### 第一章 预备知识

#### C语言原则

1.结构化编程：将过程结构化，强调算法的过程性

2.自顶向下：大型任务逐渐分解成小任务，直到任务简单易完成

程序 = 算法 + 数据

#### 面向对象

1.试图让语言满足问题的需求，设计与问题本质特性相对应的数据格式

2.类：数据+对于数据的操作

3.自下而上：低级组织（类）到高级组织（程序）

#### 泛型编程

独立于特定数据类型的代码重用和抽象通用技术。比如只写一个排序函数可以对整数、小数、字符串、甚至用户定义的复合结构进行排序

#### 可移植性

不修改代码，重新编译之后可以运行

#### 程序运行

编辑：高级语言

编译：高级语言->机器语言，目标代码

链接：将目标代码与库函数目标代码以及标准启动代码组合起来，可执行代码

### 第二章 入门C++

#### 2.1 第一节

##### main函数

1.操作系统-->启动代码-->main函数

2.程序必须从main函数开始运行。例外：比如Windows中可以编写DLL动态链接库模块供其它程序调用，因此DLL不需要main函数

##### 预处理

主编译之前的对源文件进行预处理操作。

比如#include <iostream>这个编译命令将iostream文件替换预处理命令

##### 头文件

![2-1.1](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\2-1.1.png)

##### 命名空间

```c++
using namespace std;
```

using编译指令，使用某个命名空间。比如两个命名空间可以有相同的函数：

```c++
NameS1::fnc1()
NameS2::fnc2()
```

即iostream中的cout函数相当于这样编写：

```c++
std::cout << endl;
```

##### cout

预定义对象（即使不知道对象内部情况依然可以使用它）

![2-1.2](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\2-1.2.png)

##### 控制符endl与换行符\n

控制符endl：对于cout来说有特殊含义，保证程序继续运行前刷新输出（立即显示在屏幕上）

换行符\n：不能保证立即刷新输出

#### 2.2 第二节：语句

##### 变量

声明指出要存储的数据类型和对存储在这里的数据使用的名称。

定义声明：简称为定义，意味着编译器为变量分配内存空间。

引用声明：命令计算机使用在其他地方**定义**的变量。

通常，声明不一定是定义？？

尽可能在首次使用前声明变量。

##### 赋值

将值赋给存储单元。

与C不同，C++允许连续赋值。

##### cout处理字符串与整数

说明cout能够根据运算符<<后面的数据类型调整行为（运算符重载）。

##### 类简介

类：类型

对象：变量

类定义了数据以及对于数据的操作（使用类方法和运算符重载）。

类方法本质是函数调用。

运算符重载类似于将某个“消息”通过指定的运算发发给对象进而激发某种行为。

##### 函数

每个函数需要指出函数原型。1.在源代码文件中 2.在头文件中

函数原型说明了参数类型（输入）和返回值类型（输出）

函数定义与函数原型不同。

函数定义不允许嵌套在另一个函数定义中。

函数：1.函数头和函数体 2.参数 3.返回值 4.函数原型

##### 多函数中使用using编译指令

最好只让需要访问命名空间的函数访问它。即在函数体内使用using。

或者是在特定的函数中使用类似

```c++
using std::cout
```

的编译指令。

### 第三章 处理数据

面型对象编程的本质是设计并扩展自己的数据类型。设计自己的数据类型就是让类型与数据匹配，如果正确做的这一点，以后使用数据会很方便。

#### 3.1 简单变量

变量名：1.两个下划线和一个下划线加首字目大写的变量保留给编译器及其使用的资源（实现）使用 

2.命名方式可以选择下划线隔开或者驼峰法 3.可以增加类型前缀

##### short int long long

一般情况下：

| 整数类型  | 字节数 | 范围         |
| --------- | ------ | ------------ |
| short     | 2      | -32767~32767 |
| int       | 4      | 10^9         |
| long      | 4      | 10^9         |
| long long | 8      | 10^18        |

##### 运算符sizeof与预处理命令#define

sizeof类型必须加括号，变量可以不加。返回单位是字节数。

#define命令在编译前把所有值进行替换。

##### 初始化

c++特有的初始化方式：

```c++
int a(12);
```

c++11中使用的初始化方式：大括号初始化器给单值变量赋值

```c++
int a{7};
int rh = {12};
int ros{};
int pp = {};
```

空大括号表示为0。

这种方式有助于防范类型转换错误。

##### 无符号类型

最大值最小值在climits库中

c++保证了无符号整型上溢下溢是一种循环行为，但是不保证符号整型上溢下溢时不会出错。

##### 整型字面量（常量）

十进制：首位为1~9

八进制：首位为0

十六进制：前两位为0x或者0X

cout控制符dec、hex、oct控制十、八、十六进制，相当于给cout对象发送一个消息告诉整型应该以何种格式输出。

例如：cout << hex

##### 确定常量的类型

编译器默认把整型常量存储为int类型，除非：

1.后缀：l或者L表示long类型常量，u或U表示unsigned int，ul（任意顺序、大小写）表示unsigned long，C++提供了ll或LL表示long long类型，ull、Ull、uLL和ULL表示unsigned long long类型

2.值太大无法存储为int，十进制可选int、long、long long，八进制和十六进制选择int、unsigned int 等无符号中最小的类型

##### char类型

字符常量：单引号表示字符，双引号表示字符串。

```c++
char ch;
cin >> ch;
```

如果输入5按回车键，那么读取字符'5'，将其对应的字符编码53存储在变量ch中；

```c++
int ch;
cin >> ch;
```

如果输入5按回车键，那么读取字符'5'，将其转化为数字值5存储在变量ch中。

根据ch的类型，对象cout选择不同的操作。

cout.put()：显示一个字符。

##### char字面值（常量）

单引号括起来。

转义字符：

![image-20230221191231696](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\3-1.1.png)

##### 通用字符名

源字符集：用来编写代码的字符集。

执行字符集：程序执行期间可处理的字符。

允许提供扩展字符。使用的是通用字符名：

\u后面8个十六进制位或者\U后面16个十六进制位

##### signed char和unsigned char

char默认情况下既不是没有符号也不是有符号，是否有符号由C++实现决定，即由编译器开发人员决定。但是可以显式地声明类型位有符号和无符号。

##### wchar_t

当程序所处理的字符集无法用一个字节表示时：

1.如果更大的字符集是实现（编译器及其使用资源）的基本字符集，则编译器厂商可以将char定义为16位；

2.一种实现同时支持基本字符集和更大的扩展字符集，那么char表示基本字符集，wchar_t表示扩展字符集。其中后者与底层类型undelying类型相同，取决于实现，有可能是usigned short（2字节）也有可能是int（4字节）。

wcin和wcout处理wchar_t流，前缀L表示宽字符常量和宽字符串。

##### char16_t和char32_t

由于wchar_t的宽度随实现不同而不同，因此就有了固定长度的char16_t和char32_t，二者均为无符号。分别使用前缀u和U。

##### bool类型

非零值（数字值以及指针值被隐式转换）表示true，零为false。

#### 3.2 const限定符

常量的名称应该指出常量表示的内容。使用const限定符定义和初始化常量，作用与#define一样，但是好处在于：1.指定类型 2.作用域限制在指定块中 3.可用于更加复杂的类型比如数组和结构体

ps：C++中可以使用const值声明数组长度，而C不行。

#### 3.3 浮点数

浮点数：带小数部分的数字

可以简单理解为浮点数存储时分为基准值和缩放因子，比如34.123可以存储为0.34123和缩放因子100

浮点数书写方式：

1.浮点格式：1.23

2.E表示法：

![image-20230222112641834](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\3-3.1.png)

##### 浮点类型

描述有效数位和允许的指数最小范围。比如14176的有效位就是5。

关于有效位和尾数的说明在cfloat或者float.h中

##### cout.setf()

```c++
cout.setf(ios_base::fixed, ios_base::floatfield);
```

固定小数点位置。两个参数是通过包含iostream。

##### 浮点常量

默认为double类型，float加f或者F后缀，long double加l或者L后缀。

##### 浮点数优缺点

优点是范围更大，缺点一是运算变慢，二是精度降低。

#### 3.4 算术运算符

加减乘除模

模：如果其中以一个数为负数那么结果的符号满足：(a/b)*b + a%b = a

运算符+操作数=表达式

##### 优先级和结合性

优先级列表

结合性：当两个优先级相同的运算符同时用于**同一个操作数**时是从左到右还是从右到左。

不是同一个操作数的结合性交给实现。

##### 除法分支

如果两个操作数都是整数，则执行整数除法；否则是浮点数除法。并且不同类型（比如float和double）运算时会把它们**转换为同一种类型**。

##### 类型转换

1.一种算术类型（整数和浮点数）的值赋值给另一种算术类型的值；

2.表达式中包含不同的类型时；

3.参数传递给函数时。

1. 初始化和赋值：将类型转换为接收类型。![image-20230222194426059](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\3-3.2.png)
2. {}列表初始化：不允许缩窄，即不允许变量的类型可能无法表示赋给它的值。
3. 表达式中的转换：**自动转换**：一些类型出现时就会自动转换，比如bool、char、unsigned char、signed char、short转换为int进行计算之后再根据结果变量的类型进行从int到结果类型的转换，这个过程叫**整型提升**，因为整型int计算快速可能。另外还有：如果short比int短，那么unsigned short转化为int；如果两种类型相同那么unsigned short转化为unsigned int，保证**提升时不会损失数据**。同样wchar_t被提升为**第一个宽度范围足够存储**wchar_t**取值范围**的类型：int、unsigned int、long或者unsigned long。**不同类型的转换**：![image-20230222200129876](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\3-3.3.png)![image-20230222200154637](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\3-3.4.png)
4. 传递参数时类型转换：**通常**由函数原型控制。
5. 强制类型转换：显式转换。int(变量名)或者（int）变量名。强制类型转换不会修改原变量，而是创建一个新的指定类型的值。

##### 强制类型转换运算符

一共四个，15章介绍。其中static_cast<tyname>(value)将变量原地类型转换。

##### auto声明

自动推断并转化为初始值的类型。

一般不用于简单类型推断，主要是为了STL中的复杂类型。

比如迭代器的改变：

```c++
vector<double> arr;
vector<double>::iterator pv = arr.begin()

vector<double> arr;
auto pv = arr.begin()
```

### 第四章 复合类型

#### 4.1 数组

数组：顺序存储、同类型的值

数组元素个数在声明时确定，可以是整型常量、const值、或者常量表达式，即在编译时已知的值，不能是变量，变量是在程序运行时创建的。

##### 随机访问

数组最重要的作用是可以实现随机访问任何一个元素。索引值从0开始。

##### 初始化规则

1.只有定义时能够初始化，并且不能将数组赋给另一个数组。

2.初始化列表中的值少于数组元素个数，其它元素设置为0。

3.允许不显式声明元素个数，需要在初始化列表中给出元素。

##### C++初始化数组

1.可省略等于号；

2.可不在大括号内包含任何元素，使得所有元素为0；

3.禁止缩窄转换。

#### 4.2 字符串

##### C-风格字符串

字符数组和字符串最大区别是字符串以'\0'即空字符结尾，编码值为0。

**ps：cout打印字符数组时由于最后一个元素不是空字符所以会继续向后打印，将字节解释为字符，直到遇到空字符（值为0）的字节！**

##### 字符串常量（字面值）

使用字符串常量进行字符串初始化。但是需要保证字符数组足够大，能够包含字符串所有字符再加上一个空字符。浪费一些空间没什么，因为处理字符串的函数根据空字符的位置来进行操作。

![image-20230223091908409](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\4-1.1.png)

##### 字符串常量与字符常量

字符常量是字符编码的简写表示，比如'S'是83的另一种写法。

字符串常量表示的是两个字符'S'和'\0'组成的字符串，并且实际上"S"表示的是字符串所在的内存地址。

```c++
char s = "S"
```

实际上表示把一个内存地址赋给s。

##### 字符串常量拼接

任何两个由空白（空格、制表符、换行符）分割的字符串常量会自动拼接为一个。

##### 数组中的字符串

将字符串存储到数组中可以使用：1.数组初始化为字符串常量；2.将键盘、文件输入读取到数组中。

C语言函数strlen（在cstring库中）计算字符数组中字符的个数（到第一个空字符为止）

C++可以使用cin将键盘输入存储到字符数组中。

##### C++字符串输入

关于cin：使用空白（空格、换行符、制表符）确定一个字符串的结束位置。因此在确定一个字符串之后剩下的字符均留在输入流中。

另一个问题是cin将30个字符放到大小为20的字符数组中。17章讨论。

##### 按行读取而非按词读取

1.getline

读取整行，使用换行符确定结尾，然后在输入队列中删除换行符。

第一个参数是字符数组名称，第二个参数是字符数，因为自动添加空字符，所以最多读取字符数-1个字符。

2.get

读取到换行符之后并不把换行符从队列中删除，因此下次读取时第一个字符就是换行符。

但是当get后面的参数为空（或者参数为一个char类型）时可读取下一个字符，即从队列中读取出来。（同样的函数有两个版本：**函数重载**）

ps：拼接的方式读取

```c++
cin.getline(name1, Size).getline(name2,Size)
```

因为cin.get或者getline返回一个cin对象，这个cin对象可以调用同样的方法get、getline

getline使用更方便，但是get可以用于检查停止读取的原因是由于读取了整行还是读取到换行符。

##### 空行和其他问题

空行：getline从队列开始读取，因此返回一个空字符串。get读取空行后设置失效位faikbit，接下来的输入被阻断，可以使用cin.clear恢复。

如果输入字符串比分配字符数组长，则剩余字符留在输入队列中，并且getline设置失效位。

#### 4.3 string类

除了声明与C-风格字符串不同外其他操作（初始化、访问单个元素、cin、cout等完全一样）

##### 赋值、拼接和附加

允许将一个string对象赋给另一个string对象。

允许将一个C-风格字符串和string对象与string对象相加。

##### 其他操作

C-风格字符串和C++ string类型操作对比

| 操作   | C-风格             | string对象   |
| ------ | ------------------ | ------------ |
| 复制   | strcpy(str1, str2) | str1 = str2  |
| 添加   | ctrcat(str1, str2) | str1 += str2 |
| 求长度 | strlen(str1)       | str1.size()  |

虽然C提供了strncpy和strncat指定目标数组允许最大长度作为第三个参数，但是不如string可以自动调整长度方便。

##### I/O

1.为初始化的C-风格字符串使用strlen时长度是不确定的，因为第一个'\0'即字节为0的位置不确定。

2.下面的getline不是类方法而是一个普通函数：

```c++
getline(cin, str);
```

C++在有string类之前就有了istream类，因此有处理int、double类型的类方法，但是没有处理string类型的方法。

cin>>x使用istream类中的成员函数；

cin>>str使用string类的友元函数。

##### 其它形式的字符串常量（字面值）

1.类型wchar_t、char16_t和char32_t对应的字符串常量是前缀L、u和U；

2.UTF-8：根据编码的数字值，字符可能存储为1~4个字节，前缀是u8；

3.原始字符串（raw）：字符表示的就是自己本身。R"(xxxxxx)"

要想输出括号符号即（那就更换为：R"+* xxxxx *+"，即自定义定界符，可以是任意数量，但是空格、左括号、右括号、斜杠和控制字符（制表符、换行符）除外

输入原始字符串时按下回车不仅会移到下一行，也会在字符串中添加换行符。

##### 声明和使用

结构声明：![image-20230223111325581](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\4-4.1.png)

结构使用：

C++中可以省略struct，C中不能。

##### 初始化

1.等号加上大括号

2.初始化列表

##### 结构体属性

1.与内置类型尽可能相似。其中允许成员赋值，即哪怕是结构中有数组也可以把结构体赋值给另一个结构体。

2.允许声明和创建变量一起写：![image-20230223112204393](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\4-4.2.png)

3.允许定义结构类型和一个这种类型的变量：![image-20230223112258973](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\4-4.3.png)

4.C++结构可以有成员函数，但是不推荐使用。

##### 结构数组

类型是结构体的数组。

初始化采用初始化列表的形式：

![image-20230223112503971](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\4-4.4.png)

##### 结构中的位字段

与C一样，C++允许指定占用特定位数的结构成员，使得创建与某个硬件设备上的寄存器对应的数据结构比较方便。

字段的类型是整型或者枚举，冒号后面是位数。

字段可以没有名称。

![image-20230223112914415](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\4-4.5.png)

初始化与访问与普通结构体成员相同。

#### 4.5 共用体

能够存储不同的数据类型，但是只能同时存储其中一个数据类型。

长度为最大成员长度。

两种使用方法：

1.![image-20230223114238208](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\4-5.1.png)

2.![image-20230223114309443](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\4-5.2.png)

共用体常用于节省内存以及操作系统数据结构或者硬件数据结构。

#### 4.6 枚举

创建符号常量，并且允许定义新类型。

```c++
enum color {red, orange, yellow, green, blue, violet, indigo, ultraviolet};
```

1.创建新类型color；

2.将red等作为符号常量，对应整数值0~7，称为**枚举量**；

##### 枚举变量

使用定义的**枚举类型名**可以创建**枚举变量**。

1.如果不进行强制类型转换，枚举变量只能是定义时的**枚举量**；

2.枚举只定义赋值运算符；

3.由于枚举量是整型，因此可以参与**整数提升**；

4.如果int值在枚举量取值范围内，那么可以强制类型转换int值。

枚举更常用来定义用于switch语句的符号类型，因此可以省略类型名。

##### 设置枚举量的值

1.可以显式地指定枚举量的值，但必须是整数int、long、long long。

2.默认情况下第一个值是0，未被定义的值是前面一个值+1；

3.允许创建多个值相同的枚举量。

##### 枚举的取值范围

![image-20230223150933785](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\4-6.1.png)

#### 4.7 指针

面向对象编程：在运行阶段进行决策，比如动态创建数组。

面向过程编程：在编译阶段进行决策，比如必须编译前指定数组大小。

常规变量：值是指定的量，地址作为派生量，需要用运算符&得到；

处理存储数据：地址作为指定量，值作为派生量，用*运算符对地址进行操作得到。

##### 声明以及初始化

```c++
int *p; // 表示*p是int类型
int* p; // 表示p的类型是int*
```



##### 指针的危险

创建指针的时候，分配了指针变量的内存，即用来存储地址的内存；

但是没有分配**指针指向的数据的内存**。

因此声明了指针之后，在对指针进行解除引用运算符（*）之前，将指针初始化一个确定的、合适的位置。

##### 指针与数字

指针的值是整数，但不是整型。不能把整数赋给指针，但是可以强制类型转换，指针的类型是(int*)。

##### new动态分配内存

因为变量是编译时分配的内存名，所以在运行阶段动态分配内存，只能通过指针访问。

地址本身只指出了数据对象存储地址的开始，没有指出其类型（类型决定字节数），因此需要指出指针所指向的类型。

ps：new申请的内存在堆或者自由存储区中，变量和指针存在栈内存中。

##### delete释放内存

释放指针指向的内存，但是不会删除指针（指针在栈中）。

new和delete配对使用，否则会出现内存泄露，即被分配的内存再也无法使用。

1.不要释放已经释放过的内存块；

2.不要释放声明变量获得的内存（栈中的内存）；

PS：使用delete的关键在于，释放new分配的内存，即new申请的地址，以下情况两个指针都指向同一内存块：

![image-20230223160151960](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\4-7.1.png)

可能会引发错误。

##### 使用new创建动态数组

静态联编：编译时给数组分配内存，不管用不用都会创建。

动态联编：运行时给数组分配内存，用时才创建。

1.创建动态数组new typename [size];

释放时使用delete [] p;

![image-20230223161653702](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\4-7.3.png)

##### new和delete规则

![image-20230223161448915](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\4-7.2.png)

2.动态数组访问与数组一样，不同的是指针作为变量可以进行算数运算而数组名则不行。

#### 4.8 指针、数组与指针算术

##### 指针算术

指针变量增加1，地址增加的量为指向类型的字节数。

多数情况下C++将数组名解释为数组第一个元素的地址，即arr与&arr[0]等价。但是在sizeof运算符下不是。

arr[1]与*(ptr+1)等价

数组和指针区别：

1.数组名不是变量，不可改变，指针是变量，可以变化；

2.sizeof运算数组得到的是数组的字节长度，而运算指针得到的是指针的长度。

PS：对数组名直接取地址时取的是整个数组的地址，数组的地址与数组第一个元素的地址相同，但是在地址进行算术运算+1时，前者加的是整个数组的长度，后者加的是一个元素类型长度。

![image-20230223164227259](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\4-7.4.png)

##### 指针和字符串

如果给cout提供一个字符的地址，则它将从该字符开始打印直到遇到空字符。char字符数组、char指针和用引号括起来的字符串常量都被解释为字符串中第一个字符的地址。

当字符串常量赋给一个char指针时，由于字符串常量在实现时有的编译器不允许修改，这种情况下必须使用const指针；有些编译器使用字符串字面量的一个副本表示程序中的所有该字面值，即程序中有多个相同字符串时，C++不保证字符串字面量唯一保存，因此修改其中一个可能会修改所有的字符串。总之，**字符串字面量赋给指针时该指针必须是const类型**。

**一般给cout一个指针变量都是打印地址，但是给的是char指针的话会显示字符串。**

如果需要将字符串放到数组中，初始化数组时可以使用=运算符，否则应该使用strcpy或者strncpy。

##### 动态创建结构

![image-20230223172404404](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\4-7.5.png)

两种访问方式->和.

##### 自动存储、静态存储和动态存储以及线程存储

管理数据内存的方式。

1.自动存储：函数内部定义的常规变量使用自动存储空间，被称为自动变量，函数开始时创建，结束时消亡。自动变量是一个局部变量，作用域为代码块，即花括号内。

自动变量通常在栈中，执行代码块时变量进入栈，推出代码块时从栈顶删除变量。后进先出。

2.静态存储时整个程序执行期间都存在的存储方式。静态变量的方式：一种是在函数外部定义，另一种是声明变量时使用关键字static。

可以初始化自动数组和自动结构。

3.动态存储

new和delete管理一个内存池，被称为自由存储空间或者堆。

#### 4.9 类型组合

需要注意的是，[]的优先级比*更高：

```c++
int *p[3]; // 指针数组
int (*p)[3]; //指向元素为int类型且大小为3的数组的指针
```

把变量名去掉，按照优先级来，第一个[]优先级高，所以是数组；第二个为 (*)[]，所以是指针。

##### 指向指针的指针

#### 4.10 数组的替代品



### 第五章 循环和关系表达式

#### 5.1 for循环

![image-20230223195817318](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\5-1.1.png)

##### 表达式和语句

任何值或者有效值和运算符的组合都是表达式。

赋值表达式的值定义为左侧成员的值。

表达式加上分号就是一种语句，即使这条语句没有实际意义。

智能编译器可能会跳过无意义的操作。

##### 自增（减）运算符何时生效

副作用（side effect）：指的是在计算表达式时某些值进行修改。比如a=101这个表达式修改了a的值。

顺序点：是程序执行中的一个点，在这里，进入下一步之前确保对所有的副作用都进行了评估。1.分号是顺序点 2.**完整的表达式**是一个顺序点 3.一些其它操作

**完整的表达式指的是不是另一个更大表达式的子表达式。**

![image-20230223201950359](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\5-1.2.png)

##### 前缀和后缀执行速度

![image-20230223202137931](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\5-1.3.png)

##### 递增、递减运算符和指针

![image-20230223202547047](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\5-1.4.png)

1.*++pt：先将指针递增再取出值，取的值是**自增以后**指针指向的值；

2.++*pt：先取出指针的值再将这个值递增；

3.(*pt)++：先取出指针的值再将这个值递增；

4.*pt++：先将指针递增再取出值，取的值是**自增之前**指针指向的值。

##### 组合赋值运算

![image-20230224084500503](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\5-1.5.png)

左边的操作数必须能够被赋值，如变量、数组元素、结构成员或通过对指针解除引用来标识的数据。

##### 逗号运算符

![image-20230224085206661](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\5-1.6.png)

![image-20230224085407790](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\5-1.7.png)

##### 关系表达式

![image-20230224090250549](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\5-1.8.png)

##### 比较字符串

strcmp：接收两个参数，即比较字符串的地址，这意味着参数可以是指针、字符串常量或者字符数组名。相同返回0，第一个按字符顺序排在第二个字符串之前返回负数值，否则正数。

#### 5.2 while循环

for循环知道预先执行次数，while不知道执行次数。

##### 延时循环

ctime库函数clock返回当前系统时间值，返回类型是clock_t，CLOCK_PER_SEC表示每秒钟系统时间个数，可以通过设置秒数*常量得到应该延迟的系统时间。

##### 类型别名

1.#define BYTE char

2.typedef char byte;

前者相当于替换，后者是别名的概念。

#### 5.3 do while循环

出口条件循环，循环体至少执行一次。

通常入口条件循环要比出口条件循环要好，但是do while做测试更加合理，比如需要用户输入之后对用户的输入进行测试。

#### 5.4 基于范围的for循环

![image-20230224102412791](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\5-4.1.png)

#### 5.5 循环和文本输入

cin.get(&char)中参数传递的是引用，因此可以修改传过来的变量值。

cin.get(name, Size)第一个参数是数组名（字符串的地址char*），第二个参数是大小。

##### 文件尾

1.重定向，即不从键盘获取出入，比如 gofish <fishtale使得gofish.exe程序从文件fishtale中获取输入；

2.很多OS允许以Ctrl+Z作为键盘模拟结尾；

![image-20230224104150000](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\5-5.1.png)

每次读取一个字符，知道遇到EOF的输入基本设计：

![image-20230224105235435](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\5-5.2.png)

![image-20230224105349867](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\5-5.3.png)

```c++
while (cin.get(ch)) {
	...
}
```

##### 类似getchar和putchar的cin.get

cin.get()不加任何参数与getchar类似，把字符编码值作为int返回；

cout.put(ch)类似于putchar

cin.get处理EOF时是返回符号常量EOF（通常是-1）。有些系统中char是无符号，所以无法把EOF赋给char类型，因此必须赋给int。

![image-20230224110246269](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\5-5.4.png)

#### 5.6 二维数组和指针



### 第六章 分支和逻辑运算符

循环和分支测试条件均被强制转换为bool类型，即true或者false。

#### 6.1 基本使用

##### 字符变量在参与整数运算时会整型提升

##### 防范条件运算符的错误使用

如果担心将==错写成=，可以将右值写在左边，比如3 = =x

#### 6.2 逻辑表达式

##### OR运算符II

1.优先级比关系运算符（> <等等）低；

2.是一个顺序点，即先计算左边的表达式的值再判断右边；

**冒号和逗号也是顺序点**

3.左侧为true就不会计算右侧；

##### AND运算符&&

与OR类似。

一般用char指针的数组保存一系列字符串。注意字符串字面量不允许修改。

##### NOT运算符！

优先级高于所有关系运算符和算术运算符。

and运算符优先级高于or

##### C++中可以使用and、or、和not

c语言只要包含头文件iso646.h即可

#### 6.3 字符函数库cctype

输入是字符，这些函数的返回值通常都是int，但是C++的中的for循环、while等循环测试条件强制类型转换为bool类型。

![image-20230224152250333](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\6-3.1.png)

#### 6.4 条件运算符

条件为真整个表达式值为冒号左边否则为右边。

#### 6.5 switch语句

##### 基本格式

![image-20230224152617083](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\6-5.1.png)

注意整数表达式，以及标签是整数常量表达式，比如int、char和枚举量。

注意switch语句的直落性

##### 枚举量用作标签

cin不会识别枚举量，因此常用int类型用作输入，switch语句将int值与枚举量比较时，将枚举量提升为int

#### 6.6 break和continue

#### 6.7 读取数字的循环

当cin>>n失败时（比如将char类型赋给int类型时）：

![image-20230224155022262](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\6-7.1.png)

cin>>n本质上是cin的一个方法调用，返回cin本身，如果cin位于测试条件中则被强制类型转换为bool类型。

当发现输入错误内容时：

![image-20230224155206700](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\6-7.2.png)

#### 6.8 文件输入输出

##### 文本I/O

使用cin时，输入被看作是一系列的字节，每个字节被解释为字符编码。因此不管目标类型是什么，输入一开始都是字符数据——文本数据。cin负责将文本转换为其他类型。

比如char类型：

![image-20230224162359374](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\6-8.1.png)

int类型：

![image-20230224162426853](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\6-8.2.png)

double类型：

![image-20230224162456995](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\6-8.3.png)

char数组：

![image-20230224162531261](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\6-8.4.png)

![image-20230224162606281](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\6-8.5.png)

对于输出则是相反的操作。

##### 写入文本文件

![image-20230224163219747](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\6-8.6.png)

![image-20230224163450716](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\6-8.7.png)

open方法打开已存在文件时将其长度截短为零——删除内容

##### 读取文本文件

控制台输入：

![image-20230224164211063](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\6-8.8.png)

文件输入：

![image-20230224164238611](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\6-8.9.png)

如果成功打开文件is_open()函数返回true。

读取文件的检查：

| 函数      | 作用                                            |
| --------- | ----------------------------------------------- |
| is_open() | 检查是否打开，打开为true                        |
| eof()     | 读取时遇到EOF，EOF在队列中，                    |
| fail()    | 读取时类型不匹配，字符放回原处（也可以检查EOF） |
| bad()     | 意外的问题比如文件损坏硬盘损坏                  |
| good()    | 没有任何错误返回true                            |

##### 标准格式

![image-20230224170108639](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\6-8.10.png)

### 第七章 函数

#### 7.1 函数

##### 函数定义

空函数：通常执行某种操作

![image-20230226093030396](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\7-1.1.png)

带有返回值的函数：返回值不能是数组，但是可以是结构体或对象里包含数组。

![image-20230226093620832](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\7-1.2.png)

函数原型中的变量名没有意义，相当于占位符，不必与函数定义中相同

调用时如果类型不是原型中的类型，将会进行强制类型转换。静态类型检查

#### 7.2 值传递

#### 7.3 函数和数组

传递数组实际上是传递数组首元素地址

```c++
int sumArr(int arr[], int size);
```

与传递指针类似：

```c++
int sumArr(int *p, int size);
```

##### 数组名的解释

![image-20230226095220367](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\7-3.1.png)

##### 数组和指针恒等式

![image-20230226095357524](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\7-3.2.png)



##### 传递数组标准格式

![image-20230226095849023](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\7-3.4.png)

注意数组地址不能使用sizeof 运算符准确得出数组大小。

##### C++双指针限定数组范围

第一个指针是数组首元素地址，第二个指针是数组最后一个元素后面的指针，

数组名加数组大小刚好是最后一个元素后面的指针。

##### 指针和const

变量和指针：一级间接关系

| 指针          | 变量            | 是否 |
| ------------- | --------------- | ---- |
| **const指针** | **非const变量** | 可以 |
| const指针     | const变量       | 可以 |
| 非const指针   | 非const变量     | 可以 |
| 非const指针   | const变量       | 禁止 |

禁止非const指针指向const变量，因为有可能修改const变量

二阶指针和一阶指针：二级间接关系

| 二阶指针 | 一阶指针 | 是否 |
| -------- | -------- | ---- |
| 非const  | 非const  | 可以 |
| 非const  | const    | 禁止 |
| const    | const    | 可以 |
| const    | 非const  | 可以 |

只有一阶引用时才可以将**非const地址**赋给const指针。

二阶指针不能直接指向变量，如：

```c++
int **P;
int a = 20;
*p = &a;
```

我的理解是：二阶指针未初始化，因此指向一个未知区域，*p访问的是一个未知区域，然后把未知区域的value值用于装变量a的address值

编译能通过是因为编译器不检查初始化吗？总之这个操作很危险，因为二阶指针所指向的未知区域有可能在本程序之外了。

##### const限定指针

```c++
const int *P; // 限定指针所指向的值不能改变
int * const Q = &a; // 限定指针不能改变指向
```

const限定位置决定了 *P和Q是const，即指向的值和指针本身的值（即地址）不能更改

而P和*Q可以更改，即指针本身的值（地址）和指针指向的值可以更改

```c++
const int * const S = &a; // 指针指向和指向的值均不能更改
```

#### 7.4 函数和二维数组

1.记住数组名就是一个地址，相当于指针

```c++
int data[3][4] = ......;
```

data是数组名，相当于指向第一个元素的地址（除了sizeof等例外情况下），即类似于指针，可以用*p表示；

另外第一个元素本身就是一个数组，有四个int值，因此是一个int类型的指针；

综上data的类型是指向由四个int组成的数组的指针，即：

```c++
int (*p)[4];
```

解释如下：

首先(*p)表示传递一个指针，即地址，这样解释之后把它看作：

```c++
int name[4];
```

然后这样看表示name看作是一个数组，即地址，包含了4个int类型。

综上解释为(*p)是一个指针，指向4个int类型的数组。

如果不加括号的话：

```c++
int *p[4];
```

解释为：首先和[]结合，看作是一个数组；

接着再和*结合，表示指针；

即p表示一个数组，每个元素都是int *类型，即指针。

PS：因为p[0] == *(p+0)，以及数组名本身相当于首元素地址，所以其实p[]等价于 \*p，只是4指定了元素个数；

再者，所以指针数组名相当于二阶指针，即：*p[i] = **(p+i)

2.另一种可读性更强的函数原型中的形参：

```c++
int arr[][4];
```

3.在函数内部使用时即可以当作二维数组使用也可以当作指针使用：

![image-20230227100058646](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\7-3.5.png)

#### 7.5 函数和C-风格字符串

##### C-风格字符串作为函数参数

表示C-风格字符串方式：

![image-20230227105205205](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\7-5.1.png)

因此将字符串作为函数参数传递实际上是传递第一个字符的地址，因此形参声明为char*

在函数内部通过判断是否为'\0'确定字符串结尾。

**处理字符串标准格式**：

![image-20230227105429558](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\7-5.2.png)

##### 函数返回C-风格字符串

不能直接放回字符串，可以返回字符串的首字符地址。

比如在函数内动态申请内存区域，然后再返回字符串首地址：

![image-20230227110444209](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\7-5.3.png)

#### 7.6 函数和结构

函数处理结构更像是处理普通类型，比如int等，不会像数组一样。按值传递时相当于创建一个新的结构体，然后把原结构内存的内容直接复制过去，因此再函数内使用的是一个副本。按指针传递就是直接传递原结构的地址。

#### 7.7 函数和string对象

函数对于string对象的使用类似于结构体，应该说结构体和类的使用在函数中是类似的，即可以把一个结构赋给另一个结构，一个对象赋给另一个对象。

#### 7.8 函数和array对象

这里主要是讲使用array模板，模板类型也可以是某类。

其次这里说按值传递效率低，按地址传递使代码写起来复杂，因为要考虑到*和[]的优先级问题，所以引出了引用的概念，即既可以解决按值传递复制效率低的缺点，又可以像使用变量名，而不是像使用指针一样需要解除引用。

#### 7.9 递归

允许函数调用自己，与C语言不同的是C++不允许main调用自己。

**包含一个递归调用的函数**

```c++
#include <iostream>
using namespace std;

void countDown(int x);
int main(void) {
    countDown(4);
    // system("pause");
    return 0;
}

void countDown(int x) {
    cout << "向深层递归" << x << "\n";
    if (x > 0) {
        countDown(x - 1);
    }
    cout << "向浅层返回" << x << "\n"; 
}
```

注意返回调用时是从上一层函数调用的位置继续执行。

**包含多个调用的函数**

可以讲递归理解为分治策略，将工作分为小的、相似的工作。

看不懂。

#### 7.10 函数指针

**获得函数的地址**：非常简单，函数名就是函数的地址。

```c++
int addOne(int a);
```

addOne就是函数的地址。

**声明函数指针**：声明一个指针需要指定指针指向的类型，即必须指定指针指向的函数类型。也就是说声明函数类型应该像函数原型那样指出函数的信息（返回值、参数）。

```C++
double pam(int);

double (*p)(int); // 正确的函数指针
```

解释：首先（*p）表示这是一个指针，接着指针解引用指向的是返回值类型为double和参数类型为int的函数。

![image-20230227171317811](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\7-10.1.png)

注意：

```c++
int *pt(int); // 首先pt()表示pt是一个函数，其次函数的返回值是int *即指针类型
int (*pt)(int); // 表示指向函数的指针
```

**使用指针调用函数**：1.将(*pt)当作函数名使用；2.直接把pt当作函数名

##### 恐怖的函数指针

有了函数指针定义会比较麻烦，比如下面定义一个数组，其元素是函数指针：

![image-20230227172809397](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\7-10.2.png)

```c++
const double * (*pa[3]) (const double *, int);
```

看起来复杂，其实要根据优先级来：

括号优先级最高，(*pa[3])表示这是一个数组，数组每个元素是指针，数组个数为3；

接着对于每个数组元素（指针）来说： double * item(const double *, int)表示每个item（指针）是一个函数，返回值类型是double *，参数分别为....。



指向这个函数指针数组的指针：

![image-20230227173205509](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\7-10.3.png)

在上个的定义基础上把pa替换为(*pd)，这很容易理解，即指针解引用和被指向的变量名意义上一样的，比如：

```c++
int a = 0;
int *p = &a;
```

那么a和(*p)是等价的。



通过这个指向函数指针数组的指针调用函数：

![image-20230227174555714](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\7-10.4.png)

所以还是接受函数指针调用函数比较简单。即p(a)这种形式比(*p)(a)更简单些。（p是函数指针）



注意数组名和&数组名的区别：

![image-20230227175029726](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\7-10.5.png)

其实&a相当于前面的那个指向函数指针数组的指针。

类的虚方法实现使用上述技术。

还可以使用typedef简化类型说明。

```c++
#include <iostream>
using namespace std;


//* 定义三个形式不同但是作用一样的函数
//* 作用均是返回数组中的第n个元素
const double *f1(const double ar[], int n);
const double *f2(const double [], int n); // 实际上是f1省略了数组名而已
const double *f3(const double *, int n); // 实际上等价于下面的f4
const double *f4(const double *ar, int n);


int main(void) {
    //* 首先定义一个数组
    double arr[3] = {110.1, 220.2, 330.3};

    cout.setf(ios_base::fixed, ios_base::floatfield);

    //* 指向函数的指针
    const double *(*pt1)(const double *, int) = f1;
    auto pt2 = f2; // C++自动推断类型

    //TODO 使用函数指针
    cout << "使用函数指针调用函数：" << endl;
    cout << " Address   Value\n";
    cout << pt1(arr, 1) << ":" << *pt1(arr, 1) << endl;
    cout << (*pt2)(arr, 1) << ":" << *((*pt2)(arr, 1)) << endl;

    //* 函数指针数组
    const double * (*ptArr[3])(const double [], int) = {f1, f2, f3};
    auto pa = ptArr; // auto只能用于单值推断，ptArr相当于数组第一个元素的地址
    const double *(**pb)(const double *, int) = &ptArr[0]; //! 实际上pa和pb是一样的

    //TODO 使用函数指针数组
    cout << "使用函数指针数组：" << endl;
    cout << " Address   Value\n";
    for (int i=0; i<3; i++) {
        cout << ptArr[i](arr, 1) << ":" << *(ptArr[i](arr, 1)) << endl;
    }

    //TODO 使用指向函数指针的指针
    cout << "使用指向函数指针的指针：" << endl;
    cout << " Address   Value\n";
    cout << (*pa)(arr, 1) << ":" << *(*pa)(arr, 1) << endl;
    cout << (*(*pb))(arr, 1) << ":" << *(*(*pb))(arr, 1) << endl;
    // 本质上pa与pb是相同的，只是这里C++语法中对于函数指针p来说，调用函数时p(double arr, int n) == (*p)(double arr, int n)

    //TODO 可以用pa当作函数指针数组使用，这里省略

    //* 指向函数指针数组的指针
    const double *(*(*pptr)[3])(const double *, int) = &ptArr;
    auto px = &ptArr; // 自动推断类型

    //TODO 使用指向函数指针数组的指针
    cout << "使用指向函数指针数组的指针" << endl;
    cout << " Address   Value\n";
    cout << (*pptr)[2](arr, 1) << ":" << *(*pptr)[2](arr, 1) << endl;
    //! 注意指向函数指针数组的指针如果加1的话，不能用来遍历
    cout << (*(*px)[2])(arr, 1) << ":" << *(*(*px)[2])(arr, 1) << endl;

    // system("pause");
    return 0;
}


const double *f1(const double *ar, int n) {
    return ar + n - 1;
}
const double *f2(const double ar[], int n) {
    return ar + n - 1;
}
const double *f3(const double *ar, int n) {
    return ar + n - 1;
}

```



### 第八章 函数探幽

主要是C++的一些函数新特性。

#### 8.1 内联函数

常规函数调用和内联函数调用：

![image-20230228082527344](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-1.1.png)

如果程序执行时间短于处理函数调用机制的时间，考虑使用内联函数，也就是函数功能比较简单并且重复调用的函数。

内联函数和普通参数一样都是按值传递，而C中的宏定义#define SQUARE(X) X*X 相当于替换。

**内联函数必须是非递归的。**

#### 8.2 引用变量

相当于变量的别名，通常用作函数的形参，这样就不用复制一份原变量的副本。

将&理解为引用变量的标识符，与取地址标识符是不同的用法。

int &b = a;

引用变量必须在声明时初始化，并且不能更改指向，相当于：

```c++
int &b = a;
int *const p = &a;
```

这里b和(*p)都等价于a；而&b和p等价于&a。

##### 按引用传递和按值传递

![image-20230228085103472](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-2.1.png)

##### 比较按值传递、按引用传递和指针传递

![image-20230228085230154](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-2.2.png)

![image-20230228085320823](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-2.3.png)

![image-20230228085400209](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-2.4.png)

1.比较按值传递和按引用传递，在调用时传递都是变量名的形式，使用起来也一样，只有在函数原型和定义中能看出区别；

2.比较按引用传递和指针传递，指针传递调用时需要使用变量的地址，即&a，并且在函数体内部也需要*p才能访问原变量，不如引用简单。

##### 引用的一些特性

1.修改引用变量会改变原变量的值，因此如果只是想访问原变量而不做修改那就加上const

const int &b = a；

2.一些基本变量通常不用引用传递参数买一些复杂的结构体或者对象经常使用引用传递；

3.临时变量、引用参数和const：

**如果引用参数是const，则编译器会在下面两种情况生成临时变量：**

![image-20230228092427813](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-2.5.png)

临时变量只在函数调用时存在。

![image-20230228092749300](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-2.6.png)

为什么必须是const引用才允许生成临时变量：

因为const表示函数内部不会修改原变量，因此创建临时变量就相当于按值传递，并不会改变写这个函数的意图；

否则函数内部可能会使用引用修改变量，而创建的临时变量不能满足这种意图，因此不允许。

##### 尽可能使用const引用参数

![image-20230228092827506](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-2.7.png)

##### C++11右值引用

![image-20230228092906019](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-2.8.png)

##### 引用与结构

引用比较适合函数参数传递结构或者类对象这种类型。

主要的知识点是函数的返回值为引用类型，需要注意的是，不能使得返回的引用指向一个函数内部变量（即不要返回临时变量的引用），这样当函数执行完毕之后这块内存已经不存在

返回引用两种：1.返回在一个作为参数传递给函数的引用；2.在函数中使用new创建内存，返回的引用指向这块内存（但是不要忘记使用delete，第16章讨论的autu_ptr模板和C++新增的unique_ptr可以帮助程序员自动完成释放工作）

引用返回类型与const：

![image-20230228115058568](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-2.9.png)

![image-20230228115119180](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-2.10.png)

##### 引用与对象

**C-风格字符串用作string对象引用参数**

![image-20230228165954831](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-2.11.png)

![image-20230228170035412](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-2.12.png)

##### 继承对象的引用

继承的特征是：**基类引用可以指向派生类对象，无需进行强制类型转换**。

即：可以定义一个接受基类引用作为参数的函数，在实际函数调用中，既可以把基类对象当作参数，也可以把派生类对象当作参数。

比如ostream和ofstream中的cout和fout（自己定义的）对象。

**fout与文件建立关联时，opne方法的参数是字符串，因此可以这样用指针**：

```c++
const char *s_ptr = "filename";
fout.open(s_ptr);
```

**格式化输入输出的一些方法**：

setf：

。。。



**PS：每个对象都存储了自己的格式化设置。**

##### 何时使用引用参数

![image-20230228172127180](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-2.13.png)

#### 8.3 默认参数

能够使用不同数目的参数调用同一个函数。

主要掌握i两点：

1.只需要在函数原型中声明默认参数，默认参数后面不能有非默认参数；

2.函数调用时实参从左至右依次被赋给相应的形参，不能跳过参数。

在设计类时，使用默认参数可以减少要定义的析构函数，方法、以及方法重载的数量。

#### 8.4 函数重载

也叫函数多态，允许有多个重名的函数。

关键是函数的特征标（参数数目、类型、顺序）不同。

ps：1.当函数调用时实参列表不与任何一个函数匹配时，就会发生强制类型转换，如果出现可以多个函数都可以进行强制类型转换之后匹配，就会报错；

2.类型引用和类型看作是同一种函数特征标；

3.const形参和非const形参是两种特征标，非const参数只能与非const参数匹配，const参数可以与const和非const参数匹配。

4.不能仅仅根据函数返回类型进行重载，必须特征标也不同。

##### 重载引用参数

![image-20230301195750034](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-3.1.png)

##### 何时使用函数重载

一般是函数任务基本相同，只是需要处理的数据类型不同，否则的话使用默认参数更方便，因为修改时也只需修改一个函数。

##### 名称修饰

![image-20230301202102354](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-3.2.png)

![image-20230301202122056](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-3.3.png)

#### 8.5 函数模板

使用泛型来	定义函数，即编写函数时不指出函数需要哪种数据类型，使得函数的算法对于多种数据类型都适用。

![image-20230301202532863](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-4.1.png)

![image-20230301202555518](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-4.2.png)

编译器在编译时进行的工作：

![image-20230301203038966](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-4.3.png)

![image-20230301203100146](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-4.4.png)

由此可见函数模板并没有缩短可执行程序，最终还是有两个函数的定义。

常见情形下将模板放在头文件中，需要模板时包含头文件。

##### 函数模板重载

函数模板在使用typename定义模板类型之后，可以想正常函数一样重载，并且函数模板中也可以有非模板类型。

##### 模板的局限性

比如在函数中对于数组、结构体等能进行比较等操作，解决思路：

1.允许重载运算符；

2.为特定类型提供具体化定义。

##### 显示具体化（C++98）

![image-20230301204803059](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-4.5.png)

加入希望job是一个结构体，那么在函数中就可以把两个形参当作结构体使用。

具体化就是比模板更加具体指明了某种类型，但是没完全指明。

其中：![image-20230301204952543](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-4.6.png)

##### 具体化和实例化

1.隐式实例化：就是编译器为普通模板根据类型生成函数定义的过程；

2.显式实例化：直接命令编译器创建特定的实例；

3.显示具体化：是一种模板，当出现显式具体化中生命的类型时，先于普通模板调用。在关键字template后面有<>

![image-20230301205824559](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-4.7.png)

![image-20230301205926877](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-4.8.png)

![image-20230301210016561](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-4.9.png)



##### 编译器到底使用哪个函数（重载解析）

![image-20230301210926364](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-4.10.png)

![image-20230301210952299](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-4.11.png)

**安全匹配和最佳匹配：**

![image-20230301212448992](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-4.12.png)

即符合上面这种转换的都是完全匹配。

例子：

![image-20230301212547180](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-4.13.png)

如果有多个匹配的原型，则编译器无法完成函数重载过程；如果没有最佳的可行函数，则编译器报错，一般为ambiguous（二义性）这样的词。

但是有时候即使两个函数完全匹配，仍可以完成重载解析：

1.指向**非const数据的指针和引用**优先与**非const指针和引用**匹配。比如上面的3和4优先匹配3，但是只对指针和引用起作用。

2.一个是模板函数，另一个是常规函数，则常规函数优先于模板函数（包括显式具体化）。

3.如果两个都是完全匹配的模板函数，则**较具体**的模板函数优先。比如显式具体化优先于模板隐式生成的具体化：

![image-20230302083723479](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-4.14.png)

**具体**并不一定意味着显式具体化，而是值编译器推断使用哪种类型执行的转换最少：

![image-20230302083854788](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-4.15.png)

代码例子：

```c++
#include <iostream>
using namespace std;


template <typename T>
void showArray(T arr[], int n);

// template <typename T>
// void showArray(T *ptr[], int n);

struct debts {
    char name[50];
    double amount;
};

int main(void) {
    int arr1[10]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    showArray(arr1, 6);

    debts E[3] = {{"sam", 128.12}, {"alice", 90.2}, {"bob", 2453.12}};
    double *ptrArr[3];

    for (int i = 0; i < 3; ++i) {
        ptrArr[i] = &E[i].amount;
    }

    showArray(ptrArr, 3);


    // system("pause");
    return 0;
}


template <typename T>
void showArray(T arr[], int n) {
    cout << "模板A\n";
    for (int i = 0; i < n; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// template <typename T>
// void showArray(T *ptr[], int n) {
//     cout << "模板B\n";
//     for (int i = 0; i < n; ++i) {
//         cout << *ptr[i] << " ";
//     }
//     cout << endl;
// }
```

目前已经不能通过了。估计规则改变了。

![image-20230302091055666](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-4.16.png)

![image-20230302091118261](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-4.17.png)

**自己选择让编译器使用哪个函数**

比如在调用函数时在函数名后、参数列表之前加上<>让编译器选择使用模板，加上<类型>让编译器显式具体化。

##### C++11关于模板的更新

1.**解决模板内部声明变量的类型问题：关键字decltype**

decltype(expression) var，关于var的类型：

![image-20230302091954216](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-5.1.png)

![image-20230302092015555](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-5.2.png)

![image-20230302092057973](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-5.3.png)

![image-20230302092220255](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-5.4.png)

2.**解决函数返回值类型问题：后置返回类型**

![image-20230302092436970](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\8-5.5.png)

### 第九章 内存模型和名称空间

#### 9.1 单独编译

将组件放在不同的文件中，以后修改只需要单独编译修改的文件再与未修改的链接即可。

一般的程序划分：

1.头文件：包含声明和函数原型等；

2.源代码文件：包含主函数运行的程序；

3.源代码文件：包含头文件中的结构、类定义，函数定义等等。

头文件中经常包含的内容：

![image-20230302170141104](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-1.1.png)

PS：包含自己编写的头文件一般用双引号，系统库的头文件一般用尖括号。

![image-20230302170259863](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-1.2.png)

PS：同一个文件中只能包含同一个头文件一次，因此可以使用下面的命令避免多次包含头文件：

![image-20230302170552579](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-1.3.png)



##### 多文件编译过程

![image-20230302170726700](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-1.4.png)

##### 多个库的链接与名称修饰

![image-20230302170834879](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-1.5.png)

#### 9.2 存储持续性、作用域和链接性

##### 存储持续性

使用不同的方案来存储数据，方案的区别在于数据保留在内存中的时间。

![image-20230302194620473](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.1.png)

C/C++内存分区，可以总体上划分为数据区和代码区（C语言中不分代码区？），数据区可以划分为：堆、栈、全局区/静态存储区、常量存储区。

![image-20230302195106700](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.2.png)

##### 作用域和链接

![image-20230302195524563](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.3.png)

##### 自动存储持续性

默认情况下，在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。

嵌套代码块时内部变量会隐藏外部代码块的重名变量。

![image-20230302200649494](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.4.png)

**PS：C++中的auto现在是自动类型推断，不再是自动变量的意义。**

**自动变量和栈实现：**

![image-20230302200817754](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.5.png)

![image-20230302200837367](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.6.png)

**PS：寄存器关键字register目前没有作用，可以理解为自动变量。**

##### 静态持续变量

![image-20230302201635182](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.7.png)

**所有的静态变量再整个程序运行期间都存在。**

无链接只能在函数内部访问，内部链接性只能在本文件中访问，外部链接可以在其它文件中访问。

**PS：如果没有初始化静态变量，那么会自动把所有位设置为0.**（指针变量也会设置为0吗？）

![image-20230302201919812](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.8.png)

![image-20230302201939714](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.9.png)

![image-20230302202258444](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.10.png)



##### 静态持续性、外部链接

![image-20230302205633663](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.11.png)

为了满足：1.在每个使用外部变量的的文件中都必须声明外部变量；2.单定义规则（ODR），指出变量只能有一次定义，C++提供了两种变量声明：

1.定义声明（defining declaration）或者简称定义（definition）：给变量分配内存空间；

2.引用声明（referencing declaration）或者简称声明：不给变量分配内存空间，只是声明引用。

所以如果想要在一个文件中使用另一个文件中**定义**的变量，需要首先进行外部变量**声明**，即加上extern关键字。被引用的变量所在的文件可以不需要在外部变量定义时加extern。

**PS：使用在头文件中定义的外部变量不需要加上外部变量声明，因为#include编译命令相当于把头文件加在文件最开始。**

**作用域解析符（：：）放在变量名前面时，表示使用变量的全局版本。**

![image-20230303153349361](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.12.png)

##### 静态持续性、内部链接

使用关键字staic限定作用域为整个文件的变量时，该变量的链接性为内部的，即只有该文件的函数可见。

而常规的外部链接性的变量其他文件也可以外部声明之后访问。

注意：

![image-20230303154402893](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.13.png)

![image-20230303154425361](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.14.png)

总结就是外部变量使得多文件程序的不同部分之间共享数据，链接性为内部的静态变量使得同一个文件的多个函数共享数据。（名称空间提供了另一种共享数据的方法）

##### 静态持续性、无链接性

创建方式：在函数内部使用static关键字。

只在该代码块中可用，但是该代码块不活动时变量依然存在。

**重点：1.在两次函数调用之间，静态局部变量的值保持不变。**

**2.如果初始化了静态局部变量，则程序只在启动时进行一次初始化（包括内部链接性和外部链接性以及无链接性），这意味着如果函数中初始化了静态变量，即使退出函数之后再次调用该函数，静态变量不会进行第二次初始化，仍然会保持上次退出代码块的值。**

##### 说明符

![image-20230304083526044](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.15.png)

##### cv-限定符

![image-20230304083605938](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.16.png)

##### mutable

指出结构体或者类变量即使为const，其某个成员也可以被修改。

![image-20230304083717358](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.17.png)

![image-20230304083736880](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.18.png)

##### const

在C++中const修饰的全局变量的链接性被修改为内部，就像使用了static一样。

所以一般在头文件中定义const全局变量，这样只要多个文件包含同一个头文件，就可以共享同一组常量。

如果不想要这种默认的内部链接性，则可以在const前面加上extern。

##### 函数链接性

1.所有函数的存储持续性默认为静态的，即整个程序执行期间一直存在；

2.函数的链接性默认为外部的，即其它文件可以调用另一个文件的函数（也可以在函数原型前面加上extern指出是在另一个文件定义的）；

3.可以在函数原型和定义前加上static，使得函数的链接性为内部，即只有本文件可以使用；这样在其它文件也可以定义重名函数；

4.单定义规则适用于非内联函数，每个非内联函数在程序中只能有一个定义。对于链接性为外部的函数，多文件程序中只能有一个文件包含函数定义，但是使用这个函数的文件必须包含函数原型（extern可选，但是如果在源代码文件中最好加上extern表示这是其他文件的函数，如果是头文件中就不用加extern了）

5.内联函数不受单定义规则约束，因此可以在头文件中定义内联函数，这样只要包含了头文件那么就有了内联函数定义，但是同一个内联函数的定义必须相同（即如果两个头文件中内联函数名字相同，那么其定义也必须相同）

##### C++查找函数过程

![image-20230304085620564](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.19.png)

##### C/C++语言链接性

![image-20230304090527372](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.20.png)

##### 存储方案与动态分配

动态内存指的是使用new（C语言中使用malloc）申请和delete释放的内存，这块内存称为堆，不受存储方案的限制。

虽然不受存储方案的限制，但是存储方案可以用来管理动态内存的自动和静态的指针变量。

比如在其他文件函数中使用指向堆的指针。

##### new运算符

1.初始化

C++98中：（1）对于内置类型，可以在类型名后面加上括号，括号里面初始化值

![image-20230304093404781](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.21.png)

（2）对于结构或者数组，需要使用大括号的列表初始化：

![image-20230304093450235](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.22.png)

C++11中允许初始化列表初始化单值变量：

![image-20230304093550157](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.23.png)

2.new失败时：

![image-20230304093616354](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.24.png)

3.new运算符调用的函数、替换函数以及sizeof运算符：

![image-20230304093708417](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.25.png)

![image-20230304093759334](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.26.png)

![image-20230304093823992](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.27.png)

4.定位new运算符：

指定需要使用的位置，因此需要将一个地址作为参数给定位new运算符。本质上就是定位new运算符把给定的地址参数转换为（void*）类型的指针。

调用格式：new (参数地址) int

但是要注意的是释放时，如果参数地址不在堆中，而是其他数据区，则不能直接释放。

5.定位new运算符的其他形式：

![image-20230304094245216](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-2.28.png)

#### 9.3 名称空间

##### 名称

名称可以是变量、函数、结构、枚举、类以及类或者结构的成员函数。

##### 传统的名称空间

1.声明区域：可以在其中进行声明的区域。比如在函数外声明的全局变量的声明区域就是所在的文件，函数中的变量其声明区域就是所在代码块

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-3.1.png" alt="image-20230305090331519" style="zoom:50%;" />

2.潜在作用域：从声明点开始到声明区域的结尾。

![image-20230305090452038](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-3.2.png)

![image-20230305090539196](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-3.3.png)

##### 名称空间

是一种新的声明区域，提供一个新的声明区域，一个名称空间（声明区域）中的名称不会与另一个名称空间的名称冲突，并且允许程序的其他部分使用该名称空间中声明的东西。



<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-3.6.png" alt="image-20230305091119597" style="zoom:67%;" />

**名称空间可以是全局的，也可以位于另一个名称空间中，但是不能位于代码块中**。默认情况下名称空间中声明的名称的链接性都是外部的。

![image-20230305090952196](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-3.4.png)



##### 不连续的命名空间

可以在单个文件中的多个块中声明命名空间，也可在多个文件中声明命名空间。 编译器在预处理过程中将各部分联接在一起，产生的命名空间中包含所有部分中声明的所有成员。

##### 域解析运算符

![image-20230305091045753](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-3.5.png)

##### using声明和using编译指令

using声明使特定标识符可用，using编译指令使整个名称空间可用

![image-20230305091312767](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-3.7.png)

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-3.8.png" alt="image-20230305091347587" style="zoom:80%;" />

![image-20230305091442636](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-3.9.png)

**相当于把名称空间添加到某一个声明区域中，在该声明区域中可以使用这些名称空间中的名称。**

##### using声明和using编译指令的不同

假设名称空间和声明区域定义了相同的名称，如果试图使用using声明导入名称则会冲突从而出错；而使用using编译指令导入名称时，局部版本会隐藏名称空间版本。

这是因为using编译指令更像是大量使用域解析运算符；using声明更像是声明了名称。

**更推荐使用using声明和域解析运算符**

##### 嵌套名称空间

名称空间中：1.可以声明其它名称空间；2.可以使用using编译指令和声明

在名称空间中使用using编译指令和声明包含的名称可以直接使用最大范围的名称空间访问。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-3.10.png" alt="image-20230305094459341" style="zoom:67%;" />

using编译指令可传递：

![image-20230305094527108](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-3.11.png)

名称空间创建别名：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-3.12.png" alt="image-20230305094624157" style="zoom:67%;" />

##### 未命名的名称空间与静态、内部链接性

![image-20230305094747022](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-3.13.png)

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-3.14.png" alt="image-20230305094815374" style="zoom: 80%;" />

##### 名称空间使用规则

![image-20230305095354074](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\9-3.15.png)

### 第十章 对象和类

面向对象的一些特性：

1.封装；

2.多态；

3.继承；

4.另一种多态（运算符重载）

#### 10.1 过程性编程和面向对象编程

过程性编程首先考虑完成任务的步骤，然后考虑具体的数据类型；

面向对象编程首先考虑数据，接着考虑对于数据的操作。

#### 10.2 抽象和类

##### 数据类型

一个数据类型包含以下定义：

1.数据对象所需内存量；

2.如何解释占据的位：比如long和float占用内存一致，但是解释方式不同；

3.数据类型不同其可以参与的操作不同。

##### C++中的类

1.类声明：包含数据类型的声明和接口函数的声明；

2.类方法定义：如何实现成员函数

##### 访问控制

对于类中成员数据所有的成员函数都可以访问。

private：外部不可访问

public：外部可访问

体现封装的特性，数据隐藏。

类中默认访问控制为private，结构中默认为public

##### 实现成员函数

特殊特征：

1.需要在函数名前面指出所属的类，即作用域解析运算符

2.成员函数可以访问所有的成员数据和其它成员函数。

内联成员函数：

1.直接在类生命中定义（无需inline，默认为内联）；

2.在类生命外部定义需要加上inline

成员函数的副本只有一份，即对象的成员数据各自有一份，但是所有对象公用一个成员函数。

#### 10.3 构造函数和析构函数

为什么需要构造函数：

1.初始化时不能采用赋值的方式给对象初始化，因为私有数据具有不可访问性（数据隐藏性），赋值本身就是一种访问；

2.即使可以定义类方法对于成员数据进行赋值，但是初始化尽量在创建的时候进行，而不是创建完成之后再调用函数。

因此需要提供一种在对象创建时进行初始化的函数——构造函数。

##### 声明和定义构造函数

构造函数在对象创建时自动调用。声明方式：

![image-20230306194445183](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.1.png)

1.函数名与类相同；

2.无返回值类型；

**成员名和参数名尽量不要相同，因此对于成员数据的命名方式有两种：**

1.使用m_成员数据前缀；

2.使用_做成员数据后缀

##### 使用构造函数

1.显式调用：

![image-20230306194703817](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.2.png)

2.隐式调用：

![image-20230306195004307](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.3.png)

使用new和、创建类对象：

![image-20230306195052079](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.4.png)

**除了对象创建进行初始化时，其它时候不能使用对象直接调用构造函数**

##### 默认构造函数

为了给创建对象时不进行初始化的对象使用。

1.如果用户没有定义构造函数，那么编译器自动生成一个无参数无任何操作的默认构造函数；

![image-20230306195315566](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.5.png)

2.如果用户定义了构造函数，那么编译器不会再自动生成默认构造函数，因此，必须在对象创建时进行初始化；

![image-20230306195422026](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.6.png)

3.如果用户定义了构造函数，就需要在定义一个默认构造函数，方法两种：（1）给已有构造函数的所有参数都是默认值；（2）通过函数重载定义另一个构造函数——没有参数的构造函数。**因为只能有一个默认构造函数，因此不要同时采用两种方式。**推荐的默认构造函数定义如下：

![image-20230306195719475](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.7.png)

有了默认构造函数就可以不对对象进行显式初始化了：

![image-20230306195812430](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.8.png)

##### 析构函数

析构函数在类对象被销毁时调用。

声明方法是：1.名称与类名相同；2.类名前面加上~；3.不能有任何参数。

什么时候调用析构函数：

![image-20230306200011507](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.9.png)

##### 关于显式调用构造函数的两种行为方式

![image-20230306200151666](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.10.png)

##### 关于使用对象给同类对象赋值的说明

默认情况下，将一个对象赋给同类型的另一个对象时，C++将源对象的所有数据成员的内容复制到目标对象的每个数据对象中。

##### 关于使用构造函数初始化已经存在的对象

![image-20230306200451490](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.11.png)

![image-20230306201945966](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.12.png)

##### C++11列表初始化

![image-20230306202023879](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.13.png)

##### const成员函数

![image-20230306202054747](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.14.png)

C++不允许第二行代码出现，因为不能保证show函数不修改const对象。

![image-20230306202151442](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.15.png)

#### 10.4 this指针

要解决的问题：成员函数可能涉及到两个或者更对同类对象的操作，使得访问成员数据显得不太方便。

传递对象是使用对象的引用，返回对象时也返回对象的引用。

![image-20230306202925410](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.16.png)

上面函数比较两个对象中谁的成员数据更大，然后返回该对象。

如果是作为参数被传递过来的对象，返回起来比较容易；

但是如果是调用这个函数的对象，如何返回？

引如this指针解决：

![image-20230306203114172](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.17.png)

![image-20230306203127387](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.18.png)

![image-20230306203144557](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.19.png)

![image-20230306203201652](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.20.png)

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.21.png" alt="image-20230306203219418" style="zoom:67%;" />

#### 10.5 对象数组

创建多个类对象的集合。

1.未显式初始化对象数组时，创建对象调用默认构造函数；

2.使用构造函数初始化数组元素：

![image-20230307084246940](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-3.22.png)

初始化对象数组的方案是：

1.首先使用默认构造函数创建对象；

2.然后花括号中的构造函数创建临时对象；

3.最后把临时对象的内容复制到对应元素。

#### 10.6 类作用域

1.在类中定义的名称其作用域为整个类，名称在类内可知，在类外是不可知的。因此不同类可以有相同成员名称。

2.同时意味着类外不能直接访问类内成员，比如成员函数的定义都需要加上类作用域。

3.构造函数被调用时因为名称与类相同，才能被识别。

综上，使用类成员名时，1.直接成员运算符（.）；2.间接成员运算符（->）；3.作用域解析运算符（::）。

##### 作用域为类的常量const

由于声明类时并不会创建对象，因此不能直接在类中创建常量类型并赋值。（C++11提供了成员初始化）

所以在类中定义常量有两种方式：

1.声明枚举：

![image-20230307085512667](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-6.1.png)

作用域为类。

2.使用关键字static

![image-20230307085605609](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-6.2.png)

##### 作用域内枚举（C++11）

![image-20230307085743274](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-6.3.png)

1.作用域内枚举不能进行整型提升，可以显式强制转换；

2.作用域内枚举的底层类型默认为int，但是可以指定底层类型。

![image-20230307085851136](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\10-6.4.png)

#### 10.7 抽象数据类型适合使用类实现

### 第十一章类的使用

#### 11.1 运算符重载

C++中运算符根据操作数的数目和类型决定使用哪种操作。比如*可以解除引用和乘法。

C++允许将运算符重载扩展到**用户定义的类型**（class）（这可能意味着运算符重载和类是绑定的？**不算绑定，可以是成员函数重载，也可以是友元函数**）。声明形式如下：

operatorOP(参数列表)；

OP必须是合法的运算符，比如+、-、[]等等。

重载之后：对象3 = 对象1 + 对象2；相当于对象3 = 对象1.operator+(对象2)；

![image-20230307210603646](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-1.1.png)



##### 重载运算符的限制

![image-20230307210944347](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-1.2.png)

**可以重载的运算符**：

![image-20230307211032596](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-1.3.png)

![image-20230307211052382](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-1.4.png)

![image-20230307211126808](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-1.5.png)

#### 11.2 友元

友元有三种：（1）友元函数；（2）友元类；（3）友元成员函数

本章只介绍友元函数。

友元函数可以像成员函数一样访问成员数据。

为什么需要友元：

比如一个运算符需要两个操作数，一个是类，一个是double（内置类型），那么只能使用对象 op double的形式。

如果想让double op 类；就需要定义一个非成员函数：

![image-20230307212102450](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-1.6.png)

但是一个问题是**非成员函数无法访问类成员数据**，因此需要友元函数。

##### 友元声明

![image-20230307212159630](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-1.7.png)

##### 友元定义

编写友元函数定义时不要使用类作用域限定符，也不要在定义中使用friend

![image-20230307212423513](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-1.8.png)

##### 也可以不使用友元...

![image-20230307212503973](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-1.9.png)

##### 常用的友元：<<运算符重载

常常使用cout来打印一个用户定义的类型（class），因此需要重载运算符<<。（实际上这个运算符早就被重载很多次了，比如cout遇见double、int的行为都不相同，说明在cout的类实现中一定对<<进行了多次重载。当然也可以以将新类型添加到ostream类定义中，但是修改标准接口总是很...）

因此可以在自定义类中重载<<运算符，此时应该是自定义类的友元函数，因为cout需要在前面，也就是运算符重载的第一个参数，类对象则作为第二个参数。

![image-20230307213743968](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-1.10.png)

![image-20230307213809258](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-1.11.png)

同时，为了实现可以连续使用<<，比如cout << int << double；

所以需要设置运算符重载的返回值为cout类对象的引用，也就是ostream &。

![image-20230307213846564](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-1.12.png)

**PS：这里的第一个参数引用是ostream类对象，但是实参可以是ostream的派生类ofstream对象。**

#### 11.4 运算符重载：作为成员函数还是非成员函数

![image-20230307214344965](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-1.13.png)

![image-20230307214407580](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-1.14.png)

目前来看，除了一些**只能是成员函数重载的运算符**，还没有明确的哪一个更好。

#### 11.5 类的例子

1.一个量的多种表示可以用一个类来实现，在一个对象中表示实体的不同方面：（1）在一个类中存储多种表示方式（可以用状态成员表示对象处理哪种表示中，比如使用类作用域内枚举量表示MODE）；（2）编写转换函数，即以一种表示方式给类对象赋值时，自动保存其它方式的表示。

2.![image-20230308085534003](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-5.1.png)

3.可以重载运算符的一元和二元版本：

![image-20230308085735548](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-5.2.png)

#### 11.6 类的类型转换和强制类型转换

对于内置类型：

1.如果类型兼容，将赋值类型转换为接收类型；

2.如果类型不兼容，不能进行赋值（比如把整数赋给指针变量）；

3.如果类型不兼容可以执行强制类型转换，比如 int *p = int(18).

对于用于定义类型：

1.对于参数只有一个的构造函数，内置类型与参数类型相同时可以执行类型转换，相当于使用构造函数创建一个临时变量，再赋值给接收对象；

2.参数2个以上的构造函数，如果除了第一个参数之外后面的所有参数都有默认值的话，也可以进行类型转换，否则不行。

关闭这种特性：在构造函数的声明前加上关键字explicit，这样组织了隐式类型转换，但是可以显式强制类型转换：

![image-20230308095827028](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-5.3.png)

##### 什么时候会调用构造函数进行隐式类型转换

![image-20230308095912100](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-5.4.png)

##### 函数原型提供的参数匹配过程

即将内置类型转换为需要的参数类型（甚至是类对象）

![image-20230308100335869](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-5.5.png)

![image-20230308100354899](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-5.6.png)

![image-20230308100427535](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-5.7.png)

##### 转换函数

**将类转换为内置类型：**

![image-20230308100715942](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-5.8.png)

##### 自动应用类型转换

如果定义了多个转换函数，并且在使用时没有显式强制类型转换，则会出现二义性错误：

![image-20230308101049196](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-5.9.png)

最好使用显式类型转换，不要让编译器使用隐式转换，因此在C++11中允许将转换运算符声明为显式的：

![image-20230308101324943](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-5.10.png)

另一种方法：

![image-20230308101425654](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-5.11.png)

##### C++为类提供的类型转换

![image-20230308101514761](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-5.12.png)

##### 友元函数与转换函数总结

1.目前对于类型转换的方法有：（1）将内置类型转换为类：使用构造函数；（2）将类转换为内置类型：转换函数。

这两种方式都可以使用explicit指定显式转换而不进行隐式转换。（1）的隐式转换是这种形式：class a = double; (2)的隐式转换是这种形式：int arrr[a];把对象a转换成int类型

关于运算符重载，以**两个类相加**为例子：（1）成员函数实现，代表只有一个参数为另一个类的引用；（2）友元函数实现，有两个参数分别是两个同类对象的引用

不可以同时定义，因为在面对下面这种形式会出现二义性：

class a = b + c; 编译器不知道调用成员函数还是友元函数。

**2.假如定义了一个参数的构造函数**（即允许内置类型转换为类）

**那么**二者都可以进行这样的加法：class a = b(class) + c(double)

此时（1）成员函数解释为： b.operator+(c)，因为定义了构造函数，因此c从double隐式转换为参数列表需要的class

（2）友元函数解释为：operator+(b, c)，因为定义了构造函数，c可以从double转换为参数列表需要的class

**PS（2）**：注意，如果恰好定义了double转换函数（即可以将类转换为double），那么就会混乱，此时出现**另一种解释方式**：将b从class转换为double，最后再把两个double转换为类对象进行引用（这是因为重载的友元加法接收两个类对象作为参数）。

**但是**只有友元可以进行这样的加法：class a = c(double) + b(class)

此时的解释为：operator+(c, b)，也就是c被构造函数转换为class

不会有上面的第一种成员函数的解释存在，因为不会对double内置类型调用成员函数。

综上，将加法重载定义为友元使得程序更容易适应自动类型转换，主要原因是友元函数重载加法的两个操作数都成为函数参数，与函数原型进行匹配。

下面以**类和内置类型**double相加为例子：

（1）友元函数：

![image-20230308104844912](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-5.13.png)

这样double会被构造函数**隐式**转换为类。

（2）加法运算符重载为显式使用double，为了double和类的都可以在加法的左边，需要定义两个：成员函数和友元函数：

![image-20230308105126901](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\11-5.14.png)

优缺点：

第一种依赖于隐式转换，即需要调用构造函数创建临时对象，所以增加了时间和空间开销；

第二种则速度更快。

如果经常使用的话还是重载运算符比较合适，但是如果只是偶尔使用依赖自动转换也可以，如果为了安全不想隐式转换，就在构造函数前加上explicit指出必须显式转换。

### 第十二章 类和动态内存分配

动态内存问题，把类对象需要多少内存放到运行时决定，而不是编译时。

#### 12.1 动态内存和类

这里的StringBad类值得好好看一下，复习了静态存储成员函数、new、delete、构造与析构函数，引出了复制构造函数。

已复现

##### 静态数据成员

类声明进行声明，但是在类方法实现文件中进行初始化，防止因为多次包含类声明头文件导致错误。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-1-1.1.png" alt="image-20230403210441991" style="zoom:80%;" />

##### 构造函数中new，析构函数中delete

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-1-1.2.png" alt="image-20230403210602869" style="zoom:80%;" />

##### 按值传递对象和将一个对象赋值给另一个对象

1.按值传递对象时，虽然不会修改源对象的值，但是函数内部目标对象的指针被释放时，源对象的指针也被修改了。这是因为按值传递就是把源对象的所有内存复制到目标对象的内存，因此两个对象的指针指向的位置是相同的。

2.将一个对象赋值给另一个对象时同样是把内存复制了一份。

**引出问题：上述两种操作都没有调用构造函数！**实际上是调用了复制构造函数。

![image-20230309113145252](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-1.1.png)

##### 特殊成员函数总览

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-1-1.3.png" alt="image-20230403210700176" style="zoom:80%;" />

显然上面的问题来源是隐式调用了赋值构造函数和赋值运算符。

隐式地址运算符返回调用对象的地址（即this指针的值）。

默认析构函数不做任何事。另外还有两个特殊成员函数：移动构造函数和移动赋值运算符，第18章讨论。

##### 默认构造函数

**1.没有提供任何构造函数：**

![image-20230309113519097](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-1.2.png)

**2.如果提供了构造函数，那么C++不会定义默认构造函数。**需要用户自己定义默认构造函数，两种方式：

（1）没有任何参数的构造函数，但是可以在函数体中设置特定值进行初始化；

（2）所有参数有默认值的构造函数。

但是不能同时定义上面两种默认构造函数，因为会出现二义性。

##### 复制构造函数

用于**初始化过程**。

![image-20230309114221911](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-1.3.png)

**1.何时调用复制构造函数**

新建一个对象并将其初始化为同类现有对象时，复制构造函数将被调用。

最常见的就是使用一个已经存在的对象初始化另一个新建的对象：

![image-20230309114750350](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-1.4.png)

程序生成对象副本时也会调用复制构造函数，具体来说，比如按值传递对象（函数参数、返回值）时都会生成对象副本。

**记住：按值传递就意味着生成副本。**

由于按值传递对象会生成副本（调用复制构造函数），所以应该按引用传递对象。

**2.默认复制构造函数的功能**

默认的复制构造函数逐个复制非静态成员的值，也就是浅复制。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-1.5.png" alt="image-20230309115213283" style="zoom:67%;" />

如果类成员是一个对象，那么就会调用复制构造函数来复制成员对象。

**静态成员**不受影响。

默认复制构造函数示意：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-1.6.png" alt="image-20230309115347764" style="zoom:67%;" />

##### 显式定义复制构造函数解决前面两个问题

1.解决需要在构造对象时更新静态变量的问题；

2.解决浅复制问题，即进行深度复制。

![image-20230309115910164](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-1.7.png)

深度复制示意：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-1.8.png" alt="image-20230309115939672" style="zoom:67%;" />

##### 默认重载赋值运算符

默认重载赋值运算符原型：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-1.9.png" alt="image-20230309120152860" style="zoom:67%;" />

**1.何时会调用默认重载赋值运算符**

将**已有对象**赋给另一个对象时，将使用默认重载赋值运算符：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-1.10.png" alt="image-20230309142318315" style="zoom:67%;" />

初始化对象时，不一定会使用赋值运算符：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-1.11.png" alt="image-20230309142501886" style="zoom:67%;" />

**2.赋值运算符的功能**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-1.12.png" alt="image-20230309142600666" style="zoom: 67%;" />

##### 重定义赋值运算符解决浅复制

赋值运算符的浅复制会带来问题，因此需要重新定义赋值运算符完成深复制。

与复制构造函数的定义有一些区别：

（1）由于目标对象（接收对象）可能引用了以前分配的数据，所以函数应该使用delete[]释放这些数据；

（2）函数应该避免将对象赋给自身，否则给对象重新赋值前的释放内存操作可能会删除对象的内容；

（3）函数返回一个对象的引用。（方便连续赋值）

一个示例：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-1.13.png" alt="image-20230309143412627" style="zoom:67%;" />

（1）**首先检查自我复制**，即检查接收对象的地址（this）是否与赋值运算符右边的对象的地址（&st）是否一致，如果一致则直接返回。

（2）**释放接收对象原本指向的内存。**（接收对象一定会有内存的，不用担心会释放没有分配的指针。因为无论是默认构造函数还是构造函数，这里都实现了为指针分配一块内存。这也指出：如果类中有指针，默认构造对象也要分配一块内存）

（2）执行深复制操作。

注意：赋值操作并不创建新对象，都是对已经存在的对象进行操作的，所以不必修改静态成员变量。

##### 总结代码

stringbad.h

```c++
#include <iostream>
#ifndef STRINGBAD_H_
#define STRINGBAD_H_
class StringBad {
private:
    char *str;
    int len;
    static int num_strings;
public:
    StringBad(const char *s);
    StringBad();
    StringBad(const StringBad &st);
    ~StringBad();

    StringBad &operator=(const StringBad &st);
    friend std::ostream &operator<<(std::ostream &os, const StringBad &st);
};

#endif
```

stringbad.cpp

```c++
#include "stringbad.h"
#include <cstring>

//* 初始化静态变量
int StringBad::num_strings = 0;

//* 成员方法
// 构造函数
StringBad::StringBad(const char *s) {
    len = std::strlen(s);
    str = new char[len + 1];
    std::strcpy(str, s);
    num_strings++;
    
    std::cout << num_strings << ":\"" << str
              << "\"" << "create\n";
}

// 默认构造函数
StringBad::StringBad() {
    str = new char[4];
    std::strcpy(str, "C++");
    num_strings++;

    std::cout << num_strings << ":\"" << str
              << "\"" << "default create\n";
}

// 复制构造函数
StringBad::StringBad(const StringBad &st) {
    len = st.len;
    str = new char[len + 1];
    std::strcpy(str, st.str);
    num_strings++;

    std::cout << num_strings << ":\"" << str
              << "\"" << "copy create\n";
}

// 析构函数
StringBad::~StringBad() {
    std::cout << str << " object delete， ";
    num_strings--;
    std::cout << num_strings << " left\n";

    delete [] str;
}

// 重载<<运算符
std::ostream &operator<<(std::ostream &os, const StringBad &st) {
    os << st.str;
    return os;
}

// 重载赋值=运算符
StringBad & StringBad::operator=(const StringBad &st) {
    if (&st == this) return *this;
    delete [] str;
    len = st.len;
    str = new char[len + 1];
    std::strcpy(str, st.str);

    std::cout << "调用了赋值运算符！\n";
    return *this;
}
```

主程序

```c++
#include <iostream>
#include "stringbad.h"
using std::cout;

void show1(StringBad &);
void show2(StringBad);
int main(void) {
    {
        cout << "----------块开始-----------\n";
        StringBad sb1("第一个字符串");
        StringBad sb2("第二个字符串长度更长");
        StringBad sb3("第三个字符串aabbccddeeff");

        // 打印对象
        cout << "-------直接打印字符串-------\n";
        cout << sb1 << '\n';
        cout << sb2 << '\n';
        cout << sb3 << '\n';

        // 函数调用
        cout << "---------按引用传递打印：----------\n";
        show1(sb1);
        cout << "------------引用传递完成之后再打印：-----------\n";
        cout << sb1 << '\n';
        cout << "----------按值传递-----------\n";
        show2(sb2);
        cout << "------------按值传递完成之后再打印：-----------\n";
        cout << sb2 << '\n';

        // 使用对象初始化对象
        cout << "------使用对象初始化新对象--------\n";
        StringBad new1 = sb3;
        cout << new1 << '\n';

        cout << "-------使用对象给已经存在的对象赋值--------\n";
        StringBad new2;
        new2 = sb1;
        cout << new2 << '\n';

        cout << "-----------块结束-----------\n";
    }
    
    return 0;
}

void show1(StringBad &st) {
    cout << st << '\n';
}

void show2(StringBad st) {
    cout << st << '\n';
}
```

#### 12.2 改进之后的新string类

除了重新定义复制构造函数和赋值运算符之外，还需要修改默认构造函数，增加比较功能（重载<、>、==运算符），增加中括号访问字符（重载中括号运算符）、增加静态成员函数。

##### 修改默认构造函数：空指针

默认构造函数也要使用申请一块内存，这是为了配合析构函数。

并且new要与delete兼容：

（1）delete [] 与new type[]和空指针兼容；

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-2.1.png" alt="image-20230310105224093" style="zoom:67%;" />

（2）delete 与new type兼容。

##### 重载比较运算符

可以使用标准的strcmp函数实现。

strcmp(char * s1, char & s2);

当前者字母顺序小于后者，返回负数，等于后者返回0，大于后者返回正数。

**重载时都声明为友元函数的好处：可以将string对象与C字符串进行比较**

**目前我感受的操作数为两个的运算符声明为友元和成员函数的区别：**由于成员函数只有对象才能调用，因此对象必须时运算符的第一个操作数；而友元函数两个操作数的顺序不是那么重要，因为C++会使用尝试将非类对象的数据类型转换为类，这个时候就使用一个参数的构造函数尝试进行类型转换。

##### 重载中括号运算符

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-2.2.png" alt="image-20230310110019412" style="zoom:67%;" />

1.简单实现：

![image-20230310110139408](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-2.3.png)

注意返回值类型为 char&，这样可以修改其中一个字符。

2.假设定义了一个常量对象：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-2.4.png" alt="image-20230310110533023" style="zoom:67%;" />

由于函数重载是区分const和非const特征标的，所以可以重载另一个中括号运算符：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-2.5.png" alt="image-20230310110659581" style="zoom:67%;" />

这样只能访问而不能修改。

##### 静态类成员函数

在成员函数声明时前面加上static，在类声明外的函数定义则不用加。

1.不能通过对象调用静态成员函数，也不能使用this指针，只能通过成员函数或者类名和作用域解析运算符访问；

2.静态成员函数不能访问成员数据，只能访问静态成员数据。

##### 进一步重载赋值运算符

当出现非string类对象时，比如出现了一个char *类型，那么将其赋值给string对象的流程时是：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-2.6.png" alt="image-20230310111309482" style="zoom:67%;" />

为了提高处理效率，可以重载一个新的函数，使其接受char *类型，示例为·：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-2.7.png" alt="image-20230310111404774" style="zoom:67%;" />

#### 12.3 在类中使用new和delete的注意事项

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-3-1.png" alt="image-20230310112013352" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-3-2.png" alt="image-20230310112038591" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-3-3.png" alt="image-20230310112119342" style="zoom:67%;" />

##### 逐成员复制和赋值：要不要重定义复制构造函数和赋值运算符

不一定需要，要理解逐个成员的意思，即**每个成员会被执行赋值运算**。如果每个成员本身是一个对象，而这个对象类中已经重定义了复制构造函数和赋值运算符。

比如：

![image-20230310112423418](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-3-4.png)

不要为Magazine类重定义。

#### 12.4 有关返回对象的说明

##### 返回指向const对象的引用

因为返回对象会调用复制构造函数生成临时对象，再将临时对象赋给函数返回值的接收对象。

所以一般采用返回对象的引用的方法。需要注意的是：返回的对象需要在执行函数调用前就存在，不能是函数中创建的局部对象。

返回const对象意味着不能对返回的对象进行修改，通常是接收函数参数有const对象时。

##### 返回指向非const对象的引用

返回非const对象通常是需要对返回的对象进行修改，比如重载<<和=运算符时。

比如重载cout的<<运算符时，如果返回的是ostream对象而非引用的话，需要调用复制构造函数，但是**ostream没有公开的复制构造函数**。

##### 返回对象

如果对象是在函数中创建的局部对象。则不能够使用引用来返回。

##### 返回const对象

如果不希望返回的对象被修改，需要将返回类型设置为const类型。

比如：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-4-1.png" alt="image-20230311090317735" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-4-2.png" alt="image-20230311090414706" style="zoom:67%;" />

#### 12.5 使用指向对象的指针

##### 使用new初始化对象

![image-20230311093444006](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-5-1.png)

##### 对象内部new创建一个指针和new创建一个对象

两个层次：1.对象内部指针指向的内存由构造函数使用new创建，析构函数使用deleete删除；

2.使用new创建一个对象的内存，使用delete删除

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-5-2.png" alt="image-20230311093802113" style="zoom:67%;" />

掉用析构函数的时机：

![image-20230311094021861](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-5-3.png)

##### 指针和对象

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-5-4.png" alt="image-20230311094345019" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-5-5.png" alt="image-20230311094403498" style="zoom:67%;" />

![image-20230311094437583](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-5-6.png)

![image-20230311094459890](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-5-7.png)

![image-20230311094514247](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-5-8.png)

##### 再谈：定位new运算符

定位new运算符：在分配内存时指定内存位置。

使用定位new运算符可能会产生的问题：

1.如果两次都用同一块内存的起始位置申请，那么第二个对象会覆盖第一个对象：

2.可以使用delete删除使用普通new运算符申请的内存，但是不能删除使用定位new创建的对象。首先是因为这块内存是使用new char[size]申请的。只能通过delete[]删除；其次即使是使用new创建的内存，然后使用delete删除这块内存，释放的是整个内存，而不是里面某个对象，因此对象的析构函数不会被调用。

**解决第一个问题：**需要程序员提供位于缓冲区的两个不同的地址，比如：

![image-20230311102038701](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-5-9.png)

**解决第二个问题：**需要显式调用析构函数（为数不多的需要显式调用析构函数的情形）

![image-20230311102344518](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-5-10.png)

同时注意：应该按照与创建相反的顺序删除，因为后创建的对象可能会依赖早创建的对象。

并且仅当所有对象被销毁后才能释放缓冲区。

#### 12.6 复习一些关于类的技术

##### 重载<<运算符

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-6-1.png" alt="image-20230311102606708" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-6-2.png" alt="image-20230311102629135" style="zoom:67%;" />

##### 转换函数

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-6-3.png" alt="image-20230311102717818" style="zoom:67%;" />

##### 构造函数中使用new的类

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-6-4.png" alt="image-20230311102820215" style="zoom:67%;" />

#### 12.7 实现队列类

##### 在类中声明结构

![image-20230313100017739](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-7-1.png)

##### 成员初始化列表

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-7-2.png" alt="image-20230313100104246" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-7-3.png" alt="image-20230313100146087" style="zoom:67%;" />

PS：**对于本身就是类对象的成员来说，使用初始化列表的效率更高**？（第十四章介绍）

##### 成员初始化列表使用括号的方式用于常规初始化

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-7-4.png" alt="image-20230313100426360" style="zoom:67%;" />

##### C++11的类内初始化

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-7-5.png" alt="image-20230313100517585" style="zoom:67%;" />

##### 禁用复制构造函数和赋值运算符方法

通常使用new的类都需要包含显式复制构造函数和执行深度复制的赋值运算符。

但是假设不想实现这个功能或者不需要这个功能，但是为了避免以后会调用这个功能，可以将所需要的方法定义为伪私有方法：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\12-7-6.png" alt="image-20230313102115260" style="zoom:67%;" />

##### 代码复现

main.cpp

```
#include <iostream>
#include <cstdlib>  // for srand(), rand()
#include <ctime>    // for time()
#include "queue.h"

bool newcustomer(double x);

int main(void) {
    using std::cout;
    using std::cin;

// set up
    std::srand(time(0));

    cout << "输入最大队列数目：";
    int qs;
    cin >> qs;
    Queue line(qs);

    cout << "输入模拟时间(小时)：";
    int hours;
    cin >> hours;
    const int MIN_PER_HOUR = 60;
    long cycle_limit =  MIN_PER_HOUR * hours;

    cout << "输入一个小时的平均顾客到达数目：";
    double perhour;
    cin >> perhour;
    double min_per_cust = MIN_PER_HOUR / perhour;

    Item temp;          // new cuntomer data;
    long turnaways = 0; // turn away because of full queue
    long customers = 0; // number of customers joined the queue
    long served = 0;    // serverd numbers
    long sum_line = 0;  // cumulative line length
    long wait_time = 0; // time until handler is free
    long line_wait = 0; // cumulative time in line

// start simulation
    for (int cycle = 0; cycle < cycle_limit; cycle++) {
        if (newcustomer(min_per_cust)) {
            if (line.isFull()) {
                turnaways++;
            } else {
                customers++;
                temp.set(cycle); // set arrived time
                line.enqueue(temp); // enter queue

            }
        }

        if (wait_time <= 0 && !line.isEmpty()) {
            line.dequeue(temp);
            wait_time += temp.ptime();
            line_wait += cycle - temp.when();
            served++;
        }

        if (wait_time > 0) wait_time--;
        sum_line += line.queueCount();
    }

// report result
    if (customers > 0) {
        cout << "接待顾客数目：" << customers << '\n';
        cout << "服务顾客数目：" << served << '\n';
        cout << "因队列满而未接待数目：" << turnaways << '\n';
        cout << "平均每分钟队列长度：";
        cout << (double)line_wait / cycle_limit << '\n';
        cout << "平均等待时间：" << (double)line_wait / served << '\n';
    } else {
        cout << "No customers!\n";
    }
    
    return 0;
}

bool newcustomer(double x) {
    return (std::rand() * x / RAND_MAX) < 1;
}
```

customer.h

```
#ifndef CUSTOMER_H_
#define CUSTOMER_H_
#include <cstdlib>

class Customer {
private:
    long arrived_time;
    int processing_time;
public:
    Customer() {arrived_time = processing_time = 0;}
    void set(long when) {
        processing_time = std::rand() % 3 + 1;
        arrived_time = when;
    }
    long when() {return arrived_time;}
    int ptime() {return processing_time;}

};

// void Customer::set(long when) {
//     processing_time = std::rand() % 3 + 1;
//     arrived_time = when;
// }

#endif
```

queue.h

```
#ifndef QUEUE_H_
#define QUEUE_H_

#include <iostream>
#include "customer.h"

typedef Customer Item;

class Queue {
private:
    enum {Q_SIZE = 10};
    struct Node {
        Item item;
        Node *next;
    };
    Node *head;
    Node *rear;
    int nums;
    const int qsize;
public:
    Queue(int qs = Q_SIZE);
    // Queue(const Queue &other);
    ~Queue();

    bool isEmpty() const;
    bool isFull() const;
    int queueCount() const;
    bool enqueue(const Item &item);
    bool dequeue(Item &item);

    // Queue &operator=(const Queue &other);

    // friend std::ostream &operator<<(std::ostream &os, const Queue &q);
};


#endif
```

queue.cpp

```
#include "queue.h"

// constructor and destructor
Queue::Queue(int qs) : qsize(qs) {
    head = rear = nullptr;
    nums = 0;
}

    // copy constructor
// Queue::Queue(const Queue& other) : qsize(Q_SIZE) {
//     nums = other.nums;
//     head = rear = nullptr;
//     Node *temp; // copy other's node
//     Node *p; // travellingly points to erver node of other
//     p = other.head;
//     while (p) {
//         if (!head) { // if there is no head
//             temp = new Node;
//             temp->item = p->item;
//             temp->next = nullptr;

//             head = rear = temp; // copy other's head
//         } else {
//             temp = new Node;
//             temp->item = p->item;
//             temp->next = nullptr;
            
//             rear->next = temp; // copy other's node
//             rear = temp; // keep rear points to the last one
//         }

//         p = p->next;
//     }
// }

Queue::~Queue() {
    // delete from head
    Node *temp;
    while (head) {
        temp = head;
        head = head->next;
        delete temp;
    }
}

// other methods
bool Queue::isEmpty() const {
    return nums == 0;
}

bool Queue::isFull() const {
    return nums == qsize;
}

int Queue::queueCount() const {
    return nums;
}

bool Queue::enqueue(const Item &item) {
    if (isFull()) return false;
    else {
        // create new Node
        Node *pnewNode = new Node;
        pnewNode->item = item;
        pnewNode->next = nullptr; // new node will be the last one

        // enter queue
        if (!head) {
            head = pnewNode;
        } else {
            rear->next = pnewNode;
        }
        nums++;
        rear = pnewNode;

        return true;
    }
}

bool Queue::dequeue(Item &e) {
    if (isEmpty()) return false;
    else {
        e = head->item;

        // delete head
        Node *temp = head;
        head = head->next;
        delete temp;

        nums--;

        return true;
    }
}

// Queue &Queue::operator=(const Queue &other) {
//     if (&other == this) return *this;
//     // delete old memory
//     Node *temp;
//     while (head) {
//         temp = head;
//         head = head->next;
//         delete temp;
//     }

//     // copy
//     nums = other.nums;
//     head = rear = nullptr;
//     // Node *temp; // copy other's node
//     Node *p; // travellingly points to erver node of other
//     p = other.head;
//     while (p) {
//         if (!head) { // if there is no head
//             temp = new Node;
//             temp->item = p->item;
//             temp->next = nullptr;

//             head = rear = temp; // copy other's head
//         } else {
//             temp = new Node;
//             temp->item = p->item;
//             temp->next = nullptr;
            
//             rear->next = temp; // copy other's node
//             rear = temp; // keep rear points to the last one
//         }

//         p = p->next;
//     }
//     return *this;
// }

// std::ostream &operator<<(std::ostream &os, const Queue &q) {
//     if (q.isEmpty()) {
//         os << "queue is empty";
//         return os;
//     } else {
//         Queue::Node *p; // travellingly points to node of queue
//         p = q.head;

//         while (p) {
//             os << p->item << "  ";
//             p = p->next;
//         }

//         return os;
//     }
// }
```

##### 运行结果

![image-20230320153800383](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-44.png)



### 第十三章 类继承

#### 13.1 基类示例

继承能够完成的工作：代码重用性

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-1-3.png" alt="image-20230313192557113" style="zoom:67%;" />



##### 构造函数使用初始化列表

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-1-1.png" alt="image-20230313144247035" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-1-2.png" alt="image-20230313144319583" style="zoom:67%;" />

##### 派生类声明形式

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-1-4.png" alt="image-20230313192658410" style="zoom:67%;" />

派生类的特征：（1）存储了基类的数据成员；（2）可以使用基类的方法。

派生类可以添加新特性：（1）派生类需要自己的构造函数；（2）派生类可以添加自己的成员数据和成员函数。

##### 派生类和基类的构造函数、默认构造函数和析构函数

创建派生类时，**首先创建基类对象**，这意味着基类需要在**进入派生类构造函数之前**被创建。C++使用**成员初始化列表**来完成这项工作。

例如：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-1-5.png" alt="image-20230313193039191" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-1-6.png" alt="image-20230313193136059" style="zoom:67%;" />

##### 派生类构造函数中的成员初始化列表

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-1-7.png" alt="image-20230313193232226" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-1-8.png" alt="image-20230313193253326" style="zoom:67%;" />

##### 派生类和基类的特殊关系

1.派生类对象可以使用基类的方法（方法不能是私有的）；

2.基类指针可以不用进行显式类型转换直接指向派生类对象；

3.基类引用可以不用进行显式类型转换直接引用派生类对象。

这种指针和引用的兼容性会带来一些特性：

1.基类引用和指针作为函数参数时既可以接收基类作为实参，也可以接收派生类。

2.可以使用将基类对象初始化为派生类对象（基类的复制构造函数的参数是一个基类引用）、可以将把派生类对象赋值给一个基类对象（基类的重载=赋值运算符是接收一个基类引用参数）

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-1-9.png" alt="image-20230313194305183" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-1-10.png" alt="image-20230313194336543" style="zoom:67%;" />

#### 13.2 继承：is-a关系

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-1-11.png" alt="image-20230313194937017" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-1-12.png" alt="image-20230313194957235" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-1-13.png" alt="image-20230313195019260" style="zoom:67%;" />

#### 13.3 多态公有继承

当派生类中某些方法与基类中的同名方法不同时，即一个方法（函数）具有多种形态，其行为随上下文而异，有两种方法实现多态公有继承：

1.在派生类中重新定义基类的方法；

2.使用虚方法。

##### virtual 声明

在基类可能会被重新定义的方法前加上关键字virtual，表示这个方法有可能不同。派生类相应的同名函数前**可以**加上这个关键字。

如果方法是通过引用或者指针而不是对象调用的，它将确定使用基类还是派生类的同名方法。

如果没有virtual，程序将根据**引用类型或者指针类型**选择方法，加上关键字virtual，程序根据引用或者指针**指向的对象的类型**选择方法。

（因为基类引用和基类指针可以指向派生类对象，所以需要根据指向的类型来选择方法）

**如果非虚：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-3-1.png" alt="image-20230313201356846" style="zoom:67%;" />

**如果是虚的：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-3-2.png" alt="image-20230313201426375" style="zoom:67%;" />

**基类的析构函数声明为virtual：**

这样是为了保证释放派生对象时按照正确的顺序调用析构函数。

##### 派生类不能直接访问基类的私有数据

派生类必须使用基类的公有方法才能访问基类的私有数据。

1.对于派生类的构造函数：使用初始化列表的方式

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-3-3.png" alt="image-20230313202022536" style="zoom:67%;" />

2.对于派生类的其他函数：如果是派生类中也有的同名函数，使用作用域解析运算符调用基类的公有方法进而访问私有成员数据；否则不用域解析运算符。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-3-4.png" alt="image-20230313202120721" style="zoom:67%;" />

##### 虚析构函数的作用

虚函数的作用是根据指针或者引用指向的对象类型来决定是使用基类还是派生类的同名方法。

如果**基类**指针或者引用指向的是**派生类**，那么在删除对象时也需要根据对象的类型调用析构函数。

虚析构函数保证了基类指针或引用在指向派生类对象被销毁时先调用派生类的析构函数再调用基类的析构函数。

#### 13.4 静态联编和动态联编

函数名连编指的是将源代码中的函数调用解释为执行特定的函数代码块。

在C中，每个函数名都对应一个函数代码块，因此根据函数名就能确定；

在C++中，由于函数重载的存在，必须查看参数和函数名才能决定使用哪个函数。

静态联编指的是在编译过程完成联编，但是由于虚函数的存在，必须根据对象的类型选择相应的方法，所以需要在程序运行时选择正确的函数代码，称之为动态联编。

##### 指针和引用的兼容性

内置类型不允许将一种类型的地址或者引用赋给另一种类型的指针或引用；

但是指向基类的引用或者指针可以指向派生类。

将派生类引用或指针转换为基类指针或者引用称之为向上强制转换，**公有继承**不需要进行显式转换。

将基类引用或指针转换为派生类指针或者引用称之为向下强制转换，如果不使用显式类型转换是不允许的，因为有可能会使用到基类没有的特性。



综上：隐式向上强制类型转换需要动态联编。

##### 虚函数与动态联编

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-4-1.png" alt="image-20230314082643620" style="zoom:67%;" />

##### 为什么有两种联编方式以及为什么不适用动态联编作为默认的

1.效率；2.概念模型

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-4-2.png" alt="image-20230314084035383" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-4-3.png" alt="image-20230314084142148" style="zoom:67%;" />

##### 虚函数工作原理

一种虚函数工作机制：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-4-4.png" alt="image-20230314084853847" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-4-5.png" alt="image-20230314084923644" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-4-6.png" alt="image-20230314084951988" style="zoom:67%;" />

**虚函数对于内存和执行速度的成本：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-4-7.png" alt="image-20230314085138104" style="zoom:67%;" />

##### 虚函数注意事项

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-4-8.png" alt="image-20230314085435097" style="zoom:67%;" />

**1.构造函数和析构函数**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-4-9.png" alt="image-20230314085510108" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-4-10.png" alt="image-20230314085542427" style="zoom:67%;" />

**2.友元**

友元不能是虚函数，因为友元不是类成员，只有成员才能是虚函数（继承关系中才会出现虚函数，友元不会被继承）。

可以让友元使用虚函数。

3.**没有重新定义**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-4-11.png" alt="image-20230314085829066" style="zoom:67%;" />

4.**重新定义将隐藏方法**

重新定义指的是派生类重新定义基类的函数，即函数名相同，函数特征标不同。

重新定义不会生成函数的两个重载版本，而是隐藏上面的版本。

如果在派生类中重新定义函数，不是使用相同的函数特征标覆盖基类声明，而是隐藏同名的类方法。

因此：

1.如果要重新定义继承的方法，应确保与原来的原型完全相同。如果返回值是基类引用或者指针，则可以修改为派生类指针或引用。（返回类型协变，允许返回类型随类类型变化而变化）：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-4-12.png" alt="image-20230314090717784" style="zoom:67%;" />

2.如果基类声明被重载了，则应该在派生类中重新定义所有基类版本（如果有多个版本的话）：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-4-13.png" alt="image-20230314091134205" style="zoom:67%;" />

#### 13.5 访问控制：protected

对于外部世界来说，保护成员和私有成员一致，即外界不能访问，只能通过公有方法访问；

对于派生类来说，保护成员和公有成员相似，都可以直接访问。

这带来的问题是：

派生类能够修改基类中受保护的成员数据。

因此：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-5-1.png" alt="image-20230314091732960" style="zoom:67%;" />

#### 13.6 抽象基类Abstract Base Class

以圆和椭圆为例子，说明is-a关系并不简单。圆是椭圆的一种，但是如果椭圆作为基类，圆作为派生类，就会有很多基类的方法和特性是派生并不需要的。

因此提出了抽象基类的概念，即抽取圆和椭圆的共同特性作为一种基类，抽象基类，然后圆和椭圆分别作为这种抽象基类的派生类。

但是抽象基类的方法有时候需要根据派生类的不同而不同，所以这个时候可以不定义具体的方法，而是声明这种方法，留给派生类区定义。

这种类中未实现的函数称为纯虚函数。

纯虚函数声明格式为前面加上virtual ，声明结尾处加上=0；

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-6-1.png" alt="image-20230314092849718" style="zoom:67%;" />

当类声明中包含纯虚函数时，不能创建该类的对象。

纯虚函数可以有函数定义。

如果所有的函数都有定义，但是仍需要把类声明为纯虚函数，那么就把一个函数原型声明为纯虚的。

**好处：**

1.可以使用基类（抽象基类）指针或者引用管理派生类（具体派生类）；

2.ABC描述了一个使用纯虚函数的接口，从ABC派生出来的具体类根据自己的特征使用常规虚函数实现这种接口。

##### 例子



##### ABC理念

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-6-2.png" alt="image-20230314093503997" style="zoom:67%;" />

#### 13.7 继承和动态内存分配

已知如果类中需要动态申请内存，即使用new和delete时，需要重新定义复制构造函数和赋值运算符。

那么继承的类如何需不需要重新定义复制构造函数和复制运算符呢？

需要分两种情况：

（1）派生类中不使用动态内存分配：不需要；

（2）否则需要。

具体例子看：

##### 派生类不使用动态内存

首先是基类的动态声明：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-7-1.png" alt="image-20230314192916360" style="zoom:67%;" />

假设有派生类：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-7-2.png" alt="image-20230314192955791" style="zoom:67%;" />

分析：

（1）析构函数：析构函数是用来销毁成员数据的，但是派生类中没有动态申请的内存，不需要主动释放。需要注意的是，派生类对象在销毁时先调用自己的析构函数，再调用基类的析构函数，所以不用担心基类的数据成员；

（2）复制构造函数：默认复制构造函数对于执行动态成员复制是不合适的，但是对于非指针和非引用类型是合适的。因为派生类中没有需要动态内存的数据成员，也不需要复制构造函数。需要注意的是，**成员复制根据数据类型采取相应的复制方式**，当复制类成员或继承的类组件时，都是使用该类的复制构造函数完成的。即派生类的	默认复制构造函数使用**基类的显式复制构造函数完成派生类对象的基类部分**，再对派生类的成员数据部分进行复制；

（3）赋值运算符：同上。类的默认赋值运算符自动使用基类的显式赋值运算符对基类组件进行赋值。

PS：派生类对象的属性也适用于本身是对象的类成员。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-7-3.png" alt="image-20230314193948220" style="zoom:67%;" />

##### 派生类使用动态内存

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-7-4.png" alt="image-20230314194026266" style="zoom:67%;" />

（1）析构函数

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-7-5.png" alt="image-20230314194059470" style="zoom: 67%;" />

（2）复制构造函数：在初始化成员列表中显式调用基类的复制构造函数，否则将调用基类的默认复制构造函数。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-7-6.png" alt="image-20230314194200072" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-7-7.png" alt="image-20230314194221859" style="zoom:67%;" />

（3）赋值运算符：使用作用域解析运算符显式调用基类赋值运算符。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-7-8.png" alt="image-20230314194301775" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-7-9.png" alt="image-20230314194337834" style="zoom:67%;" />

##### 派生类友元如何访问基类成员数据

强制类型转换为基类引用或者指针。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-7-10.png" alt="image-20230314194844217" style="zoom:67%;" />

#### 13.8 类设计指导原则

##### 编译器生成的特殊成员函数

1.默认构造函数

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-1.png" alt="image-20230314195231503" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-2.png" alt="image-20230314195259427" style="zoom:67%;" />

2.复制构造函数

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-26.png" alt="image-20230320191148028" style="zoom:80%;" />

3.赋值运算符

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-3.png" alt="image-20230314195525889" style="zoom:67%;" />

##### 其它类方法

1.构造函数

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-4.png" alt="image-20230314195605351" style="zoom:67%;" />

2.析构函数

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-5.png" alt="image-20230314195634642" style="zoom:67%;" />

3.转换

**将其他类型转换为类类型：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-6.png" alt="image-20230314195747193" style="zoom:67%;" />

**将类类型转换为内置类型：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-7.png" alt="image-20230314195914910" style="zoom:67%;" />

4.按值传递对象和传递引用

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-8.png" alt="image-20230314200008036" style="zoom:67%;" />

5.返回对象和返回引用

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-9.png" alt="image-20230314200118055" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-10.png" alt="image-20230314200144739" style="zoom:67%;" />

6.使用const

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-11.png" alt="image-20230314200255145" style="zoom:67%;" />

##### 公有继承的考虑因素

1.is-a关系

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-12.png" alt="image-20230314200416426" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-13.png" alt="image-20230314200522411" style="zoom:67%;" />

2.什么不能被继承

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-14.png" alt="image-20230314200700880" style="zoom:67%;" />

3.赋值运算符

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-15.png" alt="image-20230314200840839" style="zoom:67%;" />

**将派生类对象赋值给基类对象：只会对于基类中存在的成员进行赋值，派生类中新增的不会进行赋值：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-16.png" alt="image-20230314201047410" style="zoom:67%;" />

**将基类对象赋值给派生类对象：正常情况下会报错，除非定义（1）转换构造函数：将基类转换为派生类；（2）定义一个将基类转换为派生类的赋值运算符；（3）强制类型转换**；

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-17.png" alt="image-20230314201304316" style="zoom:67%;" />

4.私有成员和保护成员

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-18.png" alt="image-20230314201359674" style="zoom:67%;" />

5.虚方法

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-19.png" alt="image-20230314201432296" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-20.png" alt="image-20230314201519666" style="zoom:67%;" />

6.析构函数

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-21.png" alt="image-20230314201638649" style="zoom:67%;" />

7.友元函数

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-22.png" alt="image-20230314201706087" style="zoom:67%;" />

8.有关基类方法的说明：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-23.png" alt="image-20230314201813115" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-24.png" alt="image-20230314201827702" style="zoom:67%;" />

##### 类函数小结

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\13-8-25.png" alt="image-20230314201927927" style="zoom:80%;" />

### 第十四章 代码重用



#### 14.1 包含对象成员的类

本节主要是使用C++内置的string类和valarray类去实现一个student类。介绍**组合（包含）**这种机制是如何工作的。实现has-a关系。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-1-1.png" alt="image-20230315085421452" style="zoom:67%;" />

在这种情况下，类内的成员函数可以使用类string和valarray的共有接口访问和修改name和scores对象，但是类外只能通过类student的公共接口访问name和scores对象。

这种情况被描述为student类获得了其成员对象的实现，但是没有继承接口。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-1-2.png" alt="image-20230315085852158" style="zoom:67%;" />

##### valarray类

用于处理数值的类。

构造函数：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-1-3.png" alt="image-20230315085958231" style="zoom:67%;" />

常用方法：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-1-4.png" alt="image-20230315090021136" style="zoom:67%;" />

##### C++和约束

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-1-5.png" alt="image-20230315090126317" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-1-6.png" alt="image-20230315090145926" style="zoom:67%;" />

##### 初始化被包含的对象

对于继承来说，成员初始化列表中使用基类的构造函数来初始化继承的基类成员；

对于包含来说，成员初始化列表中使用类对象初始化成员对象，会调用相应的构造函数。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-1-7.png" alt="image-20230315090432531" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-1-8.png" alt="image-20230315090450091" style="zoom:67%;" />

#### 14.2 私有继承

私有继承：基类的保护和公有成员都成为派生类的私有成员。

这意味着基类的公有方法都成为派生类的私有方法。但是派生类继承了基类的成员组件实现。

因此私有继承和包含都是实现has-a关系，并且均继承实现，不继承接口。

私有继承和包含区别1：私有继承中只有无名称的子对象（通过继承或者包含添加的对象）成员，包含中的子对象是有显式名称的。

##### 初始化基类组件

由于区别1的存在，因此派生类初始化子对象时在成员初始化列表中使用的是类名的构造函数形式。（区别2）

##### 访问基类的方法

私有继承：只能在派生类方法中使用基类名和作用域解析运算符调用基类的方法，派生类外部无法直接调用。

包含：在类内部使用对象名调用方法。

##### 访问基类对象

由于私有继承的子对象没有名称，要想访问子对象只能通过强制类型转换把派生类转换为基类对象，转换结果就是继承的子对象类型。如：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-2-1.png" alt="image-20230315092109826" style="zoom:67%;" />

##### 访问基类的友元函数

前面提到的使用类名限定函数名不适合友元函数，因为友元函数不是基类的函数。

因此如果需要调用基类的友元函数，可以把派生类显式转换为基类。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-2-2.png" alt="image-20230315092448179" style="zoom:67%;" />

**在不进行显式强制类型转换情况下：**

派生类的引用不会自动转换为基类的引用（因为不能将派生类的引用或指针赋给基类引用或指针，因为派生类可能会有基类没有的特性）

如果不使用显式类型转换的话，下面的代码与派生类友元函数原型匹配，导致无限循环调用：

```
os << stu;
```

另外一个原因是在多重继承情况下，编译器无法确定转换为哪个基类（如果两个基类都提供了相同的友元函数）。

##### 使用包含还是私有继承

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-2-3.png" alt="image-20230315094025496" style="zoom:67%;" />

##### 保护继承

基类的公有成员和保护成员都成为派生类的保护成员。和私有继承一样，派生类中能使用基类的接口，派生类外无法访问。

保护和私有的主要区别体现在第三代：使用私有继承时，第三代类不能使用基类的接口，因为基类的公有方法在二代中是保护，在三代中是私有；

使用保护继承时，基类的公有方法在二代中是保护的，三代中也是保护的，可以访问。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-2-4.png" alt="image-20230315094723764" style="zoom:67%;" />



##### 使用using重新定义访问权限

在使用保护派生和私有派生时，基类的公有方法成员保护或私有成员，派生类外部无法访问。

如何让基类公有方法在派生类外部使用：

1.在派生类中定义一个使用基类方法的函数：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-2-5.png" alt="image-20230315095135100" style="zoom:67%;" />

2.将函数调用包装在另一个函数调用中，即使用using声明来指出派生类可以使用特定的基类成员：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-2-6.png" alt="image-20230315095428870" style="zoom:67%;" />

PS：注意using声明只使用成员名，不要圆括号、特征标和返回类型。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-2-7.png" alt="image-20230315095556090" style="zoom:67%;" />

**一种老式方法即将停用：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-2-8.png" alt="image-20230315095710032" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-2-9.png" alt="image-20230315095726140" style="zoom:67%;" />

#### 14.3 多重继承

MI（multiple inheritance）：有多个直接基类的类。

以下面这个例子：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-1.png" alt="image-20230315151443756" style="zoom:67%;" />

当SingingWaiter同时继承Singer和Waiter时会出现的问题：

（1）有多少祖先基类Worker？

（2）哪个方法？

##### 有多少基类Worker

SingingWaiter有两个Worker的组件。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-2.png" alt="image-20230315151653257" style="zoom:67%;" />

![image-20230315151713819](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-3.png)

**解决方法：虚基类**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-4.png" alt="image-20230315151801415" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-5-2.png" alt="image-20230321170019611" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-5.png" alt="image-20230315151827686" style="zoom:67%;" />

1.声明为虚：与虚函数没有什么关系，更像是关键字virtual的重载

2.为什么不都用虚基类：一是有些情况不需要虚基类；二是虚基类为需要额外的计算资源

3.缺点：需要对C++规则进行调整，以不同的方式编写一些代码。

**新的构造函数规则：**

普通的继承构造函数：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-6.png" alt="image-20230315152324682" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-7.png" alt="image-20230315152347861" style="zoom:67%;" />

**虚基类构造函数：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-8.png" alt="image-20230315152419254" style="zoom:67%;" />

##### 哪个方法

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-9.png" alt="image-20230315152807862" style="zoom:67%;" />

1.对象使用作用域解析运算符来说明使用哪个基类的方法：

![image-20230315153036367](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-10.png)

但是这方法没办法展示另一个基类的组件。

2.在派生类中重新定义同名函数，调用基类的方法（单继承常用做法），但是需要做一些修改，因为加入继承两个基类，在派生类的方法中调用其中一个基类的方法会漏掉另一个基类的组件，如果两个基类的方法都调用那么就调用了祖父类的方法两次。

因此需要**模块化**的方式：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-11.png" alt="image-20230315153455586" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-12.png" alt="image-20230315153512733" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-13.png" alt="image-20230315153738810" style="zoom:67%;" />

3.把所有的数据组件都设置为保护的。这种方法不常用，不如使用保护方法能够更加严格控制对于数据的访问。

##### 总之

如果有MI共同祖先基类，必须使用虚基类，并修改构造函数初始化列表（添加祖先基类的构造函数）。

另外，如果如果一些没有考虑好的函数需要重新编写。

##### 虚基类其他问题

1.混合使用虚基类和非虚基类

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-14.png" alt="image-20230315154449846" style="zoom:67%;" />

2.虚基类和函数优先级

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-15.png" alt="image-20230315154917018" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-16.png" alt="image-20230315154932101" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-17.png" alt="image-20230315155030171" style="zoom:67%;" />

##### MI小结

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-3-18.png" alt="image-20230315155227913" style="zoom:67%;" />

#### 14.4 类模板

继承和包含可以完成一部分代码重用，但是对于类型不同但是操作相同的类无法实现重用，因此需要模板类。

模板类比如容器类，保存的成员数据类型不同，但是基本操作类型代码都是相同的。

模板类将类型参数化传递然后构建类。

##### 模板类和模板成员函数定义

模板类声明：

在类前面加上template \<class Type\>

![image-20230315201255746](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-1.png)

模板成员**函数定义**修改：函数声明不用修改

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-2.png" alt="image-20230315201414566" style="zoom:67%;" />

PS：**模板类与模板成员函数定义最好在一个头文件中**，因为模板不是函数，不能单独编译，模板必须与特定的模板实例化请求一起使用；

**模板必须实例化才能生成模板类，即根据传递的类型创建不同的类**：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-3.png" alt="image-20230315201805198" style="zoom:67%;" />

##### 进一步探究模板类：使用指针类型作为参数类型

可以使用指针类型作为模板类的参数类型，但是要注意模板类只能管理指针变量，不能为指针创建空间。也不能管理指针指向的空间。

**类中可以用classname替代classname \<Type\>**，类外写函数定义时不能。

书上的例子可以看看。

##### 数组模板的例子和非类型参数

**1.非类型参数：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-4.png" alt="image-20230315210339371" style="zoom:67%;" />

限制：

（1）**表达式参数**可以是整型、枚举、引用或者指针。比如可以使用double* 但是不能是double；

（2）模板代码不能修改参数的值，也不能使用参数的地址，即类模板中不能有n++或者&n这种表达式；（我猜测由于模板类是根据传入参数生成类的声明，而类的声明应该是代码区，因此这个表达式参数应该是在代码区，因此不允许访问和修改，连地址也不能访问）

（3）实例化模板时，用作表达式参数的值必须是常量表达式。

与使用动态内存的优缺点对比：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-5.png" alt="image-20230315210810844" style="zoom:67%;" />

##### 模板的多功能性

可以将常规类的技术用于模板类。

（1）模板类做基类；（2）模板类做组件；（3）模板类做其它模板的类型参数。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-6.png" alt="image-20230316083837066" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-7.png" alt="image-20230316083905316" style="zoom:67%;" />

1.递归使用模板：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-8.png" alt="image-20230316083945085" style="zoom:67%;" />

2.使用多个类型参数

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-9.png" alt="image-20230316084028869" style="zoom:67%;" />

3.默认类型模板参数

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-10.png" alt="image-20230316084131991" style="zoom:67%;" />

##### 模板具体化

隐式实例化、显式实例化、显式具体化统称为具体化。

模板以泛型的方式描述类，具体化是使用具体的类型生成类声明。

1.隐式实例化

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-11.png" alt="image-20230316084807138" style="zoom:67%;" />

2.显式实例化：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-12.png" alt="image-20230316084851863" style="zoom:67%;" />

3.显式具体化：跟函数模板一样，有些时候一些特定类型的处理方式与普通类型不同，需要对这种特定类型进行不一样的处理，即对模板进行修改，使其行为不同。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-13.png" alt="image-20230316085056126" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-14.png" alt="image-20230316085136964" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-15.png" alt="image-20230316085159497" style="zoom:67%;" />

4.部分具体化

**（1）格式：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-12-1.png" alt="image-20230321184239855" style="zoom:67%;" />

**（2）优先级：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-16.png" alt="image-20230316085756895" style="zoom:67%;" />

​	**（3）为指针提供特殊版本：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-17.png" alt="image-20230316090000575" style="zoom:67%;" />

**（4）部分具体化能够做多种限制：**
<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-18.png" alt="image-20230316090225395" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-19.png" alt="image-20230316090241230" style="zoom:67%;" />

##### 成员模板

将模板用作结构、类或模板类的成员。

书上的例子：在模板类中使用模板类：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-20.png" alt="image-20230316102729537" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-22.png" alt="image-20230316102849001" style="zoom:67%;" />



参数类型在成员函数中使用：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-21.png" alt="image-20230316102821791" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-23.png" alt="image-20230316102930321" style="zoom:67%;" />

类外定义模板方法：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-24.png" alt="image-20230316103056267" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-25.png" alt="image-20230316103140168" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-26.png" alt="image-20230316103159759" style="zoom:67%;" />

##### 将模板用作模板参数

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-27.png" alt="image-20230316103620364" style="zoom:67%;" />

**可以混合使用模板参数和常规参数：**

![image-20230316103944289](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-28.png)

![image-20230316104019048](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-29.png)

##### 模板类和友元

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-30.png" alt="image-20230316105050074" style="zoom: 67%;" />

**1.模板类的非模板友元函数：**

（1）声明：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-31.png" alt="image-20230316105429763" style="zoom:67%;" />

（2）提供模板类参数作为友元函数参数：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-32.png" alt="image-20230316105521069" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-34.png" alt="image-20230316105542951" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-40.png" alt="image-20230322102745185" style="zoom:80%;" />

**2.模板类的约束模板友元函数：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-35.png" alt="image-20230316105820392" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-36.png" alt="image-20230316105921525" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-37.png" alt="image-20230316105938130" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-41.png" alt="image-20230322102905750" style="zoom: 80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-42.png" alt="image-20230322103006411" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-43.png" alt="image-20230322103040667" style="zoom:67%;" />



3.**模板类的非约束模板友元函数：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-38.png" alt="image-20230316110219852" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-44.png" alt="image-20230322103137352" style="zoom:67%;" />

![image-20230322161258381](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-45.png)

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-46.png" alt="image-20230322161401290" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-47.png" alt="image-20230322161426826" style="zoom:80%;" />

##### 模板别名（C++11）

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\14-4-39.png" alt="image-20230316110647784" style="zoom:67%;" />







### 第十五章 友元、异常和其它

#### 15.1 友元

##### 友元类

不仅函数可以是友元，类也可以是友元。

友元类描述这样一种关系：一个类可以改版另一个类的私有成员数据，比如遥控器类可以改变电视类的状态。

**友元声明：**

friend class Remote；

友元声明可以位于公有、私有、保护部分，但是需要注意的是，声明和定义的关系，这里是遥控器类会使用到Tv类的数据，因此编译器在实现遥控器类时必须已经知道了Tv类，最简单的方法是把Tv的定义写在Remote类之前。

这样所有Remote的成员函数都可以访问Tv类的所有成员

##### 友元函数以及声明、定义顺序

一个类并不需要所有的成员方法都去访问另一个类的成员数据，所以可以将特定的成员函数设置为另一个类的友元。

友元类图：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-1-4.png" alt="image-20230319164807424" style="zoom:50%;" />

友元函数图：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-1-5.png" alt="image-20230319164840961" style="zoom:50%;" />

总结来说就是，假如类A中的成员函数（非内联）想要修改B类中的成员数据，函数和类的声明和定义顺序为：

```c++
class B; // B的前向声明
class A { // A的定义
    ...
}
class B { // B的定义
    ...
}
```

例子：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-1-1.png" alt="image-20230319164146946" style="zoom: 80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-1-2.png" alt="image-20230319164237101" style="zoom:80%;" />

**内联函数**

加入类A中的成员函数（内联）funcA想要修改B类中的成员数据，函数和类的声明和定义顺序为：

```c++
class B; // B的前向声明
class A { // A的定义
    funA的声明;
}
class B { // B的定义
    ...
}
(inline)funA的定义;
```

例子

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-1-3.png" alt="image-20230319164658662" style="zoom:67%;" />

##### 内联函数的链接性是内部的

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-1-6.png" alt="image-20230319164945133" style="zoom:67%;" />

##### 互为友元关系

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-1-7.png" alt="image-20230319165029459" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-1-8.png" alt="image-20230319165144663" style="zoom:67%;" />

##### 共同的友元

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-1-9.png" alt="image-20230319165323063" style="zoom:67%;" />

![image-20230319165342032](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-1-10.png)

#### 15.2 嵌套类nested class

![image-20230319170506943](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-2-2.png)

通常是为了帮助另一个类的实现，比如在队列类中声明结点类。

**嵌套类的函数的定义也可以写在另一个文件中，但是必须使用两次作用域解析运算符**

![image-20230319170645888](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-2-3.png)

##### 嵌套类的访问权限

**1.作用域**

（1）私有部分声明：只有类内能够使用；

（2）保护部分声明：派生类和基类内能够使用；

（3）公有部分声明：类外部可以使用，但是必须使用类限定符：class::nested class

嵌套类、结构和枚举类型说明：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-2-4.png" alt="image-20230319171107499" style="zoom:67%;" />

**2.访问控制**

简单来说就是类也不能访问嵌套类中的封装数据

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-2-5.png" alt="image-20230319171254810" style="zoom:67%;" />



#### 15.3 异常

运行阶段遇到错误如何处理。

例如遇到除数为0的情况，下面是两种简单的处理方式：

1.调用cstdlib的abort()函数，向标准错误流cerr发送abnormal program termination，这样做程序终止；

2.修改函数，使得函数返回错误码，比如bool值，然后函数原来的返回值装在一个引用或者指针中返回。这种方式就是让程序员检查返回值。

##### 异常机制

三个部分组成：

1.引发异常：if ... throw

2.使用处理程序捕获异常：catch(类型) {...}，其中类型是throw抛出的对象的类型；

3.使用try

```c++
int main(void) {
	try {
        func();
    } catch (type1) {
        
    } catch (type2) {
        
    } ...

}

void func() {
    if (...) {
        throw "error"; // 或者一个对象
    }
}
```

![image-20230319202824069](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-1.png)

（1）try块：

![image-20230319202903546](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-2.png)

(2)throw：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-3.png" alt="image-20230319203000434" style="zoom:67%;" />

（3）catch块：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-4.png" alt="image-20230319203049135" style="zoom:67%;" />

![image-20230319203124505](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-5.png)

##### 将对象用作异常类型

即使用throw抛出一个异常对象：

```c++
throw ErrorClass(构造函数参数列表);
```

使用catch接收类类型：

```
catch(ErrorClass &bg);
```

##### 异常规范和C++11

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-6.png" alt="image-20230319203740083" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-7.png" alt="image-20230319203802985" style="zoom:67%;" />

##### 栈解退

**C++函数调用和返回：**

![image-20230319204632950](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-8.png)

**函数出现异常而终止：**

![image-20230319204737952](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-9.png)

![image-20230319204809339](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-10.png)

书中的连续返回的例子：主要说明两点：

1.栈解退会释放从throw到合适的catch中间的所有的自动变量，对于**对象会调用析构函数**；

2.throw抛出异常后，会一直向栈底解退，不是遇到catch就停止，而是**遇到合适的异常类型**（即catch后面括号里的类型）才停止。

##### 其它异常特性

1.throw总是将控制权交给上一个拥有合适的catch块的函数，函数调用是将控制权交给调用它的函数；

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-12.png" alt="image-20230319210121957" style="zoom:80%;" />

2.

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-13.png" alt="image-20230319210224329" style="zoom:67%;" />

PS：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-14.png" alt="image-20230319210518299" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-15.png" alt="image-20230319210635976" style="zoom:80%;" />

**默认捕获的异常：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-16.png" alt="image-20230319210732342" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-17.png" alt="image-20230319210807272" style="zoom:80%;" />

##### exception类

异常的目的主要是为**设计容错程序**提供语言级支持。异常这种特性可以改变编程方式。

exception头文件中有一个exception类，可以把它用作其他异常类的基类。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-18.png" alt="image-20230319211522279" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-19.png" alt="image-20230319211600505" style="zoom:80%;" />

**1.stdexcept异常类：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-20.png" alt="image-20230319211954750" style="zoom:80%;" />

![image-20230319212017636](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-21.png)

**logic_error类：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-22.png" alt="image-20230320082218064" style="zoom:80%;" />

**runtime_error类**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-23.png" alt="image-20230320082630231" style="zoom:80%;" />

**综合使用：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-24.png" alt="image-20230320082736181" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-25.png" alt="image-20230320082805965" style="zoom:80%;" />

**2.bad_alloc异常和new**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-26.png" alt="image-20230320083023173" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-27.png" alt="image-20230320083104584" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-28.png" alt="image-20230320083432567" style="zoom:80%;" />

**3.空指针和new：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-29.png" alt="image-20230320084223804" style="zoom:80%;" />

##### 异常、类和继承

![image-20230320090928810](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-30.png)

书上的例子：基类中组合了一个异常类，派生类继承基类，并且基于基类的嵌套异常类派生出一个新的异常类。

##### 异常也会出现问题

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-31.png" alt="image-20230320091758984" style="zoom:80%;" />

**未捕获异常：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-32.png" alt="image-20230320092206676" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-33.png" alt="image-20230320092227412" style="zoom:80%;" />

**意外异常：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-34.png" alt="image-20230320092535973" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-35.png" alt="image-20230320092601718" style="zoom:80%;" />

![image-20230320092858173](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-36.png)

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-37.png" alt="image-20230320093115548" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-38.png" alt="image-20230320093140126" style="zoom:80%;" />

##### 异常的注意事项（动态内存分配与栈解退）

![image-20230320093835026](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-40.png)

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-41.png" alt="image-20230320093912816" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-42.png" alt="image-20230320094003577" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-43.png" alt="image-20230320094052725" style="zoom:80%;" />

#### 15.4 RTTI

RTTI（Runtime Type Identification），运行阶段类型识别。

##### 为什么需要RTTI以及用途

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-45.png" alt="image-20230320164200846" style="zoom:67%;" />

**RTTI 3个元素概述**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-46.png" alt="image-20230320164312547" style="zoom:67%;" />

##### dynamic_cast运算符

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-47.png" alt="image-20230320165034688" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-48.png" alt="image-20230320165146842" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-49.png" alt="image-20230320165250537" style="zoom:67%;" />

![image-20230320165305509](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-50.png)

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-51.png" alt="image-20230320165556912" style="zoom:67%;" />

##### typeid运算符和type_info类

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-52.png" alt="image-20230320165948296" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-53.png" alt="image-20230320170029719" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-54.png" alt="image-20230320170134678" style="zoom:80%;" />

##### 使用RTTI不好的例子

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-55.png" alt="image-20230320170736391" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-3-56.png" alt="image-20230320170850941" style="zoom:80%;" />

#### 15.5 类型转换运算符

C语言中的类型转换运算符太松散：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-5-1.png" alt="image-20230320171706108" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-5-2.png" alt="image-20230320171750193" style="zoom:67%;" />

**1.dynamic_cast:**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-5-3.png" alt="image-20230320171831648" style="zoom:67%;" />

**2.const_cast:**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-5-4.png" alt="image-20230320171942916" style="zoom: 67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-5-5.png" alt="image-20230320172305960" style="zoom:67%;" />

![image-20230320172334881](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-5-6.png)

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-5-7.png" alt="image-20230320172427564" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-5-8.png" alt="image-20230320172456661" style="zoom:80%;" />

**3.static_cast:**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-5-9.png" alt="image-20230320172635674" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-5-10.png" alt="image-20230320172715967" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\15-5-11.png" alt="image-20230320173130203" style="zoom:80%;" />



### 第十六章 string和标准模板库

#### 16.1 string类

##### string的创建方式

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-1-1.png" alt="image-20230324104141517" style="zoom:80%;" />

1.使用C-风格字符串创建string对象。NBTS指的是null-terminated string即以空字符结束的字符串；

2.创建包含n个字符c的string对象；

3.使用另一个string对象创建一个新的string对象，复制构造函数；

4.默认构造函数，空字符；

5.使用C-风格字符串（NBTS）的前n个字符创建字符串。这里即使n超过了NBTS结尾也会复制。

6.模板构造函数，使用begin和end之间的字符创建string对象，这里的begin和end的行为就像指针，比如一个NBTS， char str[] = "012345678"，则arr表示首字符地址，可以使用arr表示begin（char *），使用arr+6表示end；

7.使用另一个string对象的pos开始向后的字符创建新string对象，**其中npos表示字符串最大长度，通常为unsigned int 或long；**

C++11新增：

1.移动构造函数；

2.使用初始化列表创建string对象：string str = {'a', 'b', 'c'};string str{'a', 'b', 'c'};

**string重载了一些运算符：**

1.重载 += 运算符：将另一个字符串（C风格字符串、string对象、单个字符）添加到原字符串后面；

2.重载 = 运算符：将另一个字符串（NBTS、string、char）赋值给已经存在的string对象；

3.重载 [] 运算符：使用数组表示法访问字符串每个位置的字符；

4.重载 + 运算符：将两个字符串（NBTS、string、char）相加之后返回一个string对象。

##### string类的输入

对于NBTS，有三种输入方式：

（1）cin >> NBTS；（2）cin.getline(NBTS, 100)；（3）cin.get(NBTS, 100)

对于string对象，有两种输入方式：

（1）cin >> string；（2）getline(cin, string)

其中getline函数可以接收第三个参数表示输入的边界，默认为'\n'。

功能上的区别：对于string版本的getline会自动调整目标string对象的大小。

设计上的区别：由于iostream类比string出现的早，而NBTS是C风格字符串，算是源生对象，所以读取NBTS是cin的方法，而读取string是string的友元函数。

cin.operator>>(str); operator>>(cin, str)

**关注string的输入函数**：

1.getline：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-1-2.png" alt="image-20230324110932594" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-1-3.png" alt="image-20230324111000072" style="zoom:80%;" />

2.>>：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-1-4.png" alt="image-20230324111045812" style="zoom:80%;" />

##### 字符串使用

**1.比较字符串：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-1-5.png" alt="image-20230324111151610" style="zoom:80%;" />

**2.字符串大小：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-1-6.png" alt="image-20230324111230236" style="zoom:80%;" />

**3.搜索字符或者字串：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-1-7.png" alt="image-20230324111322888" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-1-8.png" alt="image-20230324111340525" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-1-9.png" alt="image-20230324111407480" style="zoom:80%;" />

##### string的其他功能

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-1-10.png" alt="image-20230324111455547" style="zoom:80%;" />

**1.自动调整大小功能：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-1-11.png" alt="image-20230324111600515" style="zoom:80%;" />

**2.string对象向C-风格字符串转换：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-1-12.png" alt="image-20230324111659746" style="zoom:80%;" />

##### 字符串种类

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-1-13.png" alt="image-20230324111729969" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-1-14.png" alt="image-20230324111750570" style="zoom:80%;" />

#### 16.2 智能指针模板类

##### 为何要有智能指针

指针如果指向动态内存区域，必须在程序中某个时刻释放指针指向的内存。

但是存在一些情况使得程序无法执行到释放指针指向的内存的代码区域。比如：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-1.png" alt="image-20230324144128386" style="zoom:80%;" />

因此希望指针指向的内存能够自动管理。

而类具有这样的概念，有开始，有终止。

因此可以实现这样一个指针模板类，来用作指针。这样的指针对象会自动管理内存的分配与释放。



##### 使用智能指针

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-2.png" alt="image-20230324144445660" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-3.png" alt="image-20230324144517854" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-4.png" alt="image-20230324144605097" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-5.png" alt="image-20230324144713886" style="zoom:80%;" />

智能指针对象可以进行解除引用操作(*ps)和访问结构和类成员（ps->）。也可以将一个智能指针对象赋给另一个指针对象，但是也会引发一个问题。后面在比较不同的指针时会说明。

**普通指针与智能模板指针：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-6.png" alt="image-20230324145019011" style="zoom:80%;" />

**三种指针都应该避免的一点：**

不要释放非堆区内存：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-7.png" alt="image-20230324145411967" style="zoom:80%;" />

##### 注意事项

如果是常规指，当把一个指针赋给另一个指针变量时，两个指针会指向同一块内存，这样的情况如果释放两次内存是会出错的。

解决方案有：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-8.png" alt="image-20230324145716067" style="zoom:80%;" />

**注意，第二种策略当把A智能指针的所有权转让给B智能指针之后，A智能指针变为空指针，不具有对于原内存的访问权限。**

auto_ptr和unique_ptr的主要区别是：auto允许将一个auto指针赋给另一个auto指针，而unique不允许将unique赋给另一个unique指针。

因此auto的错误是在运行时才能检查出来，而unique在编译时就能检查出来。

##### unique_ptr优于auto_ptr

前面已知由于不允许将同类指针进行赋值，所以unique相对auto更安全带点。

但是，有时候，将一个智能指针赋给另一个不会留下危险的悬挂指针：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-9.png" alt="image-20230324150355231" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-10.png" alt="image-20230324150447605" style="zoom:80%;" />

总结来说就是：程序试图将一个unique_ptr赋给另一个时，如果源指针是一个临时右值，编译器允许这样做；如果源指针将存在一段时间（源指针将悬挂一段时间），编译器禁止这样做。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-11.png" alt="image-20230324150737403" style="zoom:80%;" />

如果确实想执行这种把一个智能指针赋给另一个指针的操作：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-12.png" alt="image-20230324150927143" style="zoom: 80%;" />

**unique_ptr的另一个优点：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-13.png" alt="image-20230324163214038" style="zoom:80%;" />







##### 选择智能指针

**shared_ptr：**需要多个指向同一个对象的指针。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-14.png" alt="image-20230324165443274" style="zoom:80%;" />

**unique_ptr：**不需要多个指向同一个对象的指针。

比如一个函数使用new分配内存，然后返回指向该内存的指针，可以将其返回类型声明为unique_ptr。这样所有权将交给接收返回值的unique_ptr。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-15.png" alt="image-20230324170717792" style="zoom:80%;" />

**unique_ptr转换成shared_unique：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-16.png" alt="image-20230324170922551" style="zoom:80%;" />

#### 16.3 标准模板库

简单介绍容器、算法、迭代器、函数对象等。

容器是存储若干个相同类型值的空间；算法是完成特定任务的方法；迭代器类似于泛型指针，能够用于遍历容器对象；函数对象是类似于函数的对象。

下面以模板类vector为例简单介绍STL的使用。

##### 模板类vector创建与访问、修改

**创建vector容器：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-17.png" alt="image-20230324205922634" style="zoom:80%;" />

**访问容器元素：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-18.png" alt="image-20230324205948064" style="zoom:80%;" />

**分配器简介：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-19.png" alt="image-20230324210010889" style="zoom:80%;" />

##### 对于模板类vector的操作（容器方法和迭代器）

**通用方法：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-20.png" alt="image-20230324210145340" style="zoom:80%;" />

**迭代器：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-21.png" alt="image-20230324210225612" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-22.png" alt="image-20230324210353804" style="zoom:80%;" />

**vector独有的方法：**

1.push_back():

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-23.png" alt="image-20230324210451266" style="zoom:80%;" />

2.erase():

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-24.png" alt="image-20230324210547572" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-25.png" alt="image-20230324210617159" style="zoom:67%;" />

3.insert():

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-26.png" alt="image-20230324210711251" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-27.png" alt="image-20230324210741634" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-28.png" alt="image-20230324210832007" style="zoom:80%;" />

##### 通用方法：算法

算法：从更加广泛的角度定义非成员函数，即这些函数可以用于所有的容器。

也会会定义一些针对特定容器效率比较高的成员函数。

三个代表性的STL函数：for_each()、random_shuffle()和sort():

**1.for_each():**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-29.png" alt="image-20230324211147489" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-30.png" alt="image-20230324211251883" style="zoom:80%;" />

**2.random_shuffle():**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-31.png" alt="image-20230324211343064" style="zoom:80%;" />

**3.sort():**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-32.png" alt="image-20230324211611154" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-33.png" alt="image-20230324211716158" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-34.png" alt="image-20230324211806856" style="zoom:80%;" />

##### 基于范围的for循环（C++11）

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-2-35.png" alt="image-20230324212052228" style="zoom:67%;" />

#### 16.4 泛型编程

STL是一种泛型编程，关注的是算法；面向对象关注的是编程的数据方面。它们的共同点是抽象和创建可重用代码，但是理念不相同。

泛型编程旨在编写独立于数据类型的代码。

##### 为何使用迭代器

模板使得算法独立于存储的数据类型，但是迭代器使得算法独立于使用的容器类型。

以查找算法为例：基于顺序存储结构的查找算法（数组）和基于链式存储结构的查找算法的思路都是一致的，遍历所有元素进行比较。但是由于二者数据结构不同导致算法代码不同。

因此需要寻找一个独立于容器本身的数据结构和容器存储的数据类型的方法。

其中模板提供了独立于容器中数据类型的通用表示，而迭代器提供了**遍历容器中的值的通用表示**。

迭代器的一般要求：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-1.png" alt="image-20230325211211596" style="zoom:80%;" />

PS：指针能够满足迭代器的所有要求，但是迭代器不是指针，指针是迭代器。

定义首元素和超尾元素，让迭代器有起始和终点；定义自增运算，让迭代器能够轮流指向每一个元素；定义解除引用操作，让迭代器能够访问引用的值；定义赋值操作，让一个迭代器能够把值给另一个迭代器。

一个迭代器例子：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-2.png" alt="image-20230325211632771" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-3.png" alt="image-20230325211700029" style="zoom:67%;" />

**自增前缀和后缀版本：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-4.png" alt="image-20230325211749912" style="zoom:80%;" />

**遵循这种思想，STL为每个容器类都定义了迭代器。**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-5.png" alt="image-20230325211934372" style="zoom:80%;" />

**总结，使用迭代器是为了脱离算法的数据结构。**

**使用方法：1.每个容器都有迭代器：2.有begin和end；3.迭代器能够自增**

PS：C++的自动推断：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-6.png" alt="image-20230325212123770" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-7.png" alt="image-20230325212146935" style="zoom:80%;" />

##### 迭代器类型

5种迭代器：输入迭代器、输出迭代器、正向迭代器、双向迭代器、随机访问迭代器

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-8.png" alt="image-20230325212334166" style="zoom:80%;" />

**1.输入迭代器：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-9.png" alt="image-20230325212421567" style="zoom:80%;" />

**2.输出迭代器：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-10.png" alt="image-20230325212443459" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-11.png" alt="image-20230325212458480" style="zoom:80%;" />

**3.正向迭代器：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-12.png" alt="image-20230325212526888" style="zoom:80%;" />

**4.双向迭代器：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-13.png" alt="image-20230325212556594" style="zoom:80%;" />

**5.随即访问迭代器：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-14.png" alt="image-20230325212625472" style="zoom:80%;" />

##### 迭代器具有层次结构

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-15.png" alt="image-20230325212734313" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-16.png" alt="image-20230325212755319" style="zoom:80%;" />

实现算法时选择要求最低的迭代器。

各种迭代器并不是一种确定性的类型，只是一种概念性的描述。

##### 概念、改进和模型

迭代器并不是一种类型，而是对一些列要求的集合体。这个规则的集合体**概念**描述。

迭代器层次间的关系不用继承描述，而是用**改进**描述。

具体的迭代器实现用**模型**描述。

**指针用作迭代器：**

迭代器是广义指针，指针满足所有的迭代器的要求。

迭代器是算法的接口，因此算法可以用指针完成。

基本使用方法：（例子）

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-17.png" alt="image-20230325213259952" style="zoom:80%;" />

**预定义的一些迭代器：**

1.copy：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-18.png" alt="image-20230325213356646" style="zoom:80%;" />

2.ostream_iteor迭代器

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-19.png" alt="image-20230325213522265" style="zoom:80%;" />

istream_itroe迭代器与之类似：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-20.png" alt="image-20230325213624446" style="zoom:80%;" />

**其它一些预定义的迭代器：**

1，reverse_iterrator:

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-21.png" alt="image-20230325213753541" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-22.png" alt="image-20230325213822387" style="zoom:80%;" />

2.非覆盖的方式：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-23.png" alt="image-20230325213938805" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-24.png" alt="image-20230325214011137" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-25.png" alt="image-20230325214035585" style="zoom:80%;" />

总结：一个算法copy不仅可以从一个容器复制到另一个容器，而且可以从一个容器复制到输入输出流。在各种各样迭代器的帮助下使得数据脱离了数据结构。

##### **通用(基本）容器**

基本容器是一个抽象化概念，不是一种类型。容器概念指定了所有STL容器类应该满足的一系列要求。

容器的存储的类型必须是同一种类型。

容器存储的类型的对象必须是可以复制构造和可赋值的。C++11改进了概念，添加了术语可复制插入和可以移动插入。

基本容器不能保证元素按照特定的元素存储，也不能保证元素的顺序不变。但是对基本容器进行改进之后（比如序列容器等）可以添加特定要求和操作。

基本容器的一些操作：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-26.png" alt="image-20230326095004710" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-27.png" alt="image-20230326095035165" style="zoom:80%;" />

**C++11新增通用容器要求：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-28.png" alt="image-20230326095122697" style="zoom:80%;" />

##### 序列容器

序列容器对应数据结构种线性表的概念，一共有七种，每种有自己的特性，但是有一些通用概念和操作。

序列的迭代器至少是正向迭代器：即在输入、输出迭代器的基础上增加了两次迭代之间顺序不会发生改变。

**通用操作：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-29.png" alt="image-20230326095524834" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-30.png" alt="image-20230326095628114" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-31.png" alt="image-20230326095727014" style="zoom:80%;" />

**1.vector：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-32.png" alt="image-20230326095834342" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-33.png" alt="image-20230326095858054" style="zoom:80%;" />

**2.deque：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-34.png" alt="image-20230326095940620" style="zoom:80%;" />

**3.list：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-35.png" alt="image-20230326100150145" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-36.png" alt="image-20230326100223159" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-37.png" alt="image-20230326100303170" style="zoom:80%;" />

forward_list：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-38.png" alt="image-20230326100349316" style="zoom:80%;" />

**6.queue：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-39.png" alt="image-20230326100431308" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-40.png" alt="image-20230326100453955" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-43.png" alt="image-20230326100626353" style="zoom:80%;" />

priority_queue：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-41.png" alt="image-20230326100530852" style="zoom:80%;" />

**7.stack：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-42.png" alt="image-20230326100606835" style="zoom:80%;" />

**8.array：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-44.png" alt="image-20230326100714393" style="zoom:80%;" />



##### 关联容器

关联容器就是就是将值与键关联在一起，然后使用键来寻找值。

优点是实现了对于元素的快速访问。

插入时不能指定插入位置。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-45.png" alt="image-20230326100930715" style="zoom:80%;" />

下面以set和multimap为例：

**1.set：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-46.png" alt="image-20230326101046263" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-48.png" alt="image-20230326101105354" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-49.png" alt="image-20230326101219455" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-50.png" alt="image-20230326101255830" style="zoom:80%;" />

**2.multimap**

一个键能和多个值对应，底层采用pair类。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-51.png" alt="image-20230326101417516" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-52.png" alt="image-20230326101522003" style="zoom:80%;" />



##### 无序关联容器

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-4-53.png" alt="image-20230326101545726" style="zoom:80%;" />

#### 16.5 函数对象

函数符（functor）：是可以以函数方式与()结合使用的任意对象。包括（1）函数名；（2）指向函数的指针；（3）重载了()的类对象（即定义了函数operator()()的类

以重载()的类对象为例子：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-1.png" alt="image-20230326105903535" style="zoom:80%;" />

**算法与函数符的关系：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-2.png" alt="image-20230326110117497" style="zoom:80%;" />

##### 函数符概念

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-3.png" alt="image-20230326110304159" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-5.png" alt="image-20230326111710891" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-6.png" alt="image-20230326111757419" style="zoom:80%;" />

f100是一个声明的函数对象，可以看作是函数符1；TooBig\<int>(200)使用构造函数创建了另一个函数符2。这两个函数符都是一元谓词。

**另一个例子说明这种“适配器“的概念：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-7.png" alt="image-20230326144123058" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-8.png" alt="image-20230326144346235" style="zoom:80%;" />





##### 预定义函数符

STL提供了很多基本函数符，目的是为了支持将函数作为参数的算法函数。

以算法函数transformer为例：（一个算法函数可能会有多种不同的版本，使用不同的函数符）

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-9.png" alt="image-20230326144826968" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-10.png" alt="image-20230326145018754" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-11.png" alt="image-20230326145056210" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-12.png" alt="image-20230326145119102" style="zoom:80%;" />





##### 自适应函数符和函数适配器

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-13.png" alt="image-20230326145429290" style="zoom:80%;" />

**以需要将两个参数的函数转换成一个参数的函数为例**：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-14.png" alt="image-20230326145558390" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-15.png" alt="image-20230326145844157" style="zoom:80%;" />



#### 16.6 算法

##### 算法总结

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-16.png" alt="image-20230326151840939" style="zoom:80%;" />

**算法分类：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-17.png" alt="image-20230326151912510" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-18.png" alt="image-20230326151932657" style="zoom:80%;" />

**算法通用特征：**

1.就地版本和复制版本；2.if版本

算法形式：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-19.png" alt="image-20230326152155069" style="zoom:80%;" />

**1.就地版本和复制版本：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-20.png" alt="image-20230326152258610" style="zoom:80%;" />

**2.谓词版本：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-21.png" alt="image-20230326152332560" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-22.png" alt="image-20230326152355149" style="zoom:80%;" />

##### string类和STL

string虽然不是STL的组成部分，但是在设计时考虑到了STL。所以string也包含了begin()等成员函数，可以看作是序列（线性表）的一种，使用连续存储空间、而且只存储char类型的序列。

所以string也可以使用STL的接口。

##### 函数和容器方法

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-23.png" alt="image-20230326153504410" style="zoom:80%;" />

当STL函数和特定容器的方法都可以用来解决问题时，最好使用容器方法。

一个例子：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-24.png" alt="image-20230326154012738" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-25.png" alt="image-20230326154056860" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-26.png" alt="image-20230326154125041" style="zoom:80%;" />

##### 使用STL

书上设计一个例子说明STL各个组件之间相互配合完成任务目标。

#### 16.7 其他库

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-27.png" alt="image-20230326162258701" style="zoom:80%;" />



##### vector、valarray、array

越具体，通用性越低。比如valarray和vector，valarray定义了很多vector没有的操作，这也意味着valarray的通用性更低。

**valarray与vector操作对比：**

1.数学运算操作：+、-、*、log

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-28.png" alt="image-20230326162342443" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-29.png" alt="image-20230326162500273" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-30.png" alt="image-20230326162531949" style="zoom:80%;" />

2.STL用于valarray：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-31.png" alt="image-20230326162609854" style="zoom:80%;" />

3.valarray其它特性：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-32.png" alt="image-20230326163240800" style="zoom:80%;" />

##### 模板initializer_list(C++11)

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-33.png" alt="image-20230326163356955" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-34.png" alt="image-20230326163432253" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-35.png" alt="image-20230326164411665" style="zoom:80%;" />

**所有初始化列表的元素类型必须相同：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-36.png" alt="image-20230326164457587" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-37.png" alt="image-20230326164724908" style="zoom:80%;" />

##### 使用initializer_list：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-38.png" alt="image-20230326164755932" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\16-5-39.png" alt="image-20230326164955765" style="zoom:80%;" />

### 第十七章 输入、输出和文件

#### 17.1 输入输出概述

##### 流和缓冲区

C++将程序的输入和输出看作字节流。

管理流的方式有两步：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-1-1.png" alt="image-20230327085627006" style="zoom:67%;" />

使用缓冲区可以更加高效地处理输入和输出。

输入时，输入端的设备把内容先输入到缓冲区中，程序从缓冲区中读取输入；

输出时，程序先把内容输出到缓冲区中，填满（或者其他情况时）将内容从缓冲区输出到输出端设备。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-1-2.png" alt="image-20230327085905653" style="zoom:80%;" />

流连接IO设备和程序，缓冲区可以看作位于流的一端，帮助更加高效地处理输出输入。

##### 流、缓冲区和iostream文件

需要对流和缓冲区进行管理，因此iostream中有一些专门管理流和缓冲区的类。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-1-3.png" alt="image-20230327090201273" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-1-4.png" alt="image-20230327090239186" style="zoom:80%;" />

iostream类：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-1-5.png" alt="image-20230327090327030" style="zoom:80%;" />

一个对象就代表了一个流：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-1-6.png" alt="image-20230327090432333" style="zoom:80%;" />

##### 重定向

默认情况下，输入输出流的一端是程序，另一端是标准输入（显示器）和输出（键盘），但是很多操作系统支持重定向。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-1-7.png" alt="image-20230327090710493" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-1-8.png" alt="image-20230327090735084" style="zoom:80%;" />

cerr和clog不会因为改变cout的重定向而改变另一端。

有些操作系统也提供了对于cerr和clog的重定向。

#### 17.2 使用cout进行输出

C++将输出看作字节流。但是很多数值类型并不是一个字节，比如int是32位（4字节）二进制表示。而输出是字节流。

ostream类最重要的任务之一就是将数值类型转换成字符流（一个字符就是一个字节）。

##### 重载<<方法

插入运算符。

ostream & operator<<(type);

**重载输出的基本类型：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-1.png" alt="image-20230328200151216" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-2.png" alt="image-20230328200238966" style="zoom:67%;" />

**重载的参数为指针类型：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-3.png" alt="image-20230328200335800" style="zoom: 80%;" />

对于字符指针输出到空字符\'\0\'为止，对于void*指针则输出指针变量存储的地址。

**由于返回值是ostream类型的引用，其实就是调用的ostream对象的*this，因此可以拼接使用：**

cout << a << b;

##### 其它ostream类方法

**1.put方法：**

用于显示字符，最开始原型为：ostream &put(char)

后来模板化，参数可以是w_char类型。

同样可以拼接输出。

特殊之处在于可以将数值类型用于put，put将数值类型转换为相应的char类型。因此需要数值类型合适。

PS：因为C++2.0之前把char类型看作int类型，所以cout << char输出的是int类型，put(char)输出的是字符。现在char就是char，int就是int。

**2.write方法：**

输出整个字符串。原型为：

```c++
basic_ostream<charT, traits> & write(const char_type *s, streamsize n);
```

第一个参数是字符串的地址，第二个参数是显示多少个字符。

可以把数值类型强制转化成char*指针，然后按字节输出。

##### 刷新输出缓冲区

刷新输出缓冲区意味着把缓冲区中的内容输出到输出端。

一般是缓冲区满了之后再进行刷新，比如写入到文件中，从内存输出到硬盘。

但是对于屏幕输出来说只要把换行符输出到缓冲区就会刷新缓冲区。另外就是多数C++实现会在输入即将发生时刷新缓冲区，比如：

```c++
cout << "sssss";
int temp;
cin >> temp;
```

即使没有换行符也会刷新缓冲区。

强行刷新的方法：flush和endl，其中endl多输出一个换行符。

控制符也是函数：

flush(cout);

ostream类对于控制符进行了重载：

cout << flush;

##### cout格式化输出

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-4.png" alt="image-20230328204709621" style="zoom:80%;" />

修改显示格式：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-5.png" alt="image-20230328204837132" style="zoom:80%;" />

###### **1.修改显示时使用的计时系统：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-6.png" alt="image-20230328204942020" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-7.png" alt="image-20230328205025538" style="zoom:80%;" />

###### **2.调整字符宽度方法width：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-8.png" alt="image-20230328205449582" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-9.png" alt="image-20230328205543076" style="zoom:80%;" />

###### **3.填充字符方法fill：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-10.png" alt="image-20230328205659583" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-11.png" alt="image-20230328205715168" style="zoom:80%;" />

###### **4.设置浮点数显示精度方法precision：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-12.png" alt="image-20230328205919060" style="zoom:80%;" />

###### **5.打印末尾的0和小数点：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-13.png" alt="image-20230328210107772" style="zoom:80%;" />

###### **6.setf()：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-14.png" alt="image-20230328210535622" style="zoom:80%;" />

**第一种形式：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-15.png" alt="image-20230328210745831" style="zoom:80%;" />

**第二种形式：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-16.png" alt="image-20230328211351956" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-17.png" alt="image-20230328211446781" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-18.png" alt="image-20230328211615473" style="zoom:80%;" />

**关闭setf设置的状态：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-19.png" alt="image-20230328212058565" style="zoom:80%;" />

###### **7.标准控制符：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-20.png" alt="image-20230328212218676" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-21.png" alt="image-20230328212237766" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-22.png" alt="image-20230328212257901" style="zoom:80%;" />

###### 8.头文件iomanip：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-2-23.png" alt="image-20230328212543416" style="zoom:80%;" />

#### 17.3 使用cin进行输入

cin对象将标准输入表示为字节流。cin对象根据接收值的变量的类型，将字符输入转换为指定的类型。

抽取运算符>>。

**重载的基本类型有：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-1.png" alt="image-20230329082224519" style="zoom: 80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-2.png" alt="image-20230329082655776" style="zoom:80%;" />

**运算符原型如下：**

istream & operator>>(type &);

1.可以直接修改比变量而不是副本；2.返回值是调用这个方法的对象本身，所以可以连续使用>>。

**可以将hex、oct、dec控制符与cin一起使用，将整数输入解释为十六进制、八进制和十进制。**

**重载的指针类型：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-3.png" alt="image-20230329083236679" style="zoom:80%;" />

##### cin检查输入

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-4.png" alt="image-20230329084051279" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-5.png" alt="image-20230329084134649" style="zoom:80%;" />

输入如果没有满足程序的期望，抽取运算符不会修改变量的值，并返回0。

##### 流状态

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-6.png" alt="image-20230329084752021" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-7.png" alt="image-20230329085032464" style="zoom:80%;" />

###### 1.设置状态clear和setstate

**clear：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-8.png" alt="image-20230329200742874" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-9.png" alt="image-20230329200810230" style="zoom:80%;" />

**setstate：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-10.png" alt="image-20230329200850668" style="zoom:80%;" />

**为什么要重新设置流状态：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-11.png" alt="image-20230329201652301" style="zoom:80%;" />

###### 2.IO和异常

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-12.png" alt="image-20230329202149751" style="zoom:80%;" />

###### 3.流状态的影响

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-13.png" alt="image-20230329202557346" style="zoom:80%;" />

设置流状态位（badbit、failbit、eofbit）之后，流对于后面的输入将关闭。

可以使用clear方法将流状态重置为好，重置状态之后一般要处理引起流状态改变的输入：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-14.png" alt="image-20230329203212530" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-15.png" alt="image-20230329203312336" style="zoom:80%;" />

##### 其它istream类方法

get()和getline()方法：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-16.png" alt="image-20230329203510141" style="zoom:80%;" />

###### 1.单字符输入

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-17.png" alt="image-20230329203723876" style="zoom:80%;" />

**（1）成员函数get(char &)：**

与抽取运算符>>不同的是，get方法会读取换行符、空格、制表符，而抽取运算符会跳过空白。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-18.png" alt="image-20230329204159034" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-19.png" alt="image-20230329204321245" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-20.png" alt="image-20230329204338426" style="zoom: 80%;" />

**（2）成员函数get(void)：**

同样读取空白，但是返回值是一个读取的字符的int值，这意味着不能连续使用。<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-21.png" alt="image-20230329204613712" style="zoom:80%;" />

**（3）总结单字符**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-22.png" alt="image-20230329204657528" style="zoom:80%;" />

###### 2.如何选择单字符输入方法>>还是get

首先：是否需要空白字符。如果不需要空白（比如期待用户的输入是某个字母代表的菜单选项时），使用>>；

其次，如果希望检查每个字符，使用get方法。get(char &)方法更好，get(void)方法的好处在于与C语言中的getchar()极其类似，可以互换。

###### 3.字符串输入：getline、get、ignore

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-23.png" alt="image-20230329205241245" style="zoom:80%;" />

**get和getline的主要区别在于前者把换行符留在输入流中，后者抽取并丢弃换行符。**

**ignore函数：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-24.png" alt="image-20230329205508719" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-25.png" alt="image-20230329205533377" style="zoom:80%;" />

###### 4.意外字符串输入

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-26.png" alt="image-20230329205755779" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-27.png" alt="image-20230329210000888" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-28.png" alt="image-20230329210420415" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-29.png" alt="image-20230329210439181" style="zoom:80%;" />

##### 其它istream方法

###### read函数：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-30.png" alt="image-20230330090626641" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-31.png" alt="image-20230330090728751" style="zoom:80%;" />

###### peek函数：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-32.png" alt="image-20230330090847328" style="zoom:80%;" />

###### gcount函数：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-33.png" alt="image-20230330090958015" style="zoom:80%;" />

###### putback函数：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-3-34.png" alt="image-20230330091152114" style="zoom:80%;" />

#### 17.4 文件输入和输出

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-1.png" alt="image-20230330092653791" style="zoom:80%;" />

##### 简单文件IO

**写入文件：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-2.png" alt="image-20230330092954403" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-3.png" alt="image-20230330094932062" style="zoom:80%;" />

**读取文件：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-4.png" alt="image-20230330095111793" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-5.png" alt="image-20230330104510276" style="zoom:80%;" />

**关闭文件会刷新缓冲区。**

##### 流状态检查和is_open()

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-6.png" alt="image-20230330105105316" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-7.png" alt="image-20230330105135369" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-8.png" alt="image-20230330105406974" style="zoom:80%;" />

##### 打开多个文件

**1.每个文件对应一个流：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-9.png" alt="image-20230330105525282" style="zoom:80%;" />

**2.一个流依次关联多个文件：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-10.png" alt="image-20230330105632667" style="zoom:80%;" />

##### 命令行处理技术

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-11.png" alt="image-20230330110100187" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-12.png" alt="image-20230330110138968" style="zoom:80%;" />

**PS：不同的实现，对于将文件ifstream对象关联起来时，是否重置流状态是不一样的。所以有时候需要使用显式使用clear。**

##### 文件模式

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-13.png" alt="image-20230330110925034" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-14.png" alt="image-20230330111013966" style="zoom:80%;" />

**ifstream对象和ofstream对象以及open方法的默认参数：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-15.png" alt="image-20230330111327499" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-16.png" alt="image-20230330113407963" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-17.png" alt="image-20230330113521355" style="zoom:80%;" />

###### 二进制文件

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-18.png" alt="image-20230330114921688" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-19.png" alt="image-20230330114944682" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-20.png" alt="image-20230330115124843" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-21.png" alt="image-20230330115229852" style="zoom:80%;" />

**如果需要把数据保存为二进制格式，应该使用二进制文件：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-22.png" alt="image-20230330115408210" style="zoom:80%;" />

**write函数**：写二进制文件

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-23.png" alt="image-20230330115514263" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-24.png" alt="image-20230330115614446" style="zoom:80%;" />

**read函数**：读二进制文件

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-25.png" alt="image-20230330115802845" style="zoom:80%;" />

##### 随机存取

随即存取指的是直接移动到文件的任何位置。

随机存取常用于数据库文件。程序维护一个独立的索引文件，该文件指出数据在主数据文件中的位置。这样程序可以直接跳到这个位置，读取和修改其中的数据。

**fstream对象：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-26.png" alt="image-20230330145941425" style="zoom:80%;" />

**文件模式：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-27.png" alt="image-20230330150117722" style="zoom:80%;" />

###### 文件移动方式

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-28.png" alt="image-20230330150216154" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-29.png" alt="image-20230330150249256" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-30.png" alt="image-20230330151402447" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-31.png" alt="image-20230330151530766" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-32.png" alt="image-20230330151649120" style="zoom:80%;" />

**streampos place = index * sizeof struct;**

**使用临时文件：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-33.png" alt="image-20230330152311122" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-34.png" alt="image-20230330152327689" style="zoom:80%;" />





#### 17.5 内核格式化

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-35.png" alt="image-20230330153214151" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-36.png" alt="image-20230330153345495" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\17-4-37.png" alt="image-20230330153510077" style="zoom:80%;" />



### 第十八章 C++新标准

#### 18.1 复习前面学过的C++11新标准

##### 新类型

主要是新增了long long 和 unsigned long long以支持64位的整型

新增了char16_t和char_32_t分别为16位和32位的字符表示。

新增了原始字符串。R"()"

##### 统一初始化列表

所有内置类型和类对象。=可选。

当类有一个接受初始化列表模板作为参数的构造函数，那么初始化列表只会调用这个构造函数。

**1.禁止缩窄**

**2.初始化列表模板initializer_list可用作构造函数参数，也可以用作常规函数参数。所有类型必须相同或者可以转换为同一类型**

##### 声明

###### auto

自动推断类型

###### decltype

将变量类型声明为表达式类型。常用于模板函数中，因为在模板实例化之前无法确定函数中变量类型，**只有模板实例化之后才能确定类型**。

###### 返回类型后置

在函数名和参数列表后面指定返回类型。

常用decltype一起用，用于返回根据形参推断出来的类型。

这里的逻辑是：在编译器遇到函数的参数列表之前，还不知道参数类型，因此不知道返回值类型。

**即模板函数是根据传入的形参类型确定模板参数，在看到参数列表之前，都不知道模板参数是什么。**

###### 模板别名：using

除了typedef以外，另一种别名的方式是using，常用于模板：

![image-20230331154752962](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-1-1.png)

区别是using可以用于模板部分具体化而typedef不能：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-1-2.png" alt="image-20230331154851817" style="zoom:80%;" />

###### nullptr

0仍可以表示空指针。还可以表示int整型。

但是nullptr只表示空指针。

###### 智能指针

摒弃了autp_ptr，已经介绍了unique_ptr、shared_ptr。还有一种weak_ptr。

###### 异常规范

不推荐使用异常规范，即在函数参数列表后面加上throw()表示可能出现的异常类型。

但是可以在后面加上关键字noexcept表示无异常。

###### 作用域枚举

两个不同的作用域可以有相同的名字：

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-1-3.png" alt="image-20230331155359011" style="zoom:80%;" />

###### 对类的修改

1.单参数构造函数引发的其他类型向类转换：explicit

也可以将explicit用于类型转换函数，即把类转换为其他类型的函数。

2.类内成员初始化

直接在定义中进行初始化。定义中的初始化不能使用圆括号。

##### 模板和STL的修改

###### 基于范围的for循环

对于内置数组和包含begin和end方法的STL容器可以使用基于范围的for循环。

如果想要修改值，则声明为引用即可。

###### 新的STL容器

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-1-4.png" alt="image-20230331155859694" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-1-5.png" alt="image-20230331155916846" style="zoom:80%;" />

###### 新的STL方法

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-1-6.png" alt="image-20230331155944121" style="zoom:80%;" />

###### valarray

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-1-7.png" alt="image-20230331160016979" style="zoom:80%;" />

###### 摒弃export

即不允许模板声明和定义在两个文件。

###### 尖括号

以前嵌套模板需要在两个尖括号分开，现在不需要。

##### 右值引用

左值指的是可以取地址的东西，比如变量、对象等，右值指的是一些常量和表达式的值。

右值引用使用&&表示，比如

int && a = 13;

右值引用会把右值存储到特定位置并且可以获得该值的地址。即可以将取地址运算符用于a。

#### 18.2 移动语义和右值引用

##### 为何需要移动语义

移动语义：复制时不是把源对象复制一个副本赋给目标对象，而是把源目标的所有权转给目标对象。

一个例子：假如想要初始化一个vector，但是准备在一个函数中创建一个对象，再把这个函数中的对象作为返回值传递给vector的复制构造函数进行初始化新vector。

这个过程中，函数中创建的对象作为返回对象用于初始化vector，然后会删除这个函数返回的临时对象。

那么，直接把这个返回对象的所有权给新的vector不就可以了吗？

移动语义避免了移动原始数据，而是修改了所有权。

##### 如何实现移动语义

需要让编译器知道，是么时候需要复制，什么时候只需要“移动”。

这就是右值引用的作用。

复制构造函数：使用const左值引用，这个引用关联到左值实参；

移动构造函数：使用非const右值引用，该引用关联到右值实参，比如函数的返回值。需要注意的是，因为需要转让对象的所有权，意味着需要对右值引用的内容进行修改，所以必须是非const。比如将所有权转让给新对象之后，源对象的指针需要设置为空，以免残留控制权。



实现移动语义两个步骤：

**1.右值引用让编译器知道何时使用移动语义：**

![image-20230331165426240](D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-2-1.png)

对象one是左值，所以调用复制构造函数；

表达式one和three调用加法运算符，返回的是一个临时对象，也就是右值，因此调用移动构造函数。

**2.编写移动构造函数，提供所需的行为。**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-2-2.png" alt="image-20230331165656949" style="zoom:80%;" />

##### 没有移动语义之前是如何把右值传递给左值引用的？

答案是const引用会把右值转换成一个临时变量，再这个临时变量一个地址，这样就可以传递给const引用，等到函数结束再删除这个临时变量。

注意必须是const引用，因为这符合const的用法逻辑。

##### 移动赋值

适用于构造函数的语义也适用于赋值运算符。即移动运算符。

移动运算符的右值引用也不能是const。

##### 强制移动

移动构造函数和移动赋值运算符都使用右值，但是如果想使用左值怎么办？典型例子就是数组中筛选出一个对象之后，只想要这个对象，其它都删除。

1.使用运算符static_cast<>将对象的类型强制转换为右值类型，即type &&;

2.C++11中头文件utilty中声明了函数std::move()：

Class obj2 = std::move(obj1)

这是一个表达式值，如果类中定义了移动构造函数，则整个表达式的值为右值，如果没有定义移动构造函数，那会调用复制构造函数。

如果也没有定义赋值构造函数则会报错。



#### 18.3 新的类功能

##### 特殊的成员函数

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-1.png" alt="image-20230401081040965" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-2.png" alt="image-20230401081133435" style="zoom:80%;" />

##### 默认的方法和禁用的方法

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-3.png" alt="image-20230401081253025" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-4.png" alt="image-20230401081400421" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-5.png" alt="image-20230401081434457" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-6.png" alt="image-20230401081520234" style="zoom:80%;" />

**delete用于禁止特定的类型转换：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-7.png" alt="image-20230401081717118" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-8.png" alt="image-20230401081805215" style="zoom:80%;" />

##### 委托构造函数

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-9.png" alt="image-20230401082034804" style="zoom:80%;" />

##### 继承构造函数

**一种派生类继承基类构造函数的机制。**

**C++98提供一种让名称空间中函数可用的方法：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-10.png" alt="image-20230401082224622" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-11.png" alt="image-20230401082420904" style="zoom:80%;" />

**用于构造函数：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-12.png" alt="image-20230401082625102" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-13.png" alt="image-20230401082801679" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-14.png" alt="image-20230401082840910" style="zoom:80%;" />

##### 管理虚方法：override和final

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-15.png" alt="image-20230401083819974" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-16.png" alt="image-20230401083902373" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-17.png" alt="image-20230401083940687" style="zoom:80%;" />

#### 18.4 lambda函数

主要作用是服务于需要使用函数谓词的STL算法。

##### 比较函数指针、函数符和Lambda函数

**函数指针：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-18.png" alt="image-20230401091742736" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-19.png" alt="image-20230401091817522" style="zoom: 80%;" />

**函数符：**

<img src="C:\Users\10985\AppData\Roaming\Typora\typora-user-images\image-20230401091951018.png" alt="image-20230401091951018" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-20.png" alt="image-20230401092013527" style="zoom:80%;" />

**Lambda函数：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-21.png" alt="image-20230401092145299" style="zoom:80%;" />

##### 为何使用lambda

**距离：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-22.png" alt="image-20230401092431107" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-23.png" alt="image-20230401092504881" style="zoom:80%;" />

**简洁：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-25.png" alt="image-20230401092850560" style="zoom:80%;" />

**效率：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-26.png" alt="image-20230401093037742" style="zoom:80%;" />

**功能：**

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-27.png" alt="image-20230401093253972" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-28.png" alt="image-20230401093343195" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-29.png" alt="image-20230401093359301" style="zoom:80%;" />



#### 18.5 包装器（适配器）

C++提供了多个包装器（wrapper，也叫适配器）。这些对象用于给其它编程接口提供一致或更合适的接口。

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-30.png" alt="image-20230401105256814" style="zoom:80%;" />

##### 包装器function及模板的低效性

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-31.png" alt="image-20230401105410317" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-32.png" alt="image-20230401105759927" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-33.png" alt="image-20230401105818958" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-34.png" alt="image-20230401110022197" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-35.png" alt="image-20230401110144729" style="zoom: 67%;" />

##### 修复问题

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-36.png" alt="image-20230401110402744" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-37.png" alt="image-20230401110451316" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-38.png" alt="image-20230401110508057" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-39.png" alt="image-20230401110532236" style="zoom:80%;" />

##### 其他方式

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-40.png" alt="image-20230401110818179" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-3-41.png" alt="image-20230401110907660" style="zoom:80%;" />





#### 18.6 可变参数模板

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-6-1.png" alt="image-20230401144604561" style="zoom:80%;" />

##### 模板和函数参数包

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-6-2.png" alt="image-20230401144719674" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-6-3.png" alt="image-20230401144819008" style="zoom:80%;" />

##### 展开参数包

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-6-4.png" alt="image-20230401145026736" style="zoom:80%;" />

##### 在可变参数模板函数中使用递归

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-6-5.png" alt="image-20230401145125244" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-6-6.png" alt="image-20230401145209414" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-6-7.png" alt="image-20230401145322264" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-6-8.png" alt="image-20230401145422511" style="zoom:80%;" />

##### 改进

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-6-9.png" alt="image-20230401145604174" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-6-10.png" alt="image-20230401145757435" style="zoom:80%;" />

**总结：需要定义参数列表为0、1和大于等于2时的模板函数。**

参数列表为0的函数什么都不做；

参数列表为1的函数负责处理最后一个元素的操作；

参数列表大于等于2的函数处理第一个参数，然后调用自身，并把剩余的参数传递给。

终止是解包知道包内有0个元素，0个元素会调用参数列表为0的函数。





#### 18.7 其他功能

##### 并行编程

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-7-1.png" alt="image-20230401150324087" style="zoom:80%;" />

##### 新增的库

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-7-2.png" alt="image-20230401150451102" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-7-3.png" alt="image-20230401150509481" style="zoom:80%;" />

##### 低级编程

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-7-4.png" alt="image-20230401150658261" style="zoom:80%;" />

##### 杂项

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-7-5.png" alt="image-20230401150842005" style="zoom:80%;" />

#### 18.8 语言变化

##### Boost项目

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-7-6.png" alt="image-20230401151050562" style="zoom:80%;" />

##### TR1

<img src="D:\RegularFile\C++\learning\1.C++Primer.Plus\image\18-7-7.png" alt="image-20230401151158718" style="zoom:80%;" />











