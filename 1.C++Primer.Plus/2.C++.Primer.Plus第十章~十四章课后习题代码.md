# 第十章课后代码

代码行数：570行

1.一个基本类

main.cpp

```
#include <iostream>
#include "bankaccount.h"

int main(void) {
    using std::cout;
    using std::cin;

    BankAccount one;
    cout << "------------调用默认构造函数创建的对象----------\n";
    one.ShowInfo();

    BankAccount t("ABC", 1234567, 102.3);
    cout << "------------调用默认构造函数创建的对象----------\n";
    t.ShowInfo();

    cout << "------------测试成员函数----------\n";
    t.Deposit(12.8);
    t.ShowInfo();
    t.Withdraw(100);
    t.ShowInfo();

    return 0;
}

```

bankaccount.h

```
#ifndef BANKACCOUNT_H_
#define BANKACCOUNT_H_
#include <iostream>
using std::string;

class BankAccount {
private:
    string name_;
    long long number_;
    double deposit_;
public:
    BankAccount(const string name, long long number, double deposit);
    BankAccount();

    void ShowInfo() const;
    void Deposit(double quantity);
    void Withdraw(double quantity);
};

#endif
```

bankaccount.cpp

```
#include "bankaccount.h"

BankAccount::BankAccount(const string name, long long number,
                         double deposit) {
    name_ = name;
    number_ = number;
    deposit_ = deposit;
}

BankAccount::BankAccount() {
    name_ = "";
    number_ = 0;
    deposit_ = 0;
}

void BankAccount::ShowInfo() const {
    std::cout << number_ << " : " << name_ << '\n';
    std::cout << deposit_ << '\n';
}

void BankAccount::Deposit(double quantity) {
    deposit_ += quantity;
}

void BankAccount::Withdraw(double quantity) {
    deposit_ -= quantity;
}
```

2.简单类，类中有string和char*类型

main.cpp

```
#include <iostream>
#include "person.h"

int main(void) {
    using std::cout;
    using std::string;

    cout << "-------测试默认构造函数--------\n";
    Person p1;
    p1.Show();
    p1.FormalShow();

    cout << "-------测试构造函数：一个参数--------\n";
    Person p2("Smythecraft");
    p2.Show();
    p2.FormalShow();

    cout << "-------测试构造函数：两个参数--------\n";
    Person p3("Dimmwiddy", "Sam");
    p3.Show();
    p3.FormalShow();
    

    return 0;
}

```

person.h

```
#ifndef PERSON_H_
#define PERSON_H_
#include <iostream>
using std::string;

class Person {
private:
    static const int LIMIT = 25;
    string lname_;
    char fname_[LIMIT];
public:
    Person();
    Person(const string &ln, const char *fn = "Heyyou");
    
    void Show() const;
    void FormalShow() const;
};

#endif
```

person.cpp

```
#include "person.h"
#include <cstring>

Person::Person() {
    lname_ = "";
    fname_[0] = '\0';
}

Person::Person(const string &ln, const char *fn) {
    lname_ = ln;
    std::strncpy(fname_, fn, LIMIT - 1);
}

void Person::Show() const {
    std::cout << fname_ << " : " << lname_ << '\n';
}

void Person::FormalShow() const {
    std::cout << lname_ << " : " << fname_ << '\n';
}
```

3.设计默认构造函数提示用户输入初始化参数

main.cpp

```
#include <iostream>
#include "golf.h"

int main(void) {
    using std::cout;
    using std::cin;

    Golf g;
    g.Show();

    int hd;
    cout << "请重新输入得分：";
    cin >> hd;
    g.ResetHandicap(hd);
    g.Show();
    

    return 0;
}

```

glof.h

```
#ifndef GOLF_H_
#define GOLF_H_

class Golf {
private:
    static const int Len = 5;
    char fullname_[Len];
    int handicap_;
public:
    Golf(const char *fn, int hd);
    Golf();
    void ResetHandicap(int hd);
    void Show();
};

#endif
```

golf.cpp

```
#include "golf.h"
#include <iostream>
#include <cstring>

Golf::Golf(const char *fn, int hd) {
    std::strncpy(fullname_, fn, Len - 1);
    handicap_ = hd;
}

Golf::Golf() {
    using std::cout;
    using std::cin;

    cout << "请输入名字：";
    char temp[Len];
    while (!cin.get(temp, Len - 1) || !std::strcmp(temp, "")) {
        cin.clear();
        while (cin.get() != '\n') continue;
        cout << "输入过长或者为空字符串！请重新输入：";
    }

    int hd;
    cin.get();
    cout << "请输入击球数目：";
    while (!(cin >> hd)) {
        cin.clear();
        while (cin.get() != '\n') continue;
        cout << "请输入数字：";
    }
    cin.get();

    Golf source(temp, hd);
    *this = source;
}

void Golf::ResetHandicap(int hd) {
    handicap_ = hd;
}

void Golf::Show() {
    std::cout << "姓名：" << fullname_ << '\n'
              << "击球：" << handicap_ << '\n';
}
```

4.命名空间、默认构造函数

main.cpp

```
#include <iostream>
#include "sales.h"
using namespace SALES;

int main(void) {
    using std::cout;
    using std::cin;

    Sales a;
    a.Show();
    
    return 0;
}

```

sales.h

```
#ifndef SALES_H_
#define SALES_H_
namespace SALES {
    class Sales {
    private:
        static const int QUARTERS = 4;
        double sales_[QUARTERS];
        double average_;
        double max_;
        double min_;
    public:
        Sales(double arr[], int n);
        Sales();
        void Show();
    }; // end class Sales
} // end namespace SALES

#endif
```

sales.cpp

```
#include "sales.h"
#include <iostream>

namespace SALES {
    Sales::Sales(double arr[], int n) {
        n < QUARTERS ? n : n = QUARTERS;
        int i;
        for (i = 0; i < n; i++) {
            sales_[i] = arr[i];
        } // end for
        
        for (; i < QUARTERS; i++) {
            sales_[i] = 0;
        }

        // 初始化其他参数
        double sum, max, min;
        sum = max = min = sales_[0];
        for (int i = 1; i < QUARTERS; i++) {
            sum += sales_[i];
            max < arr[i] ? max = arr[i] : max;
            min > arr[i] ? min = arr[i] : min;
        }
        average_ = sum / QUARTERS;
        max_ = max;
        min_ = min;

    } // end

    Sales::Sales() {
        using std::cout;
        using std::cin;

        double temp[QUARTERS];
        int i;
        for (i = 0; i < QUARTERS; i++) {
            cout << "请输入第" << i+1 << "季度销售额：";
            if (!(cin >> temp[i])) break;
        }
        
        while (i < QUARTERS) {
            temp[i++] = 0;
        }

        Sales s(temp, i);
        *this = s;
    } // end

    void Sales::Show() {
        for (int i = 0; i < QUARTERS; i++) {
            std::cout << "第" << i + 1 << "季度销售额是：" << sales_[i]
                      << '\n';
        } // end for

        std::cout << "均值为：" << average_ << ", "
                  << "最大值为：" << max_ << ", "
                  << "最小值为：" << min_ << '\n';
    } 

}
```

5.栈、结构

main.cpp

```
#include <iostream>
#include <cstring>
#include "stack.h"


int main(void) {
    using std::cout;
    using std::cin;

    Stack s;
    char tempname[35];
    int temp_payment;
    while (!s.IsFull()) {
        cout << "请输入""顾客的姓名：";
        if (!(cin.get(tempname, 35 - 1))) {
            if (std::strcmp(tempname, "") == 0) break;
            cin.clear();
            while (cin.get() != '\n') continue;
            cout << "输入过长！请重新输入：";
        }
    
        cin.get();
        cout << "请输入付款金额：";
        while (!(cin >> temp_payment)) {
            cin.clear();
            while (cin.get() != '\n') continue;
            cout << "输入不合法！请重新输入：";
        }
        cin.get();

        Item temp_cus;
        std::strcpy(temp_cus.fullname, tempname);
        temp_cus.payment = temp_payment;

        s.push(temp_cus);
    }

    double sum = 0;
    Item temp_it;
    while (!s.IsEmpty()) {
        s.pop(temp_it);
        sum += temp_it.payment;
    }

    cout << "所有顾客的付款总数为：" << sum << '\n';  
    
    return 0;
}

```

stack.h

```
#ifndef STACK_H_
#define STACK_H_

struct Customer {
    char fullname[35];
    double payment;
};

typedef Customer Item;

class Stack {
private:
    enum {MAX = 10};
    Item items[MAX];
    int top;
public:
    Stack();
    bool IsEmpty();
    bool IsFull();
    bool push(const Item &item);
    bool pop(Item &item);

};

#endif
```

stack.cpp

```
#include "stack.h"

Stack::Stack() {
    top = 0;
}

bool Stack::IsEmpty() {
    return top == 0;
}

bool Stack::IsFull() {
    return top == MAX;
}

bool Stack::push(const Item &item) {
    if (IsFull()) return false;
    items[top++] = item;
    return true;
}

bool Stack::pop(Item &item) {
    if (IsFull()) return false;
    item = items[--top];
    return true;
}
```

6.将成员对象作为参数传递

main.cpp

```
#include <iostream>
#include "move.h"

int main(void) {
    using std::cout;
    using std::cin;

    Move m1(2, 3);
    Move m2;
    m1.ShowMove();
    m2.ShowMove();

    Move m3 = m1.Add(m2);
    m3.ShowMove();
    Move m4 = m1.Add(m1);
    m4.ShowMove();

    m1.Reset();
    m1.ShowMove();
    
    return 0;
}

```

move.h

```
#ifndef MOVE_H_
#define MOVE_H_
#include <iostream>

class Move {
private:
    double x_;
    double y_;
public:
    Move(double a = 0, double b = 0);

    void ShowMove() const;
    Move Add(const Move &m) const;
    void Reset(double a = 0, double b = 0);
};

#endif
```

move.cpp

```
#include "move.h"


Move::Move(double a, double b) {
    x_ = a;
    y_ = b;
}

void Move::ShowMove() const {
    using std::cout;
    cout << "(" << x_ << ", " << y_ << ")\n";
}

Move Move::Add(const Move &m) const {
    Move temp(x_ + m.x_, y_ + m.y_);

    return temp; 
}

void Move::Reset(double a, double b) {
    x_ = a;
    y_ = b;
}
```

7.根据特性创建类

main.cpp

```
#include <iostream>
#include "plorg.h"

int main(void) {
    using std::cout;
    using std::cin;

    Plorg p;
    cout << "----使用默认构造函数创建对象----" << '\n';
    p.Show();

    Plorg p1("funck!", 20);
    cout << "----使用构造函数创建对象----\n";
    p1.Show();
    p1.SetCI(188);
    cout << "----使用成员函数修改CI值----\n";
    p1.Show();
    
    return 0;
}

```

plorg.h

```
#ifndef PLORG_H_
#define PLORG_H_
#include <iostream>
#include <cstring>

class Plorg {
private:
    static const int MAXLEN = 19;
    char name_[MAXLEN];
    int CI_;
public:
    Plorg(const char *str = "Plorga", int ci = 50);

    void SetCI(int ci);
    void Show();
};

#endif
```

plorg.cpp

```
#include "plorg.h"

Plorg::Plorg(const char *str, int ci) {
    std::strncpy(name_, str, MAXLEN);
    CI_ = ci;
}

void Plorg::SetCI(int ci) {
    CI_ = ci;
}

void Plorg::Show() {
    using std::cout;
    cout << name_ << " : " << CI_ << '\n';
}
```

8.简单列表类

main.cpp

```
#include <iostream>
#include "list.h"

void show(Item &);

int main(void) {
    using std::cout;
    using std::cin;

    cout << "----创建空列表----\n";
    List l;
    cout << "列表为空：" << l.IsEmpty() << '\n';

    for (int i = 0; i < 5; i++) {
        l.Add(i);
    }
    cout << "----访问列表元素并打印----\n";
    l.Visit(show);

    return 0;
}

void show(Item &x) {
    std::cout << x << '\n';
}
```

list.h

```
#ifndef LIST_H_
#define LIST_H_

typedef int Item;

class List {
private:
    static const int MAX = 10;
    Item list[MAX];
    int len;
public:
    List();

    bool IsEmpty();
    bool IsFull();
    bool Add(const Item &it);
    void Visit(void (*pf)(Item &));

};

#endif
```

list.cpp

```
#include "list.h"

List::List() {
    len = 0;
}

bool List::IsEmpty() {
    return len == 0;
}

bool List::IsFull() {
    return len == MAX;
}

bool List::Add(const Item &it) {
    if (IsFull()) return false;
    list[len] = it;
    len++;
    return true;
}

void List::Visit(void (*pf)(Item &)) {
    for (int i = 0; i < len; i++) {
        pf(list[i]);
    }
}
```



# 第十一章

总代码行数：1000行

1.一种对象的多种表示方式的类、重载<<、运算符重载

main.cpp

```
#include <iostream>
#include <fstream>
#include <cstdlib>  // rand(), srand()
#include <ctime>    // time()
#include "vector.h"


int main(void) {
    using namespace std;
    using namespace VECTOR;

    srand(time(0)); // seed random-number generator
    double direction;
    Vector step;
    Vector result(0.0, 0.0);
    unsigned long steps = 0;    // numbers of step
    double target;
    double dstep;

    // open file
    const char *pfilename = "./test.txt";
    ofstream fout;
    fout.open(pfilename, ios::out);

    cout << "Enter target distance(q to quit): ";
    while (cin >> target) {
        cout << "Enter step length: ";
        if (!(cin >> dstep)) break;

        // 写入文件
        fout << "Target distance: " << target << ", Step length: "
             << dstep << '\n';
        fout << steps << " : " << result;

        while (result.magvalue() < target) {
            direction = rand() % 360;
            step.Reset(dstep, direction, Vector::POL);
            result = result + step;
            steps++;

            // save to file
            fout << steps << " : " << result;
        }

        // display on screen
        cout << "经过" << steps << "次步数， 目前到达：\n";
        cout << result;
        result.polar_mode();
        cout << result;
        cout << "平均每步走" << result.magvalue() / steps << '\n';

        // save to file
        fout << "经过" << steps << "次步数， 目前到达：\n";
        result.rect_mode();
        fout << result;
        result.polar_mode();
        fout << result;
        fout << "平均每步走" << result.magvalue() / steps;

        // reset
        steps = 0;
        result.Reset(0, 0);
        cout << "Enter target distance(q to quit): ";
    }

    fout.close();
    cout << "Done!\n";


    return 0;
}

```

vector.h

```
#ifndef VECTOR_H_
#define VECTOR_H_
#include <iostream>
#include <fstream>

namespace VECTOR {
    class Vector {
    public:
        // RECT for rectangular
        // POL for polar
        enum Mode{RECT, POL};
    private:
    // private member data
        double x_;
        double y_;
        double mag_;
        double ang_;
        Mode mode_;
    // private methods for setting value
        void set_mag();
        void set_ang();
        void set_x();
        void set_y();
    public:
    // construcors and destructor
        Vector();
        Vector(double n1, double n2, Mode form = RECT);
        ~Vector() {};
    // others methods
        void Reset(double n1, double n2, Mode form = RECT);
        double xvalue() const {return x_;}
        double yvalue() const {return y_;}
        double magvalue() const {return mag_;}
        double angvalue() const {return ang_;}
        void polar_mode();
        void rect_mode();
    // operator overloading
        Vector operator+(const Vector &v) const;
        Vector operator-(const Vector &v) const;
        Vector operator-() const;
        Vector operator*(double n) const;
    // friend methods
        friend Vector operator*(double n, const Vector &v);
        friend std::ostream & operator<<(std::ostream &os, const Vector &v);
        // friend std::ofstream & operator<<(std::ofstream &fs, const Vector &v);
    }; // end class declaration
} // end namespace VECTOR

#endif
```

vector.cpp

```
#include "vector.h"
#include <cmath>

using std::sqrt;
using std::sin;
using std::cos;
using std::atan;
using std::atan2;
using std::cout;


namespace VECTOR {
    const double Deg_To_Rad = 45.0 / atan(1);

// private methods for setting values
    void Vector::set_mag() {
        mag_ = sqrt(x_*x_ + y_*y_);
    }

    void Vector::set_ang() {
        if (x_ == 0 && y_ == 0) {
            ang_ = 0;
        } else {
            ang_ = atan2(y_, x_);
        } // end if
    }

    void Vector::set_x() {
        x_ = mag_ * cos(ang_);
    }

    void Vector::set_y() {
        y_ = mag_ * sin(ang_);
    }

// public methods
    // default constructor: set values to zero
    // set default mode_(RETC)
    Vector::Vector() {
        x_ = y_ = mag_ = ang_ = 0;
        mode_ = RECT;
    }

    Vector::Vector(double n1, double n2, Mode form) {
        mode_ = form;
        if (form == RECT) {
            x_ = n1;
            y_ = n2;
            set_mag();
            set_ang();
        } else if (form == POL) {
            mag_ = n1;
            ang_ = n2 / Deg_To_Rad;
            set_x();
            set_y();
        } else {
            cout << "第三个参数输入不合法！\n";
            cout << "向量被设置为零\n";
            x_ = y_ = mag_ = ang_ = 0;
            mode_ = RECT;
        } // end if
    } // end constructor

    void Vector::Reset(double n1, double n2, Mode form) {
        mode_ = form;
        if (form == RECT) {
            x_ = n1;
            y_ = n2;
            set_mag();
            set_ang();
        } else if (form == POL) {
            mag_ = n1;
            ang_ = n2 / Deg_To_Rad;
            set_x();
            set_y();
        } else {
            cout << "第三个参数输入不合法！\n";
            cout << "向量被设置为零\n";
            x_ = y_ = mag_ = ang_ = 0;
            mode_ = RECT;
        } // end if
    } // end Reset

    // set to polar mode
    void Vector::polar_mode() {
        mode_ = POL;
    }

    // set to rectangular mode
    void Vector::rect_mode() {
        mode_ = RECT;
    }

// overload operator
    // add two vectors
    Vector Vector::operator+(const Vector &v) const {
        double x = x_ + v.x_;
        double y = y_ + v.y_;
        Vector res(x, y);
        
        return res;
    }

    // subtract v from this
    Vector Vector::operator-(const Vector &v) const {
        return Vector(x_ - v.x_, y_ - v.y_);
    }

    // reverse sign of vector
    Vector Vector::operator-() const {
        return Vector(-x_, -y_);
    }

    // multipy vector by n
    Vector Vector::operator*(double n) const {
        return Vector(n * x_, n * y_);
    }

// friend methods
    // multipy n by vector
    Vector operator*(double n, const Vector &v) {
        return v * n;
    }

    // overload << of cout
    // display rectangular coordinates if mode is RECT
    // else display polar coordinates if mode is POL
    std::ostream & operator<<(std::ostream &os, const Vector &v) {
        if (v.mode_ == Vector::RECT) {
            os << "(x, y) = (" << v.x_ << ", " << v.y_ << ")\n";
        } else if (v.mode_ == Vector::POL) {
            os << "(m, a) = (" << v.mag_ << ", "
               << v.ang_ * Deg_To_Rad << ")\n";
        } else {
            cout << "Vector mode is invalid";
        }

        return os;
    }

    // overload << of fout
    // save rectangular coordinates in a line if mode is RECT
    // else save polar coordinates in a line if mode is POL
    // std::ofstream & operator<<(std::ofstream &fs, const Vector &v) {
    //     if (v.mode_ == Vector::RECT) {
    //         fs << "(x, y) = " << v.x_ << ", " << v.y_ << "\n";
    //     } else if (v.mode_ == Vector::POL) {
    //         fs << "(m, a) = (" << v.mag_ << ", "
    //            << v.ang_ * Deg_To_Rad << ")\n";
    //     } else {
    //         cout << "Vector mode is invalid\n";
    //     }

    //     return fs;
    // }


} // end namespace VECTOR

```

2.在1的基础上不保存另一种表示，而是在需要使用到时才计算另一种表示方式

修改的地方：

（1）删除私有成员、初始化、重置；（2）删除私有setvalue函数，修改setxyvalue函数，使其接受两个参数初始化xy；（3）修改公有访问mag和ang的函数，改成在函数内根据xy计算mag和ang；（4）修改打印输出函数。

main.cpp

```
#include <iostream>
#include <cstdlib>  // rand(), srand()
#include <ctime>    // time()
#include "vector.h"


int main(void) {
    using namespace std;
    using namespace VECTOR;

    srand(time(0)); // seed random-number generator
    double direction;
    Vector step;
    Vector result(0.0, 0.0);
    unsigned long steps = 0;    // numbers of step
    double target;
    double dstep;

    cout << "Enter target distance(q to quit): ";
    while (cin >> target) {
        cout << "Enter step length: ";
        if (!(cin >> dstep)) break;

        while (result.magvalue() < target) {
            direction = rand() % 360;
            step.Reset(dstep, direction, Vector::POL);
            result = result + step;
            steps++;
        }

        // display on screen
        cout << "经过" << steps << "次步数， 目前到达：\n";
        cout << result;
        result.polar_mode();
        cout << result;
        cout << "平均每步走" << result.magvalue() / steps << '\n';

        // reset
        steps = 0;
        result.Reset(0, 0);
        cout << "Enter target distance(q to quit): ";
    }

    cout << "Done!\n";


    return 0;
}

```

vector.h

```
#ifndef VECTOR_H_
#define VECTOR_H_
#include <iostream>
#include <fstream>

namespace VECTOR {
    class Vector {
    public:
        // RECT for rectangular
        // POL for polar
        enum Mode{RECT, POL};
    private:
    // private member data
        double x_;
        double y_;
        Mode mode_;
    // private methods for setting value
        void set_x(double mag, double ang);
        void set_y(double mag, double ang);
    public:
    // construcors and destructor
        Vector();
        Vector(double n1, double n2, Mode form = RECT);
        ~Vector() {};
    // others methods
        void Reset(double n1, double n2, Mode form = RECT);
        double xvalue() const {return x_;}
        double yvalue() const {return y_;}
        double magvalue() const;
        double angvalue() const;
        void polar_mode();
        void rect_mode();
    // operator overloading
        Vector operator+(const Vector &v) const;
        Vector operator-(const Vector &v) const;
        Vector operator-() const;
        Vector operator*(double n) const;
    // friend methods
        friend Vector operator*(double n, const Vector &v);
        friend std::ostream & operator<<(std::ostream &os, const Vector &v);
        // friend std::ofstream & operator<<(std::ofstream &fs, const Vector &v);
    }; // end class declaration
} // end namespace VECTOR

#endif
```

vector.cpp

```
#include "vector.h"
#include <cmath>

using std::sqrt;
using std::sin;
using std::cos;
using std::atan;
using std::atan2;
using std::cout;


namespace VECTOR {
    const double Deg_To_Rad = 45.0 / atan(1);

// private methods for setting values
    void Vector::set_x(double mag, double ang) {
        x_ = mag * cos(ang);
    }

    void Vector::set_y(double mag, double ang) {
        y_ = mag * sin(ang);
    }

// public methods
    // default constructor: set values to zero
    // set default mode_(RETC)
    Vector::Vector() {
        x_ = y_ = 0;
        mode_ = RECT;
    }

    Vector::Vector(double n1, double n2, Mode form) {
        mode_ = form;
        if (form == RECT) {
            x_ = n1;
            y_ = n2;
        } else if (form == POL) {
            double mag = n1;
            double ang = n2 / Deg_To_Rad;
            set_x(mag, ang);
            set_y(mag, ang);
        } else {
            cout << "第三个参数输入不合法！\n";
            cout << "向量被设置为零\n";
            x_ = y_ = 0;
            mode_ = RECT;
        } // end if
    } // end constructor

// other methods
    // reset vector
    void Vector::Reset(double n1, double n2, Mode form) {
        mode_ = form;
        if (form == RECT) {
            x_ = n1;
            y_ = n2;
        } else if (form == POL) {
            double mag = n1;
            double ang = n2 / Deg_To_Rad;
            set_x(mag, ang);
            set_y(mag, ang);
        } else {
            cout << "第三个参数输入不合法！\n";
            cout << "向量被设置为零\n";
            x_ = y_ = 0;
            mode_ = RECT;
        } // end if
    } // end Reset

    double Vector::magvalue() const {
        return sqrt(x_ * x_ + y_ * y_);
    }
    
    double Vector::angvalue() const {
        return atan2(y_, x_);
    }

    // set to polar mode
    void Vector::polar_mode() {
        mode_ = POL;
    }

    // set to rectangular mode
    void Vector::rect_mode() {
        mode_ = RECT;
    }

// overload operator
    // add two vectors
    Vector Vector::operator+(const Vector &v) const {
        double x = x_ + v.x_;
        double y = y_ + v.y_;
        Vector res(x, y);
        
        return res;
    }

    // subtract v from this
    Vector Vector::operator-(const Vector &v) const {
        return Vector(x_ - v.x_, y_ - v.y_);
    }

    // reverse sign of vector
    Vector Vector::operator-() const {
        return Vector(-x_, -y_);
    }

    // multipy vector by n
    Vector Vector::operator*(double n) const {
        return Vector(n * x_, n * y_);
    }

// friend methods
    // multipy n by vector
    Vector operator*(double n, const Vector &v) {
        return v * n;
    }

    // overload << of cout
    // display rectangular coordinates if mode is RECT
    // else display polar coordinates if mode is POL
    std::ostream & operator<<(std::ostream &os, const Vector &v) {
        if (v.mode_ == Vector::RECT) {
            os << "(x, y) = (" << v.x_ << ", " << v.y_ << ")\n";
        } else if (v.mode_ == Vector::POL) {
            os << "(m, a) = (" << v.magvalue() << ", "
               << v.angvalue() * Deg_To_Rad << ")\n";
        } else {
            cout << "Vector mode is invalid";
        }

        return os;
    }

    // overload << of fout
    // save rectangular coordinates in a line if mode is RECT
    // else save polar coordinates in a line if mode is POL
    // std::ofstream & operator<<(std::ofstream &fs, const Vector &v) {
    //     if (v.mode_ == Vector::RECT) {
    //         fs << "(x, y) = " << v.x_ << ", " << v.y_ << "\n";
    //     } else if (v.mode_ == Vector::POL) {
    //         fs << "(m, a) = (" << v.mag_ << ", "
    //            << v.ang_ * Deg_To_Rad << ")\n";
    //     } else {
    //         cout << "Vector mode is invalid\n";
    //     }

    //     return fs;
    // }


} // end namespace VECTOR

```

3.计算N次随机漫步的最大次数、最小次数、平均步数，与类无关，不写。

4.修改Time类，把所有的成员函数重载运算符修改为友元：

main.cpp

```
#include <iostream>
#include "mytime.h"

int main(void) {
    Time start(2, 40), end(5, 55);

    std::cout << start + end << '\n';
    std::cout << start - end << '\n';
    std::cout << end - start << '\n';
    std::cout << 1 * end << '\n';
    std::cout << end * 2 << '\n';

    return 0;
}

```

mytime.h

```
#ifndef MYTIME_H_
#define MYTIME_H_
#include <iostream>

class Time {
private:
    static const int Min_To_Hour = 60;
    int hour_;
    int minute_;
public:
// constructor
    explicit Time(int h = 0, int m = 0);
// other methods
    void Reset(int h = 0, int m = 0);
// operator overloading
    Time operator*(double n) const;
// friend methods
    friend Time operator+(const Time &a, const Time &b);
    friend Time operator-(const Time &a, const Time &b);
    friend Time operator*(double n, const Time &a);
    friend std::ostream &operator<<(std::ostream &os, const Time &a);
};


#endif
```

mytime.cpp

```
#include "mytime.h"

// public methods
    // constructor
Time::Time(int h, int m) {
    hour_ = h;
    minute_ = m;
}

    // reset values
void Time::Reset(int h, int m) {
    hour_  = h;
    minute_ = m;
}

// operator overloading
    // multipy Time by n
Time Time::operator*(double n) const {
    int total_minutes = (hour_ * 60 + minute_) * n;
    return Time(total_minutes / Min_To_Hour, total_minutes % Min_To_Hour);
}


// friend methods
    // add two time
Time operator+(const Time &a, const Time &b) {
    int m = (a.minute_ + b.minute_) % Time::Min_To_Hour;
    int h = (a.hour_ + b.hour_) + (a.minute_ + b.minute_) / Time::Min_To_Hour;

    return Time(h, m);
}
    // substract b from a
Time operator-(const Time &a, const Time &b) {
    int total_min_a = a.hour_ * 60 + a.minute_;
    int total_min_b = b.hour_ * 60 + b.minute_;
    int d = total_min_b - total_min_a;
    if (d < 0) {
        std::cout << "Time error!\n";
        return Time();
    } else {
        return Time(d / Time::Min_To_Hour, d % Time::Min_To_Hour);
    } // end if
}
    // multiply n by Time
Time operator*(double n, const Time &a) {
    return a * n;
}

    // overload << of cout
std::ostream &operator<<(std::ostream &os, const Time &a) {
    std::cout << a.hour_ << "h : " << a.minute_ << 'm';

    return os;
}
```

5.在stonewt类的基础上增加一个状态成员，表示以哪种格式打印，并重载加减乘运算符

main.cpp

```
#include <iostream>
#include "stonewt.h"

int main(void) {
    using std::cout;

    Stonewt a(285.7);
    Stonewt b(21, 8);
    Stonewt c;

    cout << "----默认模式打印----\n";
    cout << a << '\n' << b << '\n' << c << '\n';

    cout << "----修改模式打印----\n";
    a.SetStone();
    b.SetPound();
    c.SetPound();
    cout << a << '\n' << b << '\n' << c << '\n';

    cout << "----测试加减乘----\n";
    cout << "a + b = " << a + b << '\n';
    cout << "a - b = " << a - b << '\n';
    cout << "a * 2 = " << a * 2 << '\n';
    cout << "2 * a = " << 2 * a << '\n';
 
    return 0;
}
```

stonewt.h

```
#ifndef STONEWT_H_
#define STONEWT_H_
#include <iostream>

class Stonewt {
public:
    enum State {STONE, POUND};
private:
    enum {pd_per_stn = 14}; // pounds per stone
    int stone_;
    double pds_left_;
    double pounds_;
    State state_;

public:
// public methods
    Stonewt(int stone, double lbs, State state = STONE);
    explicit Stonewt(double lbs, State state = POUND);
    Stonewt(State state = STONE);
    void SetStone();
    void SetPound();
// operator overloading
    Stonewt operator*(double n) const;

// friend methods
    friend Stonewt operator+(const Stonewt &a, const Stonewt &b);
    friend Stonewt operator-(const Stonewt &a, const Stonewt &b);
    friend Stonewt operator*(double n, const Stonewt &a);
    friend std::ostream &operator<<(std::ostream &, const Stonewt &s);
};

#endif
```

stonewt.cpp

```
#include "stonewt.h"

// constructor
Stonewt::Stonewt(int stone, double lbs, State state) {
    stone_ = stone;
    pds_left_ = lbs;
    pounds_ = stone * pd_per_stn + lbs;
    state_ = state;
}

Stonewt::Stonewt(double lbs, State state) {
    pounds_ = lbs;
    stone_ = int(lbs) / pd_per_stn;
    pds_left_ = int(lbs) / pd_per_stn + lbs - int(lbs);
    state_ = state;
}

Stonewt::Stonewt(State state) {
    stone_ = pds_left_ = pounds_ = 0;
    state_ = STONE;
    state_ = state;
}

// other methods
    // set state to Stone
void Stonewt::SetStone() {
    state_ = STONE;
}

    // set state to pound
void Stonewt::SetPound() {
    state_ = POUND;
}

// operator overloading
Stonewt Stonewt::operator*(double n) const {
    double pds = pounds_ * n;
    return Stonewt(pds);
}

// friend methods
Stonewt operator+(const Stonewt &a, const Stonewt &b) {
    return Stonewt(a.pounds_ + b.pounds_);
}

Stonewt operator-(const Stonewt &a, const Stonewt &b) {
    return Stonewt(a.pounds_ - b.pounds_);
}

Stonewt operator*(double n, const Stonewt &a) {
    return a * n;
}

std::ostream & operator<<(std::ostream &os, const Stonewt & s) {
    if (s.state_ == Stonewt::POUND) {
        os << s.pounds_ << "pds";
    } else if (s.state_ == Stonewt::STONE) {
        os << s.stone_ << "stone" << ", " << s.pds_left_ << "pds";
    } else {
        std::cout << "格式不合法，请重新设置state\n";
    }

    return os;
}
```

6.在5的基础上重载6个关系运算符

main.cpp

```
#include <iostream>
#include "stonewt.h"

int main(void) {
    using std::cout;
    using std::cin;

    Stonewt arr[6] = {155, 222, 11};
    for (int i = 3; i < 6; i++) {
        cout << "请以磅输入重量：";
        cin >> arr[i];
    }

    Stonewt mins = arr[0];
    Stonewt t(11, 0);
    int count = 0;

    for (int i = 0; i < 6; i++) {
        arr[i] < mins ? mins = arr[i] : mins;
        arr[i] >=  t ? count++ : count;
    }
    cout << "最小值为：" <<  mins << '\n';
    cout << "一共有" << count << "个大于11英石\n";


    return 0;
}

```

stonewt.h

```
#ifndef STONEWT_H_
#define STONEWT_H_
#include <iostream>

class Stonewt {
public:
    enum State {STONE, POUND};
private:
    enum {pd_per_stn = 14}; // pounds per stone
    int stone_;
    double pds_left_;
    double pounds_;
    State state_;

public:
// public methods
    Stonewt(int stone, double lbs, State state = STONE);
    Stonewt(double lbs, State state = POUND);
    Stonewt(State state = STONE);
    void SetStone();
    void SetPound();
// conversion functions
    explicit operator double() const;
// operator overloading
    Stonewt operator*(double n) const;
    bool operator<(const Stonewt &other) const;
    bool operator>(const Stonewt &other) const;
    bool operator==(const Stonewt &other) const;
    bool operator!=(const Stonewt &other) const;
    bool operator<=(const Stonewt &other) const;
    bool operator>=(const Stonewt &other) const;

// friend methods
    friend Stonewt operator+(const Stonewt &a, const Stonewt &b);
    friend Stonewt operator-(const Stonewt &a, const Stonewt &b);
    friend Stonewt operator*(double n, const Stonewt &a);
    friend std::ostream &operator<<(std::ostream &, const Stonewt &s);
    friend std::istream &operator>>(std::istream &, Stonewt &s);
};

#endif
```

stonewt.cpp

```
#include "stonewt.h"

// constructor
Stonewt::Stonewt(int stone, double lbs, State state) {
    stone_ = stone;
    pds_left_ = lbs;
    pounds_ = stone * pd_per_stn + lbs;
    state_ = state;
}

Stonewt::Stonewt(double lbs, State state) {
    pounds_ = lbs;
    stone_ = int(lbs) / pd_per_stn;
    pds_left_ = int(lbs) / pd_per_stn + lbs - int(lbs);
    state_ = state;
}

Stonewt::Stonewt(State state) {
    stone_ = pds_left_ = pounds_ = 0;
    state_ = STONE;
    state_ = state;
}

// other methods
    // set state to Stone
void Stonewt::SetStone() {
    state_ = STONE;
}

    // set state to pound
void Stonewt::SetPound() {
    state_ = POUND;
}

// conversion functions
Stonewt::operator double() const {
    return pounds_;
}

// operator overloading
Stonewt Stonewt::operator*(double n) const {
    double pds = pounds_ * n;
    return Stonewt(pds);
}

bool Stonewt::operator<(const Stonewt &other) const {
    return pounds_ < other.pounds_;
}

bool Stonewt::operator>(const Stonewt &other) const {
    return pounds_ > other.pounds_;
}

bool Stonewt::operator==(const Stonewt &other) const {
    return pounds_ == other.pounds_;
}

bool Stonewt::operator!=(const Stonewt &other) const {
    return pounds_ != other.pounds_;
}

bool Stonewt::operator<=(const Stonewt &other) const {
    return pounds_ <= other.pounds_;
}

bool Stonewt::operator>=(const Stonewt &other) const {
    return pounds_ >= other.pounds_;
}

// friend methods
Stonewt operator+(const Stonewt &a, const Stonewt &b) {
    return Stonewt(a.pounds_ + b.pounds_);
}

Stonewt operator-(const Stonewt &a, const Stonewt &b) {
    return Stonewt(a.pounds_ - b.pounds_);
}

Stonewt operator*(double n, const Stonewt &a) {
    return a * n;
}

std::ostream & operator<<(std::ostream &os, const Stonewt & s) {
    if (s.state_ == Stonewt::POUND) {
        os << s.pounds_ << "pds";
    } else if (s.state_ == Stonewt::STONE) {
        os << s.stone_ << "stone" << ", " << s.pds_left_ << "pds";
    } else {
        std::cout << "格式不合法，请重新设置state\n";
    }

    return os;
}

std::istream &operator>>(std::istream &is, Stonewt &s) {
    double temp;
    if (is >> temp) {
        s = Stonewt(temp);
    }
    return is;
}
```

7.实现复数类

main.cpp

```
#include <iostream>
#include "complex0.h"

int main(void) {
    using std::cout;
    using std::cin;

    Complex a(3.0, 4.0);
    Complex c;

    cout << "输入一个复数：（q退出）\n";
    while (cin >> c) {
        cout << "c is " << c << '\n';
        cout << "c 的共轭是：" << ~c << '\n';
        cout << "a is " << a << '\n';
        cout << "a + c = " << a + c << '\n';
        cout << "a - c = " << a - c << '\n';
        cout << "a * c = " << a * c << '\n';
        cout << "2 * c = " << 2 * c << '\n';
        cout << "输入一个复数：（q退出）\n";
    }
    cout << "Done！\n";

    return 0;
}

```

complex.h

```
#ifndef COMPLEX0_H_
#define COMPLEX0_H
#include <iostream>
#include <cstring>

class Complex {
private:
    double real_;
    double imag_;
public:
    Complex(double a = 0, double b = 0);

    Complex operator+(const Complex &t);
    Complex operator-(const Complex &t);
    Complex operator*(const Complex &t);
    Complex operator~() const;


    friend Complex operator*(double x, const Complex &t);
    friend std::ostream & operator<<(std::ostream &os, const Complex &it);
    friend std::istream & operator>>(std::istream &is, Complex &it);
};


#endif
```

comlpex.cpp

```
#include "complex0.h"

Complex::Complex(double a, double b) {
    real_ = a;
    imag_ = b;
}

Complex Complex::operator+(const Complex &t) {
    Complex res(this->real_ + t.real_, this->imag_ + t.imag_);
    return res;
}

Complex Complex::operator-(const Complex &t) {
    Complex res(this->real_ - t.real_, this->imag_ - t.imag_);
    return res;
}

Complex Complex::operator*(const Complex &t) {
    Complex res;
    double A = this->real_;
    double B = this->imag_;
    double C = t.real_;
    double D = t.imag_;
    res.real_ = A*C - B*D;
    res.imag_ = A*D + B*C;
    return res;
}

Complex Complex::operator~() const {
    Complex res = *this;
    res.imag_ = -res.imag_;
    return res;
}

Complex operator*(double x, const Complex &t) {
    Complex res(x * t.real_, x * t.imag_);
    return res;
}

std::ostream & operator<<(std::ostream &os, const Complex &it) {
    std::cout << "(" << it.real_ << ", " << it.imag_ << "i)";
    return os;
}

std::istream & operator>>(std::istream &is, Complex &it) {
    using std::cout;
    double temp;
    cout << "请输入实数部分：";
    if (!(is >> temp)) return is;
    it.real_ = temp;
    while (is.get() != '\n') continue;
    
    cout << "请输入虚数部分：";
    if (!(is >> temp)) return is;
    it.imag_ = temp;
    while (is.get() != '\n') continue;    

    return is;
}
```



# 第十二章

总代码行数：1000行

1.动态内存和构造、复制构造、赋值运算符

main.cpp

```
#include <iostream>
#include "cow.h"

int main(void) {
    Cow c1;
    // c1.Show();
    Cow c2("牛", "吃草" , 200);
    c2.Show();
    Cow c3 = c2;
    c3.Show();
    c1 = c2;
    c1.Show();


    return 0;
}

```

cow.h

```
#ifndef COW_H_
#define COW_H_
#include <iostream>
#include <cstring>

class Cow {
private:
    char name_[20];
    char * hobby_;
    double weight_;
public:
// constructor and destructor
    Cow();
    Cow(const char *name, const char *ho, double wt);
    Cow(const Cow &c);
    ~Cow();
    Cow & operator=(const Cow &c);

// other methods
    void Show();

};

#endif
```

cow.cpp

```
#include "cow.h"

// constructor and destructor
    // default constructor
Cow::Cow() {
    name_[0] = '\0';
    hobby_ = nullptr;
    weight_ = 0;
    std::cout << "default constructor" << std::endl;
}

    // constructor
Cow::Cow(const char* name, const char *ho, double wt) {
    int name_len = std::strlen(name);
    if (name_len >= 20) 
        std::cout << "Warring: Tne length of  Cow name can only be within 20\n";
    
    std::strncpy(name_, name, 20 - 1);

    int ho_len = std::strlen(ho);
    hobby_ = new char[ho_len + 1];
    std::strcpy(hobby_, ho);

    weight_ = wt;
    std::cout << "constructor\n";
}

    // copy constructor
Cow::Cow(const Cow &c) {
    std::strcpy(name_, c.name_);
    int ho_len = std::strlen(c.hobby_);
    hobby_ = new char[ho_len + 1];
    std::strcpy(hobby_, c.hobby_);
    weight_ = c.weight_;

    std::cout << "copy constructor\n";
}

    // assignment operator
Cow & Cow::operator=(const Cow &c) {
    if (&c == this)
        return *this;
    delete hobby_;

    std::strcpy(name_, c.name_);
    int ho_len = std::strlen(c.hobby_);
    hobby_ = new char[ho_len + 1];
    std::strcpy(hobby_, c.hobby_);
    weight_ = c.weight_;

    std::cout << "assignment operator\n";

    return *this;
}

    // destructor
Cow::~Cow() {
    delete hobby_;
}

// other methods
void Cow::Show() {
    std::cout << name_ << ", " << hobby_ << ", "
              << weight_ << "kg\n";
}
```

2.字符串类：复制构造函数、赋值运算符、重载加法、转换大小写、计算字符数、重载cin、cout

main.cpp

```
#include <iostream>
#include "stringbad.h"
using namespace std;

int main(void) {
    StringBad s1(" and I am a C++ student.");
    StringBad s2("Please enter your name: ");
    StringBad s3;
    cout << s2;
    cin >> s3;
    s2 = "My name is " + s3;
    cout << s2 << '\n';
    s2 = s2 + s1;
    s2.StringUpper();
    cout << "The string: " << s2 << "\ncontains " << s2.CountChar('A')
         << " 'A' characters in it.\n";

    cout << "-----------------\n";
    s1 = "red";
    StringBad rgb[3] = {StringBad(s1), StringBad("green"), StringBad("blue")};

    cout << "-----------------\n";
    cout << "输入混合光的基础颜色：";
    StringBad ans;
    bool success = false;
    while (cin >> ans) {
        ans.StringLower();
        for (int i = 0; i < 3; i++) {
            if (ans == rgb[i]) {
                cout << "right！\n";
                success = true;
                break;
            }
        } // end for

        if (success) break;
        else cout << "try anain!\n";
    }


    return 0;
}

```

stringbad.h

```
#ifndef STRINGBAD_H_
#define STRINGBAD_H_

#include <iostream>
#include <cstring>
#include <cctype>

class StringBad {
private:
    char *str;
    int len;
    static int num_strings;
    static const int CinLimit = 80;
public:
// 构造函数和其他函数
    StringBad(const char *s);
    StringBad();
    StringBad(const StringBad &st);
    ~StringBad();

// other methods
    void StringLower();
    void StringUpper();
    int CountChar(const char c);

// 重载运算符
    StringBad & operator=(const StringBad &st);
    StringBad & operator=(const char *s);
    char & operator[](int i);
    const char & operator[](int i) const;

// 友元函数
    friend StringBad operator+(const StringBad &a, const StringBad &b);
    friend bool operator<(const StringBad &st, const StringBad &other);
    friend bool operator>(const StringBad &st, const StringBad &other);
    friend bool operator==(const StringBad &st, const StringBad &other);
    friend std::ostream & operator<<(std::ostream &os, const StringBad &st);
    friend std::istream & operator>>(std::istream &is, StringBad &st);

// 静态函数
    static int HowMany();
    
};

#endif
```

string.cpp

```
#include "stringbad.h"

//* 初始化静态变量
int StringBad::num_strings = 0;

//* 静态方法
int StringBad::HowMany() {
    return num_strings;
}

//* 构造函数和其它函数
// 构造函数
StringBad::StringBad(const char *s) {
    len = std::strlen(s);
    str = new char[len + 1];
    std::strcpy(str, s);
    num_strings++;
    
    std::cout << "constructor\n";
}

// 默认构造函数
StringBad::StringBad() {
    // str = new char[4];
    // std::strcpy(str, "C++");
    str = nullptr;
    num_strings++;

    std::cout << "default constructor\n";
}

// 复制构造函数
StringBad::StringBad(const StringBad &st) {
    len = st.len;
    str = new char[len + 1];
    std::strcpy(str, st.str);
    num_strings++;

    std::cout << "copy constructor\n";
}

// 析构函数
StringBad::~StringBad() {
    num_strings--;

    delete [] str;
}

// other methods
    // lower characters
void StringBad::StringLower() {
    int i = 0;
    while (str[i]) {
        if (isalpha(str[i])) {
            str[i] = tolower(str[i]);
            i++;
        } else {
            i++;
        } // end if
    } // end while
}

    // upper characters
void StringBad::StringUpper() {
    int i = 0;
    while (str[i]) {
        if (isalpha(str[i])) {
            str[i] = toupper(str[i]);
            i++;
        } else {
            i++;
        } // end if
    } // end while
}

    // count char
int StringBad::CountChar(char c) {
    int i = 0;
    int count = 0;
    while (str[i]) {
        if (str[i] == c) {
            i++, count++;
        } else {
            i++;
        } // end if
    } // end while

    return count;
}

//* 重载运算符成员函数
// 重载赋值=运算符：用另一个对象
StringBad & StringBad::operator=(const StringBad &st) {
    if (&st == this) return *this;
    delete [] str;
    len = st.len;
    str = new char[len + 1];
    std::strcpy(str, st.str);

    std::cout << "调用了赋值运算符！\n";
    return *this;
}

// 重载赋值=运算符：用C字符串
StringBad & StringBad::operator=(const char *s) {
    delete [] str;
    len = std::strlen(s);
    str = new char[len + 1];
    std::strcpy(str, s);
    std::cout << "调用了赋值运算符！\n";
    return *this;
}

// 重载[]运算符
char & StringBad::operator[](int i) {
    return str[i];
}

// 重载[]运算符：不可修改返回值
const char & StringBad::operator[](int i) const {
    return str[i];
}


//* 重载运算符友元函数
    // add two StringBad instances
StringBad operator+(const StringBad &a, const StringBad &b) {
    int len_a = std::strlen(a.str);
    int len_b = std::strlen(b.str);

    char *temp = new char[len_a + len_b + 1];
    temp[0] = '\0';
    std::strcat(temp, a.str);
    std::strcat(temp, b.str);

    StringBad res(temp);
    delete[] temp;

    return res;
}


// 重载<比较运算符
bool operator<(const StringBad &st, const StringBad &other) {
    return std::strcmp(st.str, other.str) < 0;
}

// 重载>比较运算符
bool operator>(const StringBad &st, const StringBad &other) {
    return other < st;
}

// 重载==比较运算符
bool operator==(const StringBad &st, const StringBad &other) {
    return std::strcmp(st.str, other.str) == 0;
}

// 重载<<运算符：cout
std::ostream & operator<<(std::ostream &os, const StringBad &st) {
    os << st.str;
    return os;
}

// 重载>>运算符：cin
std::istream & operator>>(std::istream &is, StringBad &st) {
    char temp[StringBad::CinLimit];
    is.get(temp, StringBad::CinLimit);
    if (is) st = temp; // 调用重载赋值运算符
    while (is && is.get() != '\n') continue;

    return is;
}
```

3.stock类，复制构造函数、赋值运算符、cout<<

main.cpp

```
#include <iostream>
#include "stock.h"

int main(void) {
    using namespace std;
    Stock arr[4] = {
        Stock("NanoSmart", 12, 20.0),
        Stock("Boffo Object", 200, 2.0),
        Stock("Obelisks", 130, 3.25),
        Stock("Fleep", 60, 6.5),
   };

   for (int i = 0; i < 4; i++) {
        cout << arr[i];
   }

    cout << "----测试复制构造函数等----\n";
    Stock s1;
    cout << s1;
    Stock s2("test2", 23, 2.3);
    cout << s2;
    Stock s3 = s2;
    cout << s3;
    s1 = s2;
    cout << s1;

    cout << "----测试普通函数---\n";
    s1.Buy(2, 2.0);
    cout << s1;
    s1.update(10);
    cout << s1;
    s1.Sell(1, 2.0);
    cout << s1;

    return 0;
}

```

stock.h

```
#ifndef STOCK_H_
#define STOCK_H_
#include <iostream>
#include <cstring>

class Stock {
private:
    char *company_;
    int shares_;
    double share_val_;
    double total_val_;
    void SetTotal();
public:
// constructor and destructor
    Stock();
    Stock(const char *company, int shares, double share_val);
    Stock(const Stock &other);
    ~Stock();
// other methods
    void Buy(int num, double price);
    void Sell(int num, double price);
    void update(double price);
// operator overloading
    Stock &operator=(const Stock &other);

// friend methods
    friend std::ostream &operator<<(std::ostream &os, const Stock &s);

};

#endif
```

stock.cpp

```
#include "stock.h"

// private methods
void Stock::SetTotal() {
    total_val_ = shares_ * share_val_;
}

// constructor and destructor
Stock::Stock() {
    company_ = nullptr;
    shares_ = share_val_ = total_val_ = 0;
    SetTotal();
}

Stock::Stock(const char *company, int shares, double share_val) {
    int name_len = std::strlen(company);
    company_ = new char[name_len + 1];
    std::strcpy(company_, company);
    
    if (shares < 0) {
        std::cout << "shares can't be negative, "
                  << "set shares to zero\n";
        shares_ = 0;
    } else {
        shares_ = shares;
    }
    
    share_val_ = share_val;
    SetTotal();

    std::cout << "constructor\n";
}

Stock::Stock(const Stock &other) {
    int name_len = std::strlen(other.company_);
    company_ = new char[name_len + 1];
    std::strcpy(company_, other.company_);

    if (other.shares_ < 0) {
        std::cout << "shares can't be negative, "
                  << "set shares to zero\n";
        shares_ = 0;
    } else {
        shares_ = other.shares_;
    }

    share_val_ = other.share_val_;
    SetTotal();

    std::cout << "copy constructor\n";
}

Stock::~Stock() {
    delete[] company_;
}

// other methods
    // buy some shares
void Stock::Buy(int num, double price) {
    if (num < 0) {
        std::cout << "you can't buy less than zero\n";
    } else {
        shares_ += num;
        share_val_ = price;
        SetTotal();
    } // end if
}

    // sell some shares
void Stock::Sell(int num, double price) {
    if (num < 0) {
        std::cout << "you can't sell less than zero\n";
    } else if (num > shares_) {
        std::cout << "you have " << shares_ << ", which means"
                  << " you can't sell more than you have\n";
    } else {
        shares_ -= num;
        share_val_ = price;
        SetTotal();
    } // end if
}

    // update share_val
void Stock::update(double price) {
    share_val_ = price;
    SetTotal();
}

// operator overloding
    // assignment operator
Stock & Stock::operator=(const Stock &other) {
    if (&other == this) return *this;
    delete[] company_;

    int name_len = std::strlen(other.company_);
    company_ = new char[name_len + 1];
    std::strcpy(company_, other.company_);
    shares_ = other.shares_;
    share_val_ = other.share_val_;
    SetTotal();

    std::cout << "assignment operator\n";
    return *this;
}

// friend method
std::ostream & operator<<(std::ostream &os, const Stock &s) {
    if (!s.company_) {
        os << "This instance does't exist.\n";
    } else {
        os << "company name: " << s.company_ << '\n'
           << "hold shares: " << s.shares_ << '\n'
           << "share price: " << s.share_val_ << '\n'
           << "total price: " << s.total_val_ << '\n'; 
    }

    return os;
}
```

4.动态申请数组的stack类

main.cpp

```
#include <iostream>
#include <cctype>
#include "stack.h"

int main(void) {
    using namespace std;

    Stack s;
    Stack history[10];
    int count = 0;
    Item e;
    char choice;

    cout << "请选择入栈（p）还是出栈（q）：";
    while (cin.get(choice) && choice != '\n') {
        while (cin.get() != '\n') continue; // read last part of this line
        if (toupper(choice) == 'P') {
            cout << "请输入入栈元素：";
            while (!(cin >> e)) {
                cin.clear();
                while (cin.get() != '\n') continue;
                cout << "输入元素不合法！请重新输入；";
            }
            while (cin.get() != '\n') continue; // read this whole line

            if (s.push(e)) {
                cout << "入栈成功！\n";
                history[count++] = s;
            } else {
                cout << "栈满，入栈失败！\n";
            } // end if push

            
            
        } else if (toupper(choice) == 'Q') {
            if (s.pop(e)) {
                cout << "出栈元素为：" << e << '\n';
                history[count++] = s;
            } else {
                cout << "栈空，出栈失败！\n";
            } // end if pop
            
        } else {
            break;
        } // end if choice

        
        cout << "请选择入栈（p）还是出栈（q）：";
    }
    cout << "Done!\n";

    cout << "栈的状态变化如下：\n";
    for (int i = 0; i < count; i++) {
        cout << history[i] << '\n';
    }

    return 0;
}

```

stack.h

```
#ifndef STACK_H_
#define STACK_H_

#include <iostream>
typedef long Item;

class Stack {
public:
    enum {MAX = 10};
    Item *pitems;
    int size;
    int top;
public:
    explicit Stack(int n = MAX);
    Stack(const Stack &other);
    ~Stack();

    bool IsEmpty() const;
    bool IsFull() const;
    bool push(const Item &e);
    bool pop(Item &e);

    Stack & operator=(const Stack &other);

    friend std::ostream &operator<<(std::ostream &os, const Stack &s);
};


#endif
```

stack.cpp

```
#include "stack.h"

Stack::Stack(int n) {
    if (n < 0) {
        std::cout << "The length of the stack cannot be negative, "
                  << "the stack is set to zero." << '\n';
        pitems = nullptr;
        size = 0;
        top = 0;
    } else if (n == 0) {
        pitems = nullptr;
        size = 0;
        top = 0;
    } else {
        pitems = new Item[n];
        size = n;
        top = 0;
    } // end if
}

Stack::Stack(const Stack &other) {
    size = other.size;
    pitems = new Item[size];
    for (int i = 0; i < top; i++) {
        pitems[i] = other.pitems[i];
    }

    top = other.top;
}

Stack::~Stack() {
    delete[] pitems;
}

bool Stack::IsEmpty() const {
    return top == 0;
}

bool Stack::IsFull() const {
    return top == size;
}

bool Stack::push(const Item &e) {
    if (!IsFull()) {
        pitems[top] = e;
        top++;
        return true;
    } else {
        return false;
    }
}

bool Stack::pop(Item &e) {
    if (!IsEmpty()) {
        e = pitems[top - 1];
        top--;
        return true;
    } else {
        return false;
    }
}

Stack & Stack::operator=(const Stack &other) {
    if (&other == this) return *this;
    delete[] pitems;

    size = other.size;
    pitems = new Item[size];
    top = other.top;
    for (int i = 0; i < top; i++) {
        pitems[i] = other.pitems[i];
    }

    return *this;
}

std::ostream &operator<<(std::ostream &os, const Stack &s) {
    if (s.IsEmpty()) {
        os << "Empty Stack";
        return os;
    } else {
        for (int i = 0; i < s.top; i++) {
            os << s.pitems[i] << "  ";
        }
        
        return os;
    }
}

```

5.队列类、顾客类、

队列类实现加测试：

main.cpp

```
#include <iostream>
#include <cctype> // toupper()
#include "queue.h"

int main(void) {
    using std::cout;
    using std::cin;
    
    Queue q;
    char choice;
    Item e;
    int count = 0;
    Queue arr[10];

    cout << "请选择入队(e)还是出队(d):";
    while (cin.get(choice) && choice != '\n') {
        while (cin.get() != '\n') continue; // read the reamins of this line

        if (toupper(choice) == 'E') {
            cout << "请输入入队元素：";
            while (!(cin >> e)) {
                cin.clear();
                while (cin.get() != '\n') continue; // read the reamins of this line
                cout << "输入不合法！请重新输入：";
            }
            while (cin.get() != '\n') continue; // read the reamins of this line

            // enter the queue
            if (q.enqueue(e)) {
                cout << e << "入队成功！\n";
                arr[count++] = q;
            } else {
                cout << "队列满！入队失败！\n";
            }

        } else if (toupper(choice) == 'D') {
            if (q.dequeue(e)) {
                cout << "出队元素为：" << e << '\n';
                arr[count++] = q;
            } else {
                cout << "队列空！出队失败！\n";
            }

        } else {
            break;
        }

        cout << "请选择入队(e)还是出队(d):";
    }

    cout << "队列状态变化为：\n";
    for (int i = 0; i < count; i++) {
        cout << arr[i] << '\n';
    }

    return 0;
}
```

queue.h

```
#ifndef QUEUE_H_
#define QUEUE_H_

#include <iostream>
typedef int Item;

class Queue {
private:
    enum {Q_SIZE = 10};
    struct Node {
        Item item;
        Node *next;
    };
    Node *head;
    Node *rear;
    int nums;
    const int qsize;
public:
    Queue(int qs = Q_SIZE);
    Queue(const Queue &other);
    ~Queue();

    bool isEmpty() const;
    bool isFull() const;
    int queueCount() const;
    bool enqueue(const Item &item);
    bool dequeue(Item &item);

    Queue &operator=(const Queue &other);

    friend std::ostream &operator<<(std::ostream &os, const Queue &q);
};


#endif
```

queue.cpp

```
#include "queue.h"

// constructor and destructor
Queue::Queue(int qs) : qsize(qs) {
    head = rear = nullptr;
    nums = 0;
}

    // copy constructor
Queue::Queue(const Queue& other) : qsize(Q_SIZE) {
    nums = other.nums;
    head = rear = nullptr;
    Node *temp; // copy other's node
    Node *p; // travellingly points to erver node of other
    p = other.head;
    while (p) {
        if (!head) { // if there is no head
            temp = new Node;
            temp->item = p->item;
            temp->next = nullptr;

            head = rear = temp; // copy other's head
        } else {
            temp = new Node;
            temp->item = p->item;
            temp->next = nullptr;
            
            rear->next = temp; // copy other's node
            rear = temp; // keep rear points to the last one
        }

        p = p->next;
    }
}

Queue::~Queue() {
    // delete from head
    Node *temp;
    while (head) {
        temp = head;
        head = head->next;
        delete temp;
    }
}

// other methods
bool Queue::isEmpty() const {
    return nums == 0;
}

bool Queue::isFull() const {
    return nums == qsize;
}

int Queue::queueCount() const {
    return nums;
}

bool Queue::enqueue(const Item &item) {
    if (isFull()) return false;
    else {
        // create new Node
        Node *pnewNode = new Node;
        pnewNode->item = item;
        pnewNode->next = nullptr; // new node will be the last one

        // enter queue
        if (!head) {
            head = pnewNode;
        } else {
            rear->next = pnewNode;
        }
        nums++;
        rear = pnewNode;

        return true;
    }
}

bool Queue::dequeue(Item &e) {
    if (isEmpty()) return false;
    else {
        e = head->item;

        // delete head
        Node *temp = head;
        head = head->next;
        delete temp;

        nums--;

        return true;
    }
}

Queue &Queue::operator=(const Queue &other) {
    if (&other == this) return *this;
    // delete old memory
    Node *temp;
    while (head) {
        temp = head;
        head = head->next;
        delete temp;
    }

    // copy
    nums = other.nums;
    head = rear = nullptr;
    // Node *temp; // copy other's node
    Node *p; // travellingly points to erver node of other
    p = other.head;
    while (p) {
        if (!head) { // if there is no head
            temp = new Node;
            temp->item = p->item;
            temp->next = nullptr;

            head = rear = temp; // copy other's head
        } else {
            temp = new Node;
            temp->item = p->item;
            temp->next = nullptr;
            
            rear->next = temp; // copy other's node
            rear = temp; // keep rear points to the last one
        }

        p = p->next;
    }
    return *this;
}

std::ostream &operator<<(std::ostream &os, const Queue &q) {
    if (q.isEmpty()) {
        os << "queue is empty";
        return os;
    } else {
        Queue::Node *p; // travellingly points to node of queue
        p = q.head;

        while (p) {
            os << p->item << "  ";
            p = p->next;
        }

        return os;
    }
}
```

ATM模拟：

main.cpp

```
#include <iostream>
#include <cstdlib>  // for srand(), rand()
#include <ctime>    // for time()
#include "queue.h"

bool newcustomer(double x);

int main(void) {
    using std::cout;
    using std::cin;

    
    cout << "输入最大队列数目：";
    int qs;
    cin >> qs;
    Queue line(qs);

    cout << "输入模拟时间(小时)：";
    int hours;
    cin >> hours;
    const int MIN_PER_HOUR = 60;
    long cycle_limit =  MIN_PER_HOUR * hours;

    double average_wait_time = 0;
    while (average_wait_time <= 1) {
    // set up
        std::srand(time(0));

        cout << "输入一个小时的平均顾客到达数目：";
        double perhour;
        cin >> perhour;
        double min_per_cust = MIN_PER_HOUR / perhour;

        Item temp;          // new cuntomer data;
        long turnaways = 0; // turn away because of full queue
        long customers = 0; // number of customers joined the queue
        long served = 0;    // serverd numbers
        long sum_line = 0;  // cumulative line length
        long wait_time = 0; // time until handler is free
        long line_wait = 0; // cumulative time in line

    // start simulation
        for (int cycle = 0; cycle < cycle_limit; cycle++) {
            if (newcustomer(min_per_cust)) {
                if (line.isFull()) {
                    turnaways++;
                } else {
                    customers++;
                    temp.set(cycle); // set arrived time
                    line.enqueue(temp); // enter queue

                }
            }

            if (wait_time <= 0 && !line.isEmpty()) {
                line.dequeue(temp);
                wait_time += temp.ptime();
                line_wait += cycle - temp.when();
                served++;
            }

            if (wait_time > 0) wait_time--;
            sum_line += line.queueCount();
        }

    // report result
        if (customers > 0) {
            cout << "接待顾客数目：" << customers << '\n';
            cout << "服务顾客数目：" << served << '\n';
            cout << "因队列满而未接待数目：" << turnaways << '\n';
            cout << "平均每分钟队列长度：";
            cout << (double)line_wait / cycle_limit << '\n';
            average_wait_time = (double)line_wait / served;
            cout << "平均等待时间：" << average_wait_time << '\n';
        } else {
            cout << "No customers!\n";
        }


    } // end while
    return 0;
}

bool newcustomer(double x) {
    return (std::rand() * x / RAND_MAX) < 1;
}
```

customer.h

```
#ifndef CUSTOMER_H_
#define CUSTOMER_H_
#include <cstdlib>

class Customer {
private:
    long arrived_time;
    int processing_time;
public:
    Customer() {arrived_time = processing_time = 0;}
    void set(long when) {
        processing_time = std::rand() % 3 + 1;
        arrived_time = when;
    }
    long when() {return arrived_time;}
    int ptime() {return processing_time;}

};

// void Customer::set(long when) {
//     processing_time = std::rand() % 3 + 1;
//     arrived_time = when;
// }

#endif
```

queue.h

```
#ifndef QUEUE_H_
#define QUEUE_H_

#include <iostream>
#include "customer.h"

typedef Customer Item;

class Queue {
private:
    enum {Q_SIZE = 10};
    struct Node {
        Item item;
        Node *next;
    };
    Node *head;
    Node *rear;
    int nums;
    const int qsize;
public:
    Queue(int qs = Q_SIZE);
    // Queue(const Queue &other);
    ~Queue();

    bool isEmpty() const;
    bool isFull() const;
    int queueCount() const;
    bool enqueue(const Item &item);
    bool dequeue(Item &item);

    // Queue &operator=(const Queue &other);

    // friend std::ostream &operator<<(std::ostream &os, const Queue &q);
};


#endif
```

queue.cpp

```
#include "queue.h"

// constructor and destructor
Queue::Queue(int qs) : qsize(qs) {
    head = rear = nullptr;
    nums = 0;
}

    // copy constructor
// Queue::Queue(const Queue& other) : qsize(Q_SIZE) {
//     nums = other.nums;
//     head = rear = nullptr;
//     Node *temp; // copy other's node
//     Node *p; // travellingly points to erver node of other
//     p = other.head;
//     while (p) {
//         if (!head) { // if there is no head
//             temp = new Node;
//             temp->item = p->item;
//             temp->next = nullptr;

//             head = rear = temp; // copy other's head
//         } else {
//             temp = new Node;
//             temp->item = p->item;
//             temp->next = nullptr;
            
//             rear->next = temp; // copy other's node
//             rear = temp; // keep rear points to the last one
//         }

//         p = p->next;
//     }
// }

Queue::~Queue() {
    // delete from head
    Node *temp;
    while (head) {
        temp = head;
        head = head->next;
        delete temp;
    }
}

// other methods
bool Queue::isEmpty() const {
    return nums == 0;
}

bool Queue::isFull() const {
    return nums == qsize;
}

int Queue::queueCount() const {
    return nums;
}

bool Queue::enqueue(const Item &item) {
    if (isFull()) return false;
    else {
        // create new Node
        Node *pnewNode = new Node;
        pnewNode->item = item;
        pnewNode->next = nullptr; // new node will be the last one

        // enter queue
        if (!head) {
            head = pnewNode;
        } else {
            rear->next = pnewNode;
        }
        nums++;
        rear = pnewNode;

        return true;
    }
}

bool Queue::dequeue(Item &e) {
    if (isEmpty()) return false;
    else {
        e = head->item;

        // delete head
        Node *temp = head;
        head = head->next;
        delete temp;

        nums--;

        return true;
    }
}

// Queue &Queue::operator=(const Queue &other) {
//     if (&other == this) return *this;
//     // delete old memory
//     Node *temp;
//     while (head) {
//         temp = head;
//         head = head->next;
//         delete temp;
//     }

//     // copy
//     nums = other.nums;
//     head = rear = nullptr;
//     // Node *temp; // copy other's node
//     Node *p; // travellingly points to erver node of other
//     p = other.head;
//     while (p) {
//         if (!head) { // if there is no head
//             temp = new Node;
//             temp->item = p->item;
//             temp->next = nullptr;

//             head = rear = temp; // copy other's head
//         } else {
//             temp = new Node;
//             temp->item = p->item;
//             temp->next = nullptr;
            
//             rear->next = temp; // copy other's node
//             rear = temp; // keep rear points to the last one
//         }

//         p = p->next;
//     }
//     return *this;
// }

// std::ostream &operator<<(std::ostream &os, const Queue &q) {
//     if (q.isEmpty()) {
//         os << "queue is empty";
//         return os;
//     } else {
//         Queue::Node *p; // travellingly points to node of queue
//         p = q.head;

//         while (p) {
//             os << p->item << "  ";
//             p = p->next;
//         }

//         return os;
//     }
// }
```

7.两个ATM的模拟

（1）两个队列；

（2）新顾客哪个队列人数少排列在哪队；

（3）两个等待处理时间，两个ATM处理各自的顾客，只是在计数时计算两个队列的总人数和总服务人数

main.cpp

```
#include <iostream>
#include <cstdlib>  // for srand(), rand()
#include <ctime>    // for time()
#include "queue.h"

bool newcustomer(double x);

int main(void) {
    using std::cout;
    using std::cin;

    
    cout << "输入最大队列数目：";
    int qs;
    cin >> qs;
    Queue line1(qs);
    Queue line2(qs);

    cout << "输入模拟时间(小时)：";
    int hours;
    cin >> hours;
    const int MIN_PER_HOUR = 60;
    long cycle_limit =  MIN_PER_HOUR * hours;

    double average_wait_time = 0;
    while (average_wait_time <= 1) {
    // set up
        std::srand(time(0));

        cout << "输入一个小时的平均顾客到达数目：";
        double perhour;
        cin >> perhour;
        double min_per_cust = MIN_PER_HOUR / perhour;

        Item temp;          // new cuntomer data;
        long turnaways = 0; // turn away because of full queue
        long customers = 0; // number of customers joined the queue
        long served = 0;    // serverd numbers
        long sum_line = 0;  // cumulative line length
        long wait_time1 = 0; // time until handler is free
        long wait_time2 = 0; 
        long line_wait = 0; // cumulative time in line

    // start simulation
        for (int cycle = 0; cycle < cycle_limit; cycle++) {
            if (newcustomer(min_per_cust)) {
                if (line1.isFull() && line2.isFull()) {
                    turnaways++;
                } else if (line1.isFull()){
                    customers++;
                    temp.set(cycle); // set arrived time
                    line2.enqueue(temp); // enter queue2
                } else if (line2.isFull()) {
                    customers++;
                    temp.set(cycle); // set arrived time
                    line2.enqueue(temp); // enter queue1
                } else {
                    if (line1.queueCount() < line2.queueCount()) {
                        customers++;
                        temp.set(cycle); // set arrived time
                        line2.enqueue(temp); // enter queue1
                    } else {
                        customers++;
                        temp.set(cycle); // set arrived time
                        line2.enqueue(temp); // enter queue2
                    }
                }
            }

            if (wait_time1 <= 0 && !line1.isEmpty()) {
                line1.dequeue(temp);
                wait_time1 += temp.ptime();
                line_wait += cycle - temp.when();
                served++;
            }
            
            if (wait_time2 <= 0 && !line2.isEmpty()) {
                line2.dequeue(temp);
                wait_time2 += temp.ptime();
                line_wait += cycle - temp.when();
                served++;
            }


            if (wait_time1 > 0) wait_time1--;
            if (wait_time2 > 0) wait_time2--;
            sum_line += line1.queueCount();
            sum_line += line2.queueCount();
        }

    // report result
        if (customers > 0) {
            cout << "接待顾客数目：" << customers << '\n';
            cout << "服务顾客数目：" << served << '\n';
            cout << "因队列满而未接待数目：" << turnaways << '\n';
            cout << "平均每分钟队列长度：";
            cout << (double)line_wait / cycle_limit << '\n';
            average_wait_time = (double)line_wait / served;
            cout << "平均等待时间：" << average_wait_time << '\n';
        } else {
            cout << "No customers!\n";
        }


    } // end while
    return 0;
}

bool newcustomer(double x) {
    return (std::rand() * x / RAND_MAX) < 1;
}
```



# 第十三章

总代码行数：560行

1.派生类、虚函数、基类指针和引用

main.cpp

```
#include <iostream>
#include "cd.h"
#include "classic.h"

void Show(const Cd &cd);

int main(void) {
    using std::cout;
    using std::cin;

    Cd c1("Beatles", "Capitol", 14, 35.5);
    Classic c2("Pinao", "Alfred", "Philips", 2, 57.17);

    Cd *pcd = &c1;

    cout << "直接使用对象：\n";
    c1.Report();
    c2.Report();

    cout << "使用Cd类的指针：\n";
    pcd->Report();
    pcd = &c2;
    pcd->Report();

    cout << "调用一个形参为Cd类引用的函数：\n";
    Show(c1);
    Show(c2);

    cout << "测试Classic类的赋值运算符：\n";
    Classic copy;
    copy = c2;
    copy.Report();

    return 0;
}

void Show(const Cd &cd) {
    cd.Report();
}
```

cd.h

```
#ifndef CD_H_
#define CD_H_
#include <iostream>
#include <cstring>

// base class
class Cd {
private:
    enum {NAME_SIZE = 50, LABEL_SIZE = 20};
    char performer[NAME_SIZE];
    char label[LABEL_SIZE];
    int selections;
    double playtime;
public:
// constructor and destructor
    Cd(const char *s1, const char *s2, int n, double x);
    Cd();
    virtual ~Cd();
// other methods
    virtual void Report() const;

};

#endif
```

cd.cpp

```
#include "cd.h"

// constructor and destructor
    // default constructor
Cd::Cd() {
    performer[0] = label[0] = '\0';
    selections = 0;
    playtime = 0;
}

    // constructor
Cd::Cd(const char *s1, const char *s2, int n, double x) {
    int len1 = std::strlen(s1);
    if (len1 >= NAME_SIZE) {
        std::cout << "The length of performer's name cannot be more than"
                  << NAME_SIZE << ", ";
        std::cout << "the excess part is ignored.\n";
    }
    std::strncpy(performer, s1, NAME_SIZE - 1);

    int len2 = std::strlen(s2);
    if (len2 >= LABEL_SIZE) {
        std::cout << "The length of CD's label cannot be more than"
                  << LABEL_SIZE << ", ";
        std::cout << "the excess part is ignored.\n";
    }
    std::strncpy(label, s2, LABEL_SIZE - 1);

    selections = n;
    playtime = x;
}

    // destructor
Cd::~Cd() {
    // std::cout << "base class destructor\n";
}

// other methods
    // show info
void Cd::Report() const {
    using std::cout;
    if (!std::strcmp(performer, "")) {
        cout << "This CD isn't initialized.\n";
    } else {
        cout << "CD's name: " << performer << '\n'
             << "Label: " << label << '\n'
             << "Selections: " << selections << '\n'
             << "Playtime: " << playtime << '\n';
    } // end if
}


```

classic.h

```
#ifndef CLASSIC_H_
#define CLASSIC_H_
#include <cstring>
#include "cd.h"

// derived class
class Classic : public Cd {
private:
    // add new member data
    enum {WORK_SIZE = 20};
    char major_work[WORK_SIZE];
public:
// constructor and destructor
    Classic(const char *s1, const char *s2, const char *s3, int n, double x);
    Classic();
    ~Classic();
// other methods
    virtual void Report() const;
};

#endif
```

classic.cpp

```
#include "classic.h"

// constructor and destructor
    // constructor
Classic::Classic(const char *s1, const char *s2, const char *s3,
                 int n, double x)
    : Cd(s1, s2, n, x) {
    int len3 = std::strlen(s3);
    if (len3 >= WORK_SIZE) {
        std::cout << "The length of performer's name cannot be more than"
                  << WORK_SIZE << ", ";
        std::cout << "the excess part is ignored.\n";
    }
    std::strncpy(major_work, s3, WORK_SIZE - 1);
}

    // default constructor
Classic::Classic() : Cd() {
    major_work[0] = '\0';
}

    // destructor
Classic::~Classic() {
    // std::cout << "derived class destructor\n";
}

// other methods
void Classic::Report() const {
    Cd::Report();
    std::cout << "Major Work: " << major_work << '\n';
}
```

2.存在动态内存的派生类、复制构造函数（成员初始化列表调用基类复制构造函数）、赋值运算符（显式调用基类赋值运算符）：

main.cpp:

```
#include <iostream>
#include "cd.h"
#include "classic.h"

void Show(const Cd &cd);

int main(void) {
    using std::cout;
    using std::cin;

    Cd c1("Beatles", "Capitol", 14, 35.5);
    Classic c2("Pinao", "Alfred", "Philips", 2, 57.17);

    Cd *pcd = &c1;

    cout << "直接使用对象：\n";
    c1.Report();
    c2.Report();

    cout << "使用Cd类的指针：\n";
    pcd->Report();
    pcd = &c2;
    pcd->Report();

    cout << "调用一个形参为Cd类引用的函数：\n";
    Show(c1);
    Show(c2);

    cout << "测试Classic类的赋值运算符：\n";
    Classic copy;
    copy = c2;
    copy.Report();

    cout << "测试Classic类的复制构造函数：\n";
    Classic copy2 = c2;
    copy2.Report();

    return 0;
}

void Show(const Cd &cd) {
    cd.Report();
}
```

cd.h

```
#ifndef CD_H_
#define CD_H_
#include <iostream>
#include <cstring>

// base class
class Cd {
private:
    char *performer;
    char *label;
    int selections;
    double playtime;
public:
// constructor and destructor
    Cd(const char *s1, const char *s2, int n, double x);
    Cd();
    Cd(const Cd &other);
    virtual ~Cd();
// other methods
    virtual void Report() const;
// assignment operator
    Cd & operator=(const Cd &other);
};

#endif
```

cd.cpp

```
#include "cd.h"

// constructor and destructor
    // default constructor
Cd::Cd() {
    performer = label = nullptr;
    selections = 0;
    playtime = 0;
}

    // constructor
Cd::Cd(const char *s1, const char *s2, int n, double x) {
    int len1 = std::strlen(s1);
    performer = new char[len1 + 1];
    std::strcpy(performer, s1);

    int len2 = std::strlen(s2);
    label = new char[len2 + 1];
    std::strcpy(label, s2);

    selections = n;
    playtime = x;
}

    // copy constructor
Cd::Cd(const Cd &other) {
    performer = new char[std::strlen(other.performer) + 1];
    std::strcpy(performer, other.performer);

    label = new char[std::strlen(other.label) + 1];
    std::strcpy(label, other.label);

    selections = other.selections;
    playtime = other.playtime;

    std::cout << "Cd copy constructor" << std::endl;
}

    // destructor
Cd::~Cd() {
    delete[] performer;
    delete[] label;
}

// other methods
    // show info
void Cd::Report() const {
    using std::cout;
    cout << "CD's name: " << performer << '\n'
         << "Label: " << label << '\n'
         << "Selections: " << selections << '\n'
         << "Playtime: " << playtime << '\n';
}

// operator overloading
    // assignment operator
Cd & Cd::operator=(const Cd &other) {
    if (&other == this) return *this;
    delete[] performer;
    delete[] label;

    performer = new char[std::strlen(other.performer) + 1];
    std::strcpy(performer, other.performer);

    label = new char[std::strlen(other.label) + 1];
    std::strcpy(label, other.label);

    selections = other.selections;
    playtime = other.playtime;

    std::cout << "Cd assignment operator\n";
    return *this;
}
```

classic.h

```
#ifndef CLASSIC_H_
#define CLASSIC_H_
#include <cstring>
#include "cd.h"

// derived class
class Classic : public Cd {
private:
    // add new member data
    char *major_work;
public:
// constructor and destructor
    Classic(const char *s1, const char *s2, const char *s3, int n, double x);
    Classic();
    Classic(const Classic &other);
    ~Classic();
// other methods
    virtual void Report() const;
// operator overloading
    Classic &operator=(const Classic &other);
};

#endif
```

classic.cpp

```
#include "classic.h"

// constructor and destructor
    // constructor
Classic::Classic(const char *s1, const char *s2, const char *s3,
                 int n, double x)
    : Cd(s1, s2, n, x) {
    int len3 = std::strlen(s3);
    major_work = new char[len3 + 1];
    std::strcpy(major_work, s3);
}

    // default constructor
Classic::Classic() : Cd() {
    major_work = nullptr;
}

    // copy constructor
Classic::Classic(const Classic &other) : Cd(other) {
    major_work = new char[std::strlen(other.major_work) + 1];
    std::strcpy(major_work, other.major_work);

    std::cout << "Classic copy constructor" << std::endl;
}

    // destructor
Classic::~Classic() {
    // std::cout << "derived class destructor\n";
    delete[] major_work;
}

// other methods
void Classic::Report() const {
    Cd::Report();
    std::cout << "Major Work: " << major_work << '\n';
}

// operatoer overloading
    // assignment operator
Classic & Classic::operator=(const Classic &other) {
    if (&other == this) return *this;
    // call based class's assignment operator
    Cd::operator=(other); // *this == hs;
    delete[] major_work;

    major_work = new char[std::strlen(other.major_work) + 1];
    std::strcpy(major_work, other.major_work);

    std::cout << "Classic assignment operator\n";
    return *this;
}
```

3.抽象基类、虚函数、派生类（有无动态内存分配）是否需要重载赋值运算符和复制构造函数

main.cpp

```
#include <iostream>
#include "dma.h"


int main(void) {
    using std::cout;
    using std::cin;

    ABC *parr[3];

    // points to derived class1
    parr[0] = new baseDMA("baseDMA", 1);

    // points to derived class2
    parr[1] = new lacksDMA("lacksDMA", "s2forLacksDMA", 2);

    // points to derived class3
    parr[2] = new hasDMA("hasDMA", "DMAs2", 3);

    for (int i = 0; i < 3; i++) {
        parr[i]->View();
        delete parr[i];
    }
    

    return 0;
}

```

dma.h

```
#ifndef DMA_H_
#define DMA_H_
#include <iostream>
#include <cstring>

// abstract base class
class ABC {
private:
    char *label;
    int rating;
public:
// constructor and destructor
    ABC();
    ABC(const char *s, int n);
    ABC(const ABC &other);
    virtual ~ABC();
// other methods
    virtual void View() const = 0;
// operator overloading
    ABC &operator=(const ABC &other);
};

// derived class1
class baseDMA : public ABC {
public:
// constructor and destructor
    baseDMA();
    baseDMA(const char *s, int n);
    // baseDMA(const baseDMA &other); // no need
    ~baseDMA();
// other methods
    void View() const;
// operator overloading
    // baseDMA &operator=(const baseDMA &other); // no need
};

// derived class2
class lacksDMA : public ABC {
private:
    enum {COLOR_SIZE = 40};
    char color[COLOR_SIZE];
public:
// constructor and destructor
    lacksDMA();
    lacksDMA(const char *s1, const char *s2, int n);
    ~lacksDMA();
    // lacksDMA(const baseDMA &other); // no need
// other methods
    void View() const;
// operator overloading
    // lacksDMA &operator=(const lacksDMA &other); // no need
};

// derived class3
class hasDMA : public ABC {
private:
    char *style;
public:
// constructor and destructor
    hasDMA();
    hasDMA(const char *s1, const char *s2, int n);
    hasDMA(const hasDMA &other);
    ~hasDMA();
// other methods
    void View() const;
// operator overloadind
    hasDMA &operator=(const hasDMA &other);

};

#endif
```

dma.cpp

```
#include "DMA.h"


// abstract base class ABC
    // constructor and destructor
        // desfault constructor
ABC::ABC() {
    label = nullptr;
    rating = 0;
}
        // constructor
ABC::ABC(const char *s, int n) {
    label = new char[std::strlen(s) + 1];
    std::strcpy(label, s);

    rating = n;
}

        // copy constructor
ABC::ABC(const ABC& other) {
    label = new char[std::strlen(other.label) + 1];
    std::strcpy(label, other.label);

    rating = other.rating;
}
        // destructor
ABC::~ABC() {
    delete[] label;
}

    // other methods
void ABC::View() const {
    using std::cout;
    cout << "Label: " << label << '\n'
         << "Rating: " << rating << '\n';
}

    // operator overloading
        // assignment operator
ABC & ABC::operator=(const ABC& other) {
    if (&other == this) return *this;
    delete[] label;

    label = new char[std::strlen(other.label) + 1];
    rating = other.rating;

    return *this;
}

// derived class1 baseDMA
    // default constructor
baseDMA::baseDMA() : ABC() {

}

    // constructor
baseDMA::baseDMA(const char *s1, int n) : ABC(s1, n) {

}

    // destructor
baseDMA::~baseDMA() {

}

    // other methods
void baseDMA::View() const {
    ABC::View();
}

// derived class2 lacksDMA
    // constructor and destructor
lacksDMA::lacksDMA() : ABC() {
    color[0] = '\0';
}

lacksDMA::lacksDMA(const char *s1, const char *s2, int n) : ABC(s1, n) {
    int len = std::strlen(s2);
    if (len >= COLOR_SIZE) {
        std::cout << "The length of performer's name cannot be more than"
                  << COLOR_SIZE << ", ";
        std::cout << "the excess part is ignored.\n";
    }
    std::strncpy(color, s2, COLOR_SIZE - 1);
}

lacksDMA::~lacksDMA() {

}

void lacksDMA::View() const {
    ABC::View();
    std::cout << "Color: " << color << '\n';
}

// derived class3 hasDMA
    // construcor and destructor
hasDMA::hasDMA() : ABC() {
    style = nullptr;
}

hasDMA::hasDMA(const char *s1, const char *s2, int n) : ABC(s1, n) {
    style = new char[std::strlen(s2) + 1];
    std::strcpy(style, s2);
}

hasDMA::hasDMA(const hasDMA &other) : ABC(other) {
    style = new char[std::strlen(other.style) + 1];
    std::strcpy(style, other.style);
}

hasDMA::~hasDMA() {
    delete[] style;
}

void hasDMA::View() const {
    ABC::View();
    std::cout << "Style: " << style << '\n';
}

hasDMA & hasDMA::operator=(const hasDMA &other) {
    if (&other == this) return *this;
    ABC::operator=(other);
    delete[] style;

    style = new char[std::strlen(other.style) + 1];
    std::strcpy(style, other.style);

    return *this;
}
```

4.基类、派生类、为何不重载赋值运算符和友元函数



# 第十四章

总代码行数：1320行

1.组合、类中有pair、pair中有valarray，重点是构造函数

main.cpp

```
#include <iostream>
#include "wine.h"

int main(void) {
    using std::cout;
    using std::cin;
    
    cout << "请输入酒的名字：";
    char lab[50];
    cin.getline(lab, 50);
    cout << "请输入有几种年份：";
    int yrs;
    cin >> yrs;
    while (cin.get() != '\n') continue;

    Wine h(lab, yrs);
    h.GetBottles();
    h.Show();

    int YER = 3;
    int y[YER] = {1993, 1995, 1998};
    int b[YER] = {48, 60, 72};
    Wine m("Guing Grape Red", YER, y, b);
    m.Show();
    cout << "Total: " << m.Sum() << '\n';
    

    return 0;
}

```

pair.h

```
#ifndef PAIRS_H_
#define PAIRS_H_

template <class T1, class T2>
class Pair {
private:
    T1 a;
    T2 b;
public:
    Pair(T1 a, T2 b) : a(a), b(b) {}
    Pair() {}
    
    T1 & first();
    T2 & second();
    // for const instance
    T1 first() const { return a; }
    T2 second() const { return b; }
};

template <class T1, class T2>
T1 & Pair<T1, T2>::first() {
    return a;
}

template <class T1, class T2>
T2 & Pair<T1, T2>::second() {
    return b;
}

#endif
```

wine.h

```
#ifndef WINE_H_
#define WINE_H_
#include <iostream>
#include <valarray>
#include <string>
#include "pairs.h"
using std::string;
using std::valarray;

typedef valarray<int> ArrayInt;
typedef Pair<ArrayInt, ArrayInt> PairArray;

class Wine {
private:
    Wine();
    string name;
    PairArray pair;
    int nums_years;
public:
    Wine(const char *l, int y);
    Wine(const char *l, int y, const int yr[], const int bot[]);

    bool GetBottles();
    string & Label();
    string Label() const;
    int Sum() const;
    void Show() const;

};



#endif
```

wine.cpp

```
#include "wine.h"

Wine::Wine() {
    name = "\0";
    nums_years = 0;
}

Wine::Wine(const char *l, int y) : name(l), pair(ArrayInt(y), ArrayInt(y)) {
    nums_years = y;
}

Wine::Wine(const char *l, int y, const int yr[], const int bot[])
    : name(l), pair(ArrayInt(yr, y), ArrayInt(bot, y)) {
    nums_years = y;
}

bool Wine::GetBottles() {
    if (nums_years == 0) return false;

    int temp_year, temp_bot;
    using std::cout;
    using std::cin;
    for (int i = 0; i < nums_years; i++) {
        cout << "请输入第" << i + 1 << "个年份：";
        cin >> temp_year;
        while (cin.get() != '\n') continue;

        cout << "请输入" << temp_year << "年酒的瓶数：";
        cin >> temp_bot;
        while (cin.get() != '\n') continue;

        pair.first()[i] = temp_year;
        pair.second()[i] = temp_bot;
    }

    return true;
}

// which can achive and modify
string & Wine::Label() {
    return name;
}

// which only can achive a copy for the const instance
string Wine::Label() const {
    return name;
}

int Wine::Sum() const {
    int res = 0;
    for (int i = 0; i < nums_years; i++) {
        res += pair.second()[i];
    }

    return res;
}

void Wine::Show() const {
    using std::cout;
    cout << "Wine Name: " << name << '\n';
    cout << '\t' << "Year\tBottles\n";
    for (int i = 0; i < nums_years; i++) {
        cout << '\t' << pair.first()[i] << '\t' << pair.second()[i] << '\n';
    }
}
```

2.使用私有继承解决1，一是子对象没有显式名称，要初始化需要调用基类的构造函数，要访问需要强制类型转换；二是模板基类的派生类可以不是模板类；三是这继承的pair是一个显式实例化（使用ArrayInt）之后的模板类。

main.cpp无变化

pair.h无变化

wine.h

```
#ifndef WINE_H_
#define WINE_H_
#include <iostream>
#include <valarray>
#include <string>
#include "pairs.h"
using std::string;
using std::valarray;

typedef valarray<int> ArrayInt;
typedef Pair<ArrayInt, ArrayInt> PairArray;

class Wine : private PairArray, private string {
private:
    int nums_years;
public:
    Wine();
    Wine(const char *l, int y);
    Wine(const char *l, int y, const int yr[], const int bot[]);

    bool GetBottles();
    string & Label();
    string Label() const;
    int Sum() const;
    void Show() const;

};



#endif
```

wine.cpp

```
#include "wine.h"

Wine::Wine() { // call based classes' default constructor
    nums_years = 0;
}

Wine::Wine(const char *l, int y) : string(l), PairArray(ArrayInt(y), ArrayInt(y)) {
    nums_years = y;
}

Wine::Wine(const char *l, int y, const int yr[], const int bot[])
    : string(l), PairArray(ArrayInt(yr, y), ArrayInt(bot, y)) {
    nums_years = y;
}

bool Wine::GetBottles() {
    if (nums_years == 0) return false;

    int temp_year, temp_bot;
    using std::cout;
    using std::cin;
    for (int i = 0; i < nums_years; i++) {
        cout << "请输入第" << i + 1 << "个年份：";
        cin >> temp_year;
        while (cin.get() != '\n') continue;

        cout << "请输入" << temp_year << "年酒的瓶数：";
        cin >> temp_bot;
        while (cin.get() != '\n') continue;

        PairArray(*this).first()[i] = temp_year;
        PairArray(*this).second()[i] = temp_bot;
    }

    return true;
}

// which can achive and modify
string & Wine::Label() {
    return (string &)*this;
}

// which only can achive a copy for the const instance
string Wine::Label() const {
    return (string)*this;
}

int Wine::Sum() const {
    int res = 0;
    for (int i = 0; i < nums_years; i++) {
        res += PairArray(*this).second()[i];
    }

    return res;
}

void Wine::Show() const {
    using std::cout;
    cout << "Wine Name: " << (const string &)*this << '\n';
    cout << '\t' << "Year\tBottles\n";
    for (int i = 0; i < nums_years; i++) {
        cout << '\t' << PairArray(*this).first()[i] << '\t' << PairArray(*this).second()[i] << '\n';
    }
}
```

3.MI、队列类模板、重载运算符<<

更新：妈的，写了一天终于改正确了！920行代码。

明白了：模板类和友元、多重继承的虚基类、虚函数、友元如何实现多态

-------

关于MI：多重继承，虚基类如何使用，一是构造函数的使用，二是一些细节函数需要修改，比如set函数和show函数，这里我选择重载<<运算符，对于特定类测试均没有问题，但是毁在题目要求的是存储基类指针的队列，因此使用cout<<打印时只会调用基类的友元cout<<函数，这也反映了友元是不能被继承的，并且友元基本没有多态的可能，即友元是特定类的友元，不具有动态联编的可能。因此需要修改成使用show函数打印信息。

队列类模板：模板类、这里主要出的问题是模板类和友元函数（三种情况），以及友元函数如何访问模板类的成员（实例化之后才能访问）

一个失败的版本（失败在友元cout<<无法实现多态）

main.cpp

```
#include <iostream>
#include <cctype>
#include "queuetp.h"
#include "work.h"

int main(void) {
    using std::cout;
    using std::cin;
    using std::toupper;

    Queue<Worker *> q;
    char choice;
    Queue<Worker *> qarr[10];
    int count = 0;
    Worker *temp = nullptr;

    cout << "请选择入队(e)还是出队(d)：";
    while (cin.get(choice) && choice != '\n') {
        while (cin.get() != '\n') continue;

        if (toupper(choice) == 'E') {
            char cc;
            cout << "请选择(a)Waiter;(b)Singer;(c)SingingerWaiter: ";
            cin >> cc;
            while (cin.get() != '\n') continue;

            switch (cc) {
            case 'a':
                temp = new Waiter;
                break;
            case 'b':
                temp = new Singer;
                break;
            case 'c':
                temp = new SingingWaiter;
                break;
            default:
                cout << "输入不合法！\n";
                break;
            }
            if (!temp) break; // no instance
            temp->Set();

            if (q.Enqueue(temp)) {
                cout << "入队成功！\n";
                qarr[count++] = q;
            } else {
                cout << "队列满！入队失败！\n";
            }

        } else if (toupper(choice) == 'D') {
            if (q.Dequeue(temp)) {
                cout << "出队成功！出队元素为：\n";
                cout << *temp;

                // display history
                cout << "历史状态记录：\n";
                for (int i = 0; i < count; i++) {
                    cout << "---------------\n";
                    cout << qarr[i];
                }
                // delete
                delete temp;
                // clear history
                count = 0;

            } else {
                cout << "队列空！出队失败！\n";
            }


        } else {
            break;
        }

        cout << "请选择入队(e)还是出队(d)：";
    }

    // It is possible that the queue is not empty
    while (q.Dequeue(temp)) {
        delete temp;
    }


    return 0;
}

```

queue.h

```
#ifndef QUEUETP_H_
#define QUEUETP_H_
#include <iostream>
#include "work.h"

template <class T> class Queue;
template <typename T>
std::ostream & operator<<(std::ostream &os,const Queue<T> &other);

template <class T>
class Queue {
private:
    struct Node {
        T value;
        Node *next;
    };

    int size;   // size of queue
    int nums;   // number of Node
    Node *front;
    Node *rear;
public:
    Queue(int sz = 10);
    Queue(const Queue<T> &other);
    ~Queue();

    bool isEmpty() const;
    bool isFull() const;
    bool Enqueue(const T &item);
    bool Dequeue(T &item);

    Queue<T> & operator=(const Queue<T> &other);
    
    friend std::ostream & operator<<<>(std::ostream & os, const Queue<T> &other);
}; // end class declaration

template <class T>
Queue<T>::Queue(int sz) {
    size = sz;
    nums = 0;
    front = rear = nullptr;
}

template <class T>
Queue<T>::Queue(const Queue<T> &other) {
    size = other.size;
    nums = other.nums;
    front = rear = nullptr;

    Node *temp;
    Node *q = other.front; // travellingly points to Node of other
    while (!q) {
        temp = new Node;
        temp->value = q->value;
        temp->next = nullptr;

        if (!front) {
            front = rear = temp;
        } else {
            rear->next = temp;
            rear = temp; // keep rear points to the last one
        } // end if

        q = q->next;
    } // end while
}

template <class T>
Queue<T>::~Queue() {
    Node *temp;
    while (!front) {
        temp = front;
        front = front->next;
        
        delete temp;
    }
}

template <class T>
bool Queue<T>::isEmpty() const {
    return nums == 0;
}

template <class T>
bool Queue<T>::isFull() const {
    return nums == size;
}

template <class T>
bool Queue<T>::Enqueue(const T &item) {
    if (isFull()) return false;
    // create a new Node
    Node *temp = new Node;
    temp->value = item;
    temp->next = nullptr;

    if (!front) {
        front = rear = temp;
    } else {
        rear->next = temp; // enter queue
        rear = temp;
    }
    nums++;

    return true;
}

template <class T>
bool Queue<T>::Dequeue(T &item) {
    if (isEmpty()) return false;

    item = front->value;
    
    Node *temp = front;
    if (front->next == nullptr) {
        front = rear = nullptr;
    } else {
        front = front->next;
    }
    delete temp;
    nums--;

    return true;
}

template <class T>
Queue<T> & Queue<T>::operator=(const Queue<T> &other) {
    if (&other == this) return *this;
    Node *temp;
    while (front != nullptr) {
        temp = front;
        front = front->next;
        
        delete temp;
    }

    size = other.size;
    nums = other.nums;
    front = rear = nullptr;

    // Node *temp;
    Node *q = other.front; // travellingly points to Node of other
    while (q) {
        temp = new Node;
        temp->value = q->value;
        temp->next = nullptr;

        if (!front) {
            front = rear = temp;
        } else {
            rear->next = temp;
            rear = temp; // keep rear points to the last one
        } // end if

        q = q->next;
    } // end while

    return *this;
}

template <typename T>
std::ostream & operator<<(std::ostream &os, const Queue<T> &other) {
    if (other.isEmpty()) {
        std::cout << "queue is empty\n";
    } else {
        Queue<Worker *>::Node *temp; // travelingly points to Node of other
        temp = other.front;
        while (temp) {
            std::cout << *(temp->value);
            temp = temp->next;
        }
    }
    
    return os;
}

#endif
```

work.h

```
#ifndef WORKER_H_
#define WORKER_H_
#include <iostream>
#include <string>
using std::string;

// base class
class Worker {
private:
    string name;
    int id;
protected:
    virtual void Get();
public:
    Worker(string n = "None", int i = 0) : name(n), id(i) {}
    virtual ~Worker() = 0;

    virtual bool Set() = 0;
    void Show(std::ostream &os) const;
    friend std::ostream & operator<<(std::ostream &os, const Worker &w);
};

// derived class1
class Waiter : virtual public Worker {
private:
    int salary;
protected:
    virtual void Get();
    
public:
    Waiter(string n = "None", int i = 0, int s = 0)
        : Worker(n, i), salary(s) {};
    virtual ~Waiter();

    virtual bool Set();
    void Show(std::ostream &os) const;
    friend std::ostream & operator<<(std::ostream &os, const Waiter &w);

};

// derived class2
class Singer : virtual public Worker {
private:
    int voice;
protected:
    virtual void Get();
    
public:
    Singer(string n = "None", int i = 0, int v = 0) : Worker(n, i), voice(v) {}
    virtual ~Singer();

    virtual bool Set();
    void Show(std::ostream &os) const;
    friend std::ostream & operator<<(std::ostream &os, const Singer &s);
};

// derived derived class
class SingingWaiter : public Waiter, public Singer {
protected:
    void Get();
    
public:
    SingingWaiter(string n = "None", int i = 0, int s = 0, int v = 0)
        : Worker(n, i), Waiter(n, i, s), Singer(n, i, v) {}
    ~SingingWaiter();

    bool Set();
    void Show(std::ostream &os) const;
    friend std::ostream & operator<<(std::ostream &os, const SingingWaiter &s);
};


#endif
```

work.cpp

```
#include "work.h"

// base class
void Worker::Get() {
    using std::cout;
    using std::cin;
    getline(cin, name);
    cout << "请输入Worker的ID：";
    cin >> id;
    while (cin.get() != '\n') continue;
}

void Worker::Show(std::ostream &os) const {
    os << "Worker的名字：" << name << '\t'
       << "Worker的ID：" << id << '\n';
}

Worker::~Worker() {}

bool Worker::Set() {
    using std::cout;
    cout << "请输入Worker的名字：";
    Get();

    return true;
}

std::ostream & operator<<(std::ostream &os, const Worker &w) {
    w.Show(os);
    return os;
}

// derived class1
void Waiter::Get() {
    using std::cout;
    using std::cin;

    cout << "请输入Waiter的薪水：";
    cin >> salary;
    while (cin.get() != '\n') continue;
}

void Waiter::Show(std::ostream &os) const {
    os << "Waiter的薪水是：" << salary << '\n';
}

Waiter::~Waiter() {};

bool Waiter::Set() {
    using std::cout;

    cout << "请输入Waiter的名字：";
    Worker::Get();
    Get();

    return true;
}

std::ostream & operator<<(std::ostream &os, const Waiter &w) {
    os << (Worker &)w;
    w.Show(os);
    return os;
}

// derived class2
void Singer::Get() {
    using std::cout;
    using std::cin;

    cout << "请输入Singer的音量：";
    cin >> voice;
    while (cin.get() != '\n') continue;
}

void Singer::Show(std::ostream &os) const {
    os << "Singer的音量为：" << voice << '\n';
}

Singer::~Singer() { }

bool Singer::Set() {
    using std::cout;

    cout << "请输入Singer的名字：";
    Worker::Get();
    Get();

    return true;
}

std::ostream & operator<<(std::ostream &os, const Singer &s) {
    os << (Worker &)s;
    s.Show(os);
    return os;
}

// derived derived class
void SingingWaiter::Get() {

}

void SingingWaiter::Show(std::ostream &os) const {

}

SingingWaiter::~SingingWaiter() {}

bool SingingWaiter::Set() {
    using std::cout;

    cout << "请输入SingingWaiter的名字：";
    Worker::Get();
    Waiter::Get();
    Singer::Get();
    Get();
    
    return true;
}

std::ostream & operator<<(std::ostream &os, const SingingWaiter &s) {
    os << (Waiter &)s;
    ((Singer &)s).Show(os);
    s.Show(os);
    
    return os;
}
```

#### 打印结果

![image-20230322212438651](.\image-课后代码\14-1.png)

即只会打印基类能够显示的内容。

#### 成功的版本

使用友元实现多态：友元调用多态成员函数

比如我这里想用cout<<打印不同类型的对象，首先是使用多态实现一个Show函数，即使用通过基类指针调用Show来实现多态，然后在基类中声明友元函数cout<<，这个友元函数去调用show函数，因为是根据传入的参数基类指针，所以会调用相应对象的show函数。

总结来说就是在多态的基础上再加一层友元，从而实现友元的多态。

main.cpp

```
#include <iostream>
#include <cctype>
#include "queuetp.h"
#include "work.h"

int main(void) {
    using std::cout;
    using std::cin;
    using std::toupper;

    Queue<Worker *> q;
    char choice;
    Queue<Worker *> qarr[10];
    int count = 0;
    Worker *temp = nullptr;

    cout << "请选择入队(e)还是出队(d)：";
    while (cin.get(choice) && choice != '\n') {
        while (cin.get() != '\n') continue;

        if (toupper(choice) == 'E') {
            char cc;
            cout << "请选择(a)Waiter;(b)Singer;(c)SingingerWaiter: ";
            cin >> cc;
            while (cin.get() != '\n') continue;

            switch (cc) {
            case 'a':
                temp = new Waiter;
                break;
            case 'b':
                temp = new Singer;
                break;
            case 'c':
                temp = new SingingWaiter;
                break;
            default:
                cout << "输入不合法！\n";
                break;
            }
            if (!temp) break; // no instance
            temp->Set();

            if (q.Enqueue(temp)) {
                cout << "入队成功！\n";
                qarr[count++] = q;
            } else {
                cout << "队列满！入队失败！\n";
            }

        } else if (toupper(choice) == 'D') {
            if (q.Dequeue(temp)) {
                cout << "出队成功！出队元素为：\n";
                cout << *temp;

                // display history
                cout << "历史状态记录：\n";
                for (int i = 0; i < count; i++) {
                    cout << "---------------\n";
                    cout << qarr[i];
                }
                // delete
                delete temp;
                // clear history
                count = 0;

            } else {
                cout << "队列空！出队失败！\n";
            }


        } else {
            break;
        }

        cout << "请选择入队(e)还是出队(d)：";
    }

    // It is possible that the queue is not empty
    while (q.Dequeue(temp)) {
        delete temp;
    }


    return 0;
}


```

queuetp.h

```
#ifndef QUEUETP_H_
#define QUEUETP_H_
#include <iostream>
#include "work.h"

template <class T> class Queue;
template <typename T>
std::ostream & operator<<(std::ostream &os,const Queue<T> &other);

template <class T>
class Queue {
private:
    struct Node {
        T value;
        Node *next;
    };

    int size;   // size of queue
    int nums;   // number of Node
    Node *front;
    Node *rear;
public:
    Queue(int sz = 10);
    Queue(const Queue<T> &other);
    ~Queue();

    bool isEmpty() const;
    bool isFull() const;
    bool Enqueue(const T &item);
    bool Dequeue(T &item);

    Queue<T> & operator=(const Queue<T> &other);
    
    friend std::ostream & operator<<<>(std::ostream & os, const Queue<T> &other);
}; // end class declaration

template <class T>
Queue<T>::Queue(int sz) {
    size = sz;
    nums = 0;
    front = rear = nullptr;
}

template <class T>
Queue<T>::Queue(const Queue<T> &other) {
    size = other.size;
    nums = other.nums;
    front = rear = nullptr;

    Node *temp;
    Node *q = other.front; // travellingly points to Node of other
    while (!q) {
        temp = new Node;
        temp->value = q->value;
        temp->next = nullptr;

        if (!front) {
            front = rear = temp;
        } else {
            rear->next = temp;
            rear = temp; // keep rear points to the last one
        } // end if

        q = q->next;
    } // end while
}

template <class T>
Queue<T>::~Queue() {
    Node *temp;
    while (!front) {
        temp = front;
        front = front->next;
        
        delete temp;
    }
}

template <class T>
bool Queue<T>::isEmpty() const {
    return nums == 0;
}

template <class T>
bool Queue<T>::isFull() const {
    return nums == size;
}

template <class T>
bool Queue<T>::Enqueue(const T &item) {
    if (isFull()) return false;
    // create a new Node
    Node *temp = new Node;
    temp->value = item;
    temp->next = nullptr;

    if (!front) {
        front = rear = temp;
    } else {
        rear->next = temp; // enter queue
        rear = temp;
    }
    nums++;

    return true;
}

template <class T>
bool Queue<T>::Dequeue(T &item) {
    if (isEmpty()) return false;

    item = front->value;
    
    Node *temp = front;
    if (front->next == nullptr) {
        front = rear = nullptr;
    } else {
        front = front->next;
    }
    delete temp;
    nums--;

    return true;
}

template <class T>
Queue<T> & Queue<T>::operator=(const Queue<T> &other) {
    if (&other == this) return *this;
    Node *temp;
    while (front != nullptr) {
        temp = front;
        front = front->next;
        
        delete temp;
    }

    size = other.size;
    nums = other.nums;
    front = rear = nullptr;

    // Node *temp;
    Node *q = other.front; // travellingly points to Node of other
    while (q) {
        temp = new Node;
        temp->value = q->value;
        temp->next = nullptr;

        if (!front) {
            front = rear = temp;
        } else {
            rear->next = temp;
            rear = temp; // keep rear points to the last one
        } // end if

        q = q->next;
    } // end while

    return *this;
}

template <typename T>
std::ostream & operator<<(std::ostream &os, const Queue<T> &other) {
    if (other.isEmpty()) {
        std::cout << "queue is empty\n";
    } else {
        Queue<Worker *>::Node *temp; // travelingly points to Node of other
        temp = other.front;
        while (temp) {
            std::cout << *(temp->value);
            temp = temp->next;
        }
    }
    
    return os;
}

#endif
```

work.h

```
#ifndef WORKER_H_
#define WORKER_H_
#include <iostream>
#include <string>
using std::string;

// base class
class Worker {
private:
    string name;
    int id;
protected:
    virtual void Get();
    void Data(std::ostream &os) const;
public:
    Worker(string n = "None", int i = 0) : name(n), id(i) {}
    virtual ~Worker() = 0;

    virtual bool Set() = 0;
    virtual void Show(std::ostream &os) const;
    friend std::ostream & operator<<(std::ostream &os, const Worker &w);
};

// derived class1
class Waiter : virtual public Worker {
private:
    int salary;
protected:
    virtual void Get();
    void Data(std::ostream &os) const;
public:
    Waiter(string n = "None", int i = 0, int s = 0)
        : Worker(n, i), salary(s) {};
    virtual ~Waiter();

    virtual bool Set();
    virtual void Show(std::ostream &os) const;
    friend std::ostream & operator<<(std::ostream &os, const Waiter &w);

};

// derived class2
class Singer : virtual public Worker {
private:
    int voice;
protected:
    virtual void Get();
    void Data(std::ostream &os) const;
public:
    Singer(string n = "None", int i = 0, int v = 0) : Worker(n, i), voice(v) {}
    virtual ~Singer();

    virtual bool Set();
    virtual void Show(std::ostream &os) const;
    friend std::ostream & operator<<(std::ostream &os, const Singer &s);
};

// derived derived class
class SingingWaiter : public Waiter, public Singer {
protected:
    void Get();
    void Data(std::ostream &os) const;
public:
    SingingWaiter(string n = "None", int i = 0, int s = 0, int v = 0)
        : Worker(n, i), Waiter(n, i, s), Singer(n, i, v) {}
    ~SingingWaiter();

    bool Set();
    virtual void Show(std::ostream &os) const;
    friend std::ostream & operator<<(std::ostream &os, const SingingWaiter &s);
};


#endif
```

work.cpp

```
#include "work.h"

// base class
void Worker::Get() {
    using std::cout;
    using std::cin;
    getline(cin, name);
    cout << "请输入Worker的ID：";
    cin >> id;
    while (cin.get() != '\n') continue;
}

void Worker::Data(std::ostream &os) const {
    os << "Worker的名字：" << name << '\t'
       << "Worker的ID：" << id << '\n';
}

void Worker::Show(std::ostream &os) const {
    Data(os);
}

Worker::~Worker() {}

bool Worker::Set() {
    using std::cout;
    cout << "请输入Worker的名字：";
    Get();

    return true;
}

std::ostream & operator<<(std::ostream &os, const Worker &w) {
    w.Show(os);
    return os;
}

// derived class1
void Waiter::Get() {
    using std::cout;
    using std::cin;

    cout << "请输入Waiter的薪水：";
    cin >> salary;
    while (cin.get() != '\n') continue;
}

void Waiter::Data(std::ostream &os) const {
    os << "Waiter的薪水是：" << salary << '\n';
}

void Waiter::Show(std::ostream &os) const {
    Worker::Data(os);
    Data(os);
}

Waiter::~Waiter() {};

bool Waiter::Set() {
    using std::cout;

    cout << "请输入Waiter的名字：";
    Worker::Get();
    Get();

    return true;
}

std::ostream & operator<<(std::ostream &os, const Waiter &w) {
    w.Show(os);
    return os;
}

// derived class2
void Singer::Get() {
    using std::cout;
    using std::cin;

    cout << "请输入Singer的音量：";
    cin >> voice;
    while (cin.get() != '\n') continue;
}

void Singer::Data(std::ostream &os) const {
    os << "Singer的音量为：" << voice << '\n';
}

void Singer::Show(std::ostream &os) const {
    Worker::Data(os);
    Data(os);
}

Singer::~Singer() { }

bool Singer::Set() {
    using std::cout;

    cout << "请输入Singer的名字：";
    Worker::Get();
    Get();

    return true;
}

std::ostream & operator<<(std::ostream &os, const Singer &s) {
    s.Show(os);
    return os;
}

// derived derived class
void SingingWaiter::Get() {

}

void SingingWaiter::Data(std::ostream &os) const {

}

void SingingWaiter::Show(std::ostream &os) const {
    Worker::Data(os);
    Waiter::Data(os);
    Singer::Data(os);
    Data(os);
}

SingingWaiter::~SingingWaiter() {}

bool SingingWaiter::Set() {
    using std::cout;

    cout << "请输入SingingWaiter的名字：";
    Worker::Get();
    Waiter::Get();
    Singer::Get();
    Get();
    
    return true;
}

std::ostream & operator<<(std::ostream &os, const SingingWaiter &s) {
    s.Show(os);
    
    return os;
}
```

6.多继承的虚基类、虚基类的多继承情况在最底层如何避免重复打印祖先类的数据：这里给出的解决方案是：（菱形继承：一个祖父、两个父代、一个祖孙）祖父提供Show函数打印自己的成员数据；两个父代分别提供一个成员函数Draw返回（打印）自己独有的成员数据，然后Show函数调用祖父的Show函数以及自己的Draw函数；祖孙调用祖父的Show函数以及父类的Draw（两个就使用两种Draw）。模块化的思想，自己提供一个打印独属于自己的属性的接口函数。

上一题的解决思路也差不多，都是提供一个只打印自己属性的接口方法，然后当需要打印自己全部信息的时候，提供更高一层接口：调用父类和自己的接口方法，这个方法刚好可以使用protected，外部无法访问，只有类层次可以访问。这个“更高层次的接口”可以提供给外界。

main.cpp

```
#include <iostream>
#include "person.h"

int main(void) {
    using std::cout;
    using std::cin;

    BadDude b("Jack", "Martin", 2, 10);
    Person *p = &b;
    p->Show();

    return 0;
}


```

person.h

```
#ifndef PERSON_H_
#define PERSON_H_
#include <iostream>
#include <cstdlib> // for rand
#include <ctime>
#include <string>
using std::string;

// base class
class Person {
private:
    string firstname;
    string lastname;
public:
    Person(string fn = "None", string ln = "None")
        : firstname(fn), lastname(ln) {}
    virtual ~Person() = 0;

    virtual void Show() const = 0;
};


// derived class
class Gunslinger : virtual public Person {
private:
    double time_gun;
    int nick;
public:
    Gunslinger(string fn = "None", string ln = "None", double tg = 0, int nk = 0);
    virtual ~Gunslinger() {}

    virtual int Draw() const;
    virtual void Show() const;

};

// derived class2
class PorkerPlayer : virtual public Person {
public:
    PorkerPlayer(string fn = "None", string ln = "None") : Person(fn, ln) {}
    virtual ~PorkerPlayer() {}

    virtual int Draw() const;
    virtual void Show() const;

};

// derived derived class
class BadDude : public Gunslinger, public PorkerPlayer {
public:
    BadDude(string fn = "None", string ln = "None", double tg = 0, int nk = 0)
        : Person(fn, ln), Gunslinger(fn, ln, tg, nk), PorkerPlayer(fn, ln) {}
    ~BadDude() {}

    int GDraw() const;
    int CDraw() const;
    void Show() const;

};

#endif
```

person.cpp

```
#include "person.h"

// base class 
Person::~Person() {}

void Person::Show() const {
    std::cout << firstname << "\t" << lastname << '\n';
}

// derived class1
Gunslinger::Gunslinger(string fn, string ln, double tg, int nk)
    : Person(fn, ln), time_gun(tg), nick(nk) {}

int Gunslinger::Draw() const {
    return time_gun;
}

void Gunslinger::Show() const {
    Person::Show();
    std::cout << "拔枪时间为：" << Draw() << '\n';
    std::cout << "枪划痕数目：" << nick << '\n';
}

// derived class2
int PorkerPlayer::Draw() const {
    srand(time(0));
    return rand() % 52 + 1;
}

void PorkerPlayer::Show() const {
    Person::Show();
    std::cout << "下一张牌是：" << Draw();
}

// derived derived class
int BadDude::GDraw() const {
    return Gunslinger::Draw();
}

int BadDude::CDraw() const {
    return PorkerPlayer::Draw();
}

void BadDude::Show() const {
    Person::Show();
    std::cout << "拔枪时间为：" << GDraw() << '\n';
    std::cout << "下一张牌是：" << CDraw() << '\n';
}

```

7.多重继承的虚基类、接收父对象的构造函数、

（1）为什么没有定义赋值运算符：因为没有用到动态分配内存空间。

（2）为什么讲SetAll和SetAll定义成虚的：因为想要使用抽象基类的指针或引用使用派生类对象并选择正确的对象方法。

（3）为什么要将Abcstr_emp类定义成虚基类：因为有一个祖孙类是由两个Abcstr_emp的子类派生而来的，为了避免祖孙类中有两个Abcstr_emp类组件部分。

（4）为什么HighFink类没有数据部分：因为它的成员数据部分在两个父类中。

（5）为什么只需要一个operator<<版本：因为完成虚函数之后，只需使用基类的引用或指针就可以完成对于子对象的指向。传递给operator<<的只需要是基类的指针或引用即可。

（6）如果用下面代码替换程序结尾部分，将会发生什么情况：

![image-20230323150812476](.\image-课后代码\14-2.png)

只会调用基类的ShowAll函数，即不会打印属于子类的数据部分，因为不会动态选择子类的ShowAll方法。

main.cpp

```
#include <iostream>
#include "emp.h"

int main(void) {
    using std::cout;
    using std::cin;

    HighFink h;
    Abcstr_emp *p = &h;
    p->SetAll();
    p->ShowAll();

    cout << *p;


    return 0;
}


```

emp.h

```
#ifndef EMP_H_
#define EMP_H_
#include <iostream>
#include <string>

class Abcstr_emp {
private:
    std::string fname;
    std::string lname;
    std::string job;
public:
    Abcstr_emp();
    Abcstr_emp(const std::string &fn, const std::string &ln, const std::string &j);
    virtual ~Abcstr_emp() = 0;

    virtual void ShowAll() const;
    virtual void SetAll();

    friend std::ostream &operator<<(std::ostream &os, const Abcstr_emp &e);
};

// Employee derived from Abcstr_emp
class Employee : public Abcstr_emp {
public:
    Employee() : Abcstr_emp() {}
    Employee(const std::string &fn, const std::string &ln, const std::string &j)
        : Abcstr_emp(fn, ln, j) {}
    ~Employee() {}

    virtual void ShowAll() const;
    virtual void SetAll();
};

// Manager derived from Abcstr_emp
class Manager : virtual public Abcstr_emp {
private:
    int inchargeof;
protected:
    int InChargeOf() const {return inchargeof;}
    int & InChargeOf() {return inchargeof;}
public:
    Manager() {}
    Manager(const std::string &fn, const std::string &ln, const std::string &j,
            int ico = 0) : Abcstr_emp(fn, ln, j), inchargeof(ico) {}
    virtual ~Manager() {}

    virtual void ShowAll() const;
    virtual void SetAll();

};

// Fink derived from Abcstr_emp
class Fink : virtual public Abcstr_emp {
private:
    std::string reportsto;
protected:
    const std::string ReportsTo() const {return reportsto;}
    std::string & ReportsTo() {return reportsto;}
public:
    Fink() {}
    Fink(const std::string &fn, const std::string &ln, const std::string &j,
         const std::string &re) : Abcstr_emp(fn, ln, j), reportsto(re) {}
    
    virtual ~Fink() {}

    virtual void ShowAll() const;
    virtual void SetAll();

};

// HighFink derived from Manager and Fink
class HighFink : public Fink, public Manager {
public:
    HighFink() {}
    HighFink(const std::string &fn, const std::string &ln,
             const std::string &j, const std::string &re, int i)
        : Abcstr_emp(fn, ln, j), Manager(fn, ln, j, i), Fink(fn, ln, j, re) {}
    
    ~HighFink() {};

    void ShowAll() const;
    void SetAll();
};

#endif
```

emp.cpp

```
#include "emp.h"

// Abcstr_emp
Abcstr_emp::Abcstr_emp() {
    fname = lname = job = "";
}

Abcstr_emp::Abcstr_emp(const std::string &fn, const std::string &ln,
                       const std::string &j)
    : fname(fn), lname(ln), job(j) {}

Abcstr_emp::~Abcstr_emp() {}

void Abcstr_emp::ShowAll() const {
    std::cout << fname << ' ' << lname << "\t: " << job << '\n';
}

void Abcstr_emp::SetAll() {
    using std::cout;
    using std::cin;
    cout << "请输入姓氏：";
    getline(cin, fname);
    cout << "请输入名字：";
    getline(cin, lname);
    cout << "请输入职业：";
    getline(cin, job);
}

std::ostream &operator<<(std::ostream &os, const Abcstr_emp &e) {
    e.ShowAll();
    return os;
}

// Employee derived from Abcstr_emp
void Employee::ShowAll() const {
    Abcstr_emp::ShowAll();
}

void Employee::SetAll() {
    Abcstr_emp::SetAll();
}

// Manager derived from Abcstr_emp
void Manager::ShowAll() const {
    Abcstr_emp::ShowAll();
    std::cout << "管理员工数目：" << InChargeOf() << '\n';
}

void Manager::SetAll() {
    Abcstr_emp::SetAll();
    std::cout << "请输入管理员工数目：";
    std::cin >> InChargeOf();
    while (std::cin.get() != '\n') continue;
}

// Fink derived from Abcstr_emp
void Fink::ShowAll() const {
    Abcstr_emp::ShowAll();
    std::cout << "这个讨厌鬼向\"" << ReportsTo() << "\"报告\n";
}

void Fink::SetAll() {
    Abcstr_emp::SetAll();
    std::cout << "请输入这个讨厌鬼向谁报告：";
    getline(std::cin, ReportsTo());
}

// HighFink derived from Manager and Fink
void HighFink::ShowAll() const {
    Abcstr_emp::ShowAll();
    std::cout << "管理员工数目：" << InChargeOf() << '\n';
    std::cout << "这个讨厌鬼向\"" << ReportsTo() << "\"报告\n";
}
    
void HighFink::SetAll() {
    Abcstr_emp::SetAll();
    std::cout << "请输入管理员工数目：";
    std::cin >> InChargeOf();
    while (std::cin.get() != '\n') continue;
    std::cout << "请输入这个讨厌鬼向谁报告：";
    getline(std::cin, ReportsTo());
}
```



# 总结

总代码行数：3300行左右

这几章都是关于类部分的知识，从类的基础知识、运算符重载、复制构造函数和赋值运算符对于动态内存的管理、友元函数、构造函数和转换函数对于类型转换的管理、继承基础知识、虚函数和基类指针或引用实现多态、抽象基类、继承与动态内存管理、包含和私有继承实现has-关系、多重继承和虚基类、类模板和友元等。

除了基础知识的学习，重点应该是：

1.动态内存管理；

2.虚函数和多态；

3.多重继承和虚基类；

4.类模板和友元。

难点是：1.如何在多重继承和虚基类中完成多态，这就需要每个类在设计时向类层次中（protected）提供一个修改和访问”独属于自己的“成员数据的方法，然后在公开接口中实现诸如ShowAll和SetAll的接口，这些接口都是虚函数，这样外部调用这些虚函数时就可以实现多态调用。

总的来说就是两个层次：protected层次的模块化、public层次的虚拟化（多态），就可以实现菱形关系中的多态。

2.是否需要复制构造函数和赋值运算符取决于类成员中是否用到了动态内存管理，主要是防止复制时的浅拷贝情况。

3.类模板和友元主要分成三种情况去考虑，应该把友元函数当作模板考虑清楚，（1）对于特定实例化类模板的友元函数（非模板函数）；（2）受到类模板的模板参数约束的友元模板函数；（3）友元模板函数的模板参数与类模板的模板参数无关。







