# 第十五章

总代码行数：250行

1.友元类

main.cpp

```
#include <iostream>
#include "remotetv.h"

int main(void) {
    Remote r;
    r.ShowMode();

    Tv t;
    t.ChangeRemoteMode(r);
    r.ShowMode();

    return 0;
}
```

remotetv.h

```
#ifndef REMOTETV_H_
#define REMOTETV_H_
#include <iostream>

class Tv;
class Remote {
friend class Tv;
public:
    enum MODE {normal, interactive};
private:
    MODE mode;
public:
    Remote(MODE m = normal) : mode(m) {}

    void ShowMode();

};

class Tv {
friend class Remote;
public:

    void ChangeRemoteMode(Remote &r);

};

#endif
```

remotetv.cpp

```
#include "remotetv.h"

// 
void Remote::ShowMode() {
    if (mode) {
        std::cout << "遥控器的状态是互动模式。\n";
    } else {
        std::cout << "遥控器的状态是常规模式。\n";
    }
    
}

void Tv::ChangeRemoteMode(Remote &r) {
    r.mode == Remote::normal ? r.mode = Remote::interactive : r.mode = Remote::normal;
}
```

2.j从标准异常派生自己的异常类：

main.cpp

```
#include <iostream>
#include <cmath>
#include <exception>
#include "myerror.h"

class Test {
public:
    int a;
    Test(int x) : a(x) {}
};

double hmean(double a, double b) {
    if (a == -b) {
        throw bad_hmean("bad argument to hmean()");
    } else {
        return 2.0 * a * b / (a + b); 
    }
}

double gmean(double a, double b) {
    if (a < 0 || b < 0) {
        throw bad_gmean("bad argument to gmean()");
    } else {
        return std::sqrt(a * b);
    }
}

int main(void) {
    try {
        std::cout << hmean(2, -2) << '\n';
    } 
    catch (bad_hmean &e) {
        std::cout << e.what();
    }

    try {
        std::cout << gmean(-1, -1) << '\n';
    } catch (std::logic_error & l) {
        std::cout << l.what();
    }

    return 0;
}

```

myerror.h

```
#ifndef MYERROR_H_
#define MYERROR_H_
#include <stdexcept>
#include <string>

class bad_hmean :public std::logic_error {
public:
    explicit bad_hmean(const std::string &msg) : std::logic_error(msg) {}
};

class bad_gmean : public std::logic_error {
public:
    explicit bad_gmean(const std::string &msg) : std::logic_error(msg) {}
};


#endif
```

3.异常类：接受参数

main.cpp

```
#include <iostream>
#include "myerror.h"

double hmean(double a, double b) {
    if (a == -b) {
        throw bad_hmean(a, b);
    } else {
        return 2.0 * a * b / (a + b); 
    }
}


int main(void) {
    try {
        std::cout << hmean(2, -2) << '\n';
    } 
    catch (MyError &e) {
        std::cout << e;
    }

    return 0;
}


```

myerror.h

```
#ifndef MYERROR_H_
#define MYERROR_H_
#include <iostream>
#include <stdexcept>
#include <string>

class MyError : public std::logic_error {
private:
    double a;
    double b;
public:
    MyError(double x, double y) : std::logic_error("none"), a(x), b(y) {}
    virtual ~MyError() {}

    virtual void Show(std::ostream &os) const {
        os << "bad arguments: " << a << ", " << b;
    }
    friend std::ostream &operator<<(std::ostream &os, MyError &my) {
        my.Show(os);
        return os;
    }

};

class bad_hmean : public MyError {
public:
    explicit bad_hmean(double x, double y) : MyError(x, y) {}
    
    virtual void Show(std::ostream &os) const {
        MyError::Show(os);
        os << " to hmean()";
    }
};



#endif
```

4.异常处理的多态（即一个异常继承另一个异常）、RTTI处理虚函数（即尝试进行动态指针类型转换，转成哪种类型就用哪种类型的成员函数）

main.cpp

```
#include <iostream>
#include "sales.h"


int main(void) {
using std::cout;
    using std::cin;
    using std::endl;

    double vals1[12] =
    {
        1220, 1100, 1122, 2212, 1232, 2334,
        2884, 2393, 3302, 2922, 3002, 3544
    };

    double vals2[12] =
    {
        12, 11, 22, 21, 32, 34,
        28, 29, 33, 29, 32, 35
    };

    Sales sales1(2011, vals1, 12);
    LabeledSales sales2("Blogstar",2012, vals2, 12 );

    cout << "First try block:\n";
    try
    {
        int i;
        cout << "Year = " << sales1.Year() << endl;
        for (i = 0; i < 12; ++i)
        {

            cout << sales1[i] << ' ';
            if (i % 6 == 5)
                cout << endl;
        }
        cout << "Year = " << sales2.Year() << endl;
        cout << "Label = " << sales2.Label() << endl;
        for (i = 0; i <= 12; ++i)
        {

            cout << sales2[i] << ' ';
            if (i % 6 == 5)
                cout << endl;
        }
        cout << "End of try block 1.\n";
   }
   catch(std::logic_error & bad)
   {    
        Sales::bad_index *s;
        LabeledSales::nbad_index *l;
        if (s = dynamic_cast<Sales::bad_index *>(&bad)) {
            cout << (*s).what();
            cout << "bad index: " << (*s).bi_val() << endl;
        } else {
            l = dynamic_cast<LabeledSales::nbad_index *>(&bad);
            cout << (*l).what();
            cout << "Company: " << (*l).label_val() << endl;
            cout << "bad index: " << (*l).bi_val() << endl;
        }
        
   }
   cout << "\nNext try block:\n";
   try
    {
        sales2[2] = 37.5;
        sales1[20] = 23345;
        cout << "End of try block 2.\n";
   }
   catch(std::logic_error & bad)
   {    
        Sales::bad_index *s;
        LabeledSales::nbad_index *l;
        if (s = dynamic_cast<Sales::bad_index *>(&bad)) {
            cout << (*s).what();
            cout << "bad index: " << (*s).bi_val() << endl;
        } else {
            l = dynamic_cast<LabeledSales::nbad_index *>(&bad);
            cout << (*l).what();
            cout << "Company: " << (*l).label_val() << endl;
            cout << "bad index: " << (*l).bi_val() << endl;
        }
        
   }
   cout << "done\n";
    return 0;
}


```



# 第十六章

总代码行数：700行

1.回文（不考虑标点、大小写）：

mian.cpp

```
#include <iostream> // for cout
#include <string>

bool isPalindrome(std::string str);

int main(void) {
    using std::cout;
    using std::cin;
    using std::string;

    string str;
    cout << "请输入一个字符串：";
    while (cin >> str and str != "q") {
        if (isPalindrome(str)) {
            cout << str << "是回文。\n";
        } else {
            cout << str << "不是回文\n";
        }

        cout << "请输入一个字符串：";
    }

    return 0;
}

bool isPalindrome(std::string str) {
    return str.compare(std::string(str.rbegin(), str.rend())) == 0;
}
```

2.回文（考虑标点、大写小写）

main.cpp

```
#include <iostream> // for cout
#include <cctype>   // for isalpha
#include <string>

bool isPalindrome(std::string str);
std::string format(std::string str);

int main(void) {
    using std::cout;
    using std::cin;
    using std::string;

    string str;
    cout << "请输入一个字符串：";
    while (getline(cin, str) && str != "") {
        string temp = format(str);
        if (isPalindrome(temp)) {
            cout << str << "是回文。\n";
        } else {
            cout << str << "不是回文\n";
        }

        cout << "请输入一个字符串：";
    }

    return 0;
}

bool isPalindrome(std::string str) {
    return str.compare(std::string(str.rbegin(), str.rend())) == 0;
}

std::string format(std::string str) {
    int i = 0;
    std::string res;
    while (str[i]) {
        if (std::isalpha(str[i])) {
            res.push_back(std::tolower(str[i]));
        }
        i++;
    }

    return res;
}
```

3.从文件读取string、string的一些方法的使用：find、string::npos等

main.cpp

```
#include <iostream> // for cout
#include <fstream>
#include <string>
#include <vector>
#include <ctime>
#include <cstdlib>

int main(void) {
    using std::cout;
    using std::cin;
    using std::ifstream;
    using std::string;
    using std::vector;
    using std::srand;
    using std::rand;
    using std::time;

    const char *filename = "./test.txt";
    ifstream fin;
    fin.open(filename);

    vector<string> wordlist;
    string word;
    while (fin >> word) {
        wordlist.push_back(word);
    }

    fin.close();

    // choose a random word
    srand(time(0));
    string target_word = wordlist[rand() % wordlist.size()];
    string target_copy = string(target_word.length(), '-');
    string guessed_chars;
    int guess_time = 7;
    char guess_char;
    cout << "You have " << guess_time << " times left to guess, "
         << "please input a char: ";
    while (guess_time > 0 && cin.get(guess_char) && guess_char != '\n') {
        while (cin.get() != '\n') continue;
        // handle guessed char
        if (target_copy.find(guess_char) != string::npos ||
            guessed_chars.find(guess_char) != string::npos) {
            cout << "You already guessed \"" << guess_char << "\"\n";
            cout << "Please reinput: ";
            continue;
        }

        int loc = target_word.find(guess_char);
        if (loc != string::npos) {
            target_copy[loc] = guess_char;
            guessed_chars.push_back(guess_char);
            while ((loc = target_word.find(guess_char, loc + 1)) != string::npos) {
                target_copy[loc] = guess_char;
            }

            cout << "guess right! ";
            cout << "your guess is " << target_copy << '\n';
        } else {
            guessed_chars.push_back(guess_char);
            guess_time--;
            cout << "guess wrong! ";
            cout << "your guess is " << target_copy << '\n';
        }

        if (target_copy != target_word) {
            cout << "You have " << guess_time << " times left to guess, ";
            if (guess_time == 0) break;
            else cout << "please input a char: ";
        } else break;

        
    }

    if (guess_time > 0) {
        cout << "Congratulations!\n";
    } else {
        cout << "The right answer is " << target_word << '\n';
    }

    return 0;
}

```

4.统计数组中不重复元素个数

第一种：使用set容器：

main.cpp

```
#include <iostream> // for cout
#include <set>
#include <algorithm>

int reduce(long ar[], int n);
void show(long x);
int main(void) {
    using std::cout;

    long arr[] = {0l, 1l, 2l, 3l, 0l, 5l, 5l};
    int nums = reduce(arr, 7);
    cout << "一共有" << nums << "个不重复元素\n";

    return 0;
}

int reduce(long ar[], int n) {
    using std::set;
    using std::for_each;
    // using std::unique;

    set<long> s(ar, ar + n);
    for_each(s.begin(), s.end(), show);
    std::cout << '\n';

    return s.size();
}

void show(long x) {
    std::cout << x << '\t';
}

```

第二种：使用unique：直接在数组上使用unique，因为数组相当于指针，而指针是迭代器

main.cpp

```
#include <iostream> // for cout
#include <set>
#include <vector>
#include <algorithm>

int reduce(long ar[], int n);
void show(long x);
int main(void) {
    using std::cout;

    long arr[] = {0l, 1l, 2l, 3l, 0l, 5l, 5l};
    int nums = reduce(arr, 7);
    cout << "一共有" << nums << "个不重复元素\n";

    return 0;
}

int reduce(long ar[], int n) {
    using std::for_each;
    using std::unique;

    
    std::sort(ar, ar + n);
    long *last = unique(ar, ar + n);
    for_each(ar, last, show);
    std::cout << '\n';


    return last - ar;
}

void show(long x) {
    std::cout << x << '\t';
}

```

5.第4题的模板，使用long和string

main.cpp

```
#include <iostream> // for cout
#include <vector>
#include <string>
#include <algorithm>

template <typename T>
int reduce(T ar[], int n);

// void show(long x);
void show(std::string s);
int main(void) {
    using std::cout;
    using std::string;

    // cout << "----使用long数组----\n";
    // long arr[] = {0l, 1l, 2l, 3l, 0l, 5l, 5l};
    // int nums = reduce(arr, 7);
    // cout << "一共有" << nums << "个不重复元素\n";

    
    cout << "----使用string数组----\n";
    string arr_str[] = {"name", "value", "sexy", "value", "sunny", "name"};
    int nums = reduce(arr_str, 6);
    cout << "一共有" << nums << "个不重复元素\n";

    return 0;
}

template <typename T>
int reduce(T ar[], int n) {
    using std::for_each;
    using std::unique;

    
    std::sort(ar, ar + n);
    T *last = unique(ar, ar + n);
    for_each(ar, last, show);
    std::cout << '\n';


    return last - ar;
}


void show(std::string s) {
    std::cout << s << '\t';
}

```

6.使用STL的队列完成第十二章的ATM队列模拟，就是换了个queue

main.cpp

```
#include <iostream>
#include <cstdlib>  // for srand(), rand()
#include <ctime>    // for time()
#include "customer.h"
#include <queue>

bool newcustomer(double x);

int main(void) {
    using std::cout;
    using std::cin;
    using std::queue;

    
    cout << "输入最大队列数目：";
    int qs_max;
    cin >> qs_max;
    queue<Customer> que;

    cout << "输入模拟时间(小时)：";
    int hours;
    cin >> hours;
    const int MIN_PER_HOUR = 60;
    long cycle_limit =  MIN_PER_HOUR * hours;

    double average_wait_time = 0;
    while (average_wait_time <= 1) {
    // set up
        std::srand(time(0));

        cout << "输入一个小时的平均顾客到达数目：";
        double perhour;
        cin >> perhour;
        double min_per_cust = MIN_PER_HOUR / perhour;

        Customer temp;          // new cuntomer data;
        long turnaways = 0; // turn away because of full queue
        long customers = 0; // number of customers joined the queue
        long served = 0;    // serverd numbers
        long sum_line = 0;  // cumulative line length
        long wait_time = 0; // time until handler is free
        long line_wait = 0; // cumulative time in line

    // start simulation
        for (int cycle = 0; cycle < cycle_limit; cycle++) {
            if (newcustomer(min_per_cust)) {
                if (que.size() == qs_max) {
                    turnaways++;
                } else {
                    customers++;
                    temp.set(cycle); // set arrived time
                    que.push(temp); // enter queue

                }
            }

            if (wait_time <= 0 && !que.empty()) {
                temp = Customer(que.front());
                que.pop();
                wait_time += temp.ptime();
                line_wait += cycle - temp.when();
                served++;
            }

            if (wait_time > 0) wait_time--;
            sum_line += que.size();
        }

    // report result
        if (customers > 0) {
            cout << "接待顾客数目：" << customers << '\n';
            cout << "服务顾客数目：" << served << '\n';
            cout << "因队列满而未接待数目：" << turnaways << '\n';
            cout << "平均每分钟队列长度：";
            cout << (double)line_wait / cycle_limit << '\n';
            average_wait_time = (double)line_wait / served;
            cout << "平均等待时间：" << average_wait_time << '\n';
        } else {
            cout << "No customers!\n";
        }


    } // end while
    return 0;
}

bool newcustomer(double x) {
    return (std::rand() * x / RAND_MAX) < 1;
}
```

customer.h

```
#ifndef CUSTOMER_H_
#define CUSTOMER_H_
#include <cstdlib>

class Customer {
private:
    long arrived_time;
    int processing_time;
public:
    Customer() {arrived_time = processing_time = 0;}
    void set(long when) {
        processing_time = std::rand() % 3 + 1;
        arrived_time = when;
    }
    long when() {return arrived_time;}
    int ptime() {return processing_time;}

};

// void Customer::set(long when) {
//     processing_time = std::rand() % 3 + 1;
//     arrived_time = when;
// }

#endif
```

7.vector：可以进vector赋值（把一个容器赋给另一个容器）、random_shuffle

从nums个数种选择n个数：

main.cpp

```
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> Lotto(int nums, int n);
void show(int x);
int main(void) {
    using std::for_each;
    using std::cout;

    auto winner = Lotto(51, 6);
    for_each(winner.begin(), winner.end(), show);

    return 0;
}

std::vector<int> Lotto(int nums, int n) {
    using std::vector;
    using std::random_shuffle;
    vector<int> v;
    for (int i = 0; i < nums; i++) {
        v.push_back(i + 1);
    }
    
    random_shuffle(v.begin(), v.end());

    return vector<int>(v.begin(), v.begin() + n);
}

void show(int x) {
    std::cout << x << '\t';
}
```

8.使用vector、sort算法、合并两个vector并删除重复元素

main.cpp

```
#include <iostream>
#include "invite.h"

int main(void) {
    Invite it;
    vector<string> A, B, C;

    it.input("Mat", A);
    it.show(A);
    
    it.input("Pat", B);
    it.show(B);

    C = it.merge(A, B);
    it.show(C);
    
    return 0;
}

```

invite.h

```
#ifndef INVITE_H_
#define INVITE_H_
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using std::vector;
using std::string;
using std::cin;
using std::cout;
using std::sort;
using std::unique;


class Invite {
protected:
    bool cmp(const string &a, const string &b);
public:
    // no explicit constructor and destructor
    bool input(const string &name, vector<string> &list);
    bool show(vector<string> &list);
    vector<string> merge(const vector<string> &listA, const vector<string> &listB);
};

#endif
```

invite.cpp

```
#include "invite.h"

bool Invite::cmp(const string &a, const string &b) {
    if (a.compare(b) < 0) return true;
    else return false;
}

bool Invite::input(const string &name, vector<string> &list) {
    cout << name << ", please input your friends: ";
    string temp;
    cin.clear();
    while (cin >> temp) {
        list.push_back(temp);
    }

    return true;
}

bool Invite::show(vector<string> &list) {
    sort(list.begin(), list.end());
    for (auto str : list) {
        cout << str << ' ';
    }
    cout << '\n';
    return true;
}

vector<string> Invite::merge(const vector<string> &listA, const vector<string> &listB) {
    vector<string> listC(listA.begin(), listA.end());
    listC.insert(listC.end(), listB.begin(), listB.end());

    sort(listC.begin(), listC.end());
    auto last = unique(listC.begin(), listC.end());
    listC.erase(last, listC.end());

    return listC;
}
```

9.比较vector和list的排序时间，通常做法是将list复制到vector中进行排序，然后再将结果返回list。

证明在顺序存储结构中排序速度远远小于在链式存储中排序。并且将链式存储先复制到顺序存储再排序最后复制到链式存储中的时间不会比在顺序存储中消耗太多时间。

mian.cpp

```
#include <iostream>
#include "compareVandL.h"

int main(void) {
    CompareVandL c(10000000);
        
    cout << c.timeSortV() << '\n';
    cout << c.timeSortL() << '\n';
    cout << c.timeVL() << '\n';
    
    return 0;
}
```

compareVandL.h

```
#ifndef COMPAREVANDL_H_
#define COMPAREVANDL_H_
#include <iostream>
#include <vector>   // for vector
#include <list>     // for list
#include <algorithm>    // for copy(), sort()
#include <ctime>    //for clock(), clock_t, 
#include <cstdlib>  // for rand()

using std::vector;
using std::list;
using std::sort;
using std::copy;
using std::clock;
using std::clock_t;
using std::rand;
using std::cout;

class CompareVandL {
private:
    vector<int> vi0;
    vector<int> vi;
    list<int> li;
public:
    CompareVandL(int n);
    bool show() const;

    double timeSortV();
    double timeSortL();
    double timeVL();
};


#endif
```

compareVandL.cpp

```
#include "compareVandL.h"


CompareVandL::CompareVandL(int n) {
    //randomly generate n numbers
    // srand(time(0));
    for (int i = 0; i < n; i++) {
        vi0.push_back(rand());
    }
    vi.resize(n);
    copy(vi0.begin(), vi0.end(), vi.begin());
    li.resize(n);
    copy(vi0.begin(), vi0.end(), li.begin());
}

bool CompareVandL::show() const {
    for (auto x : vi) cout << x << ' ';
    return true;
}

double CompareVandL::timeSortV() {
    clock_t start = clock();
    sort(vi.begin(), vi.end());
    clock_t end = clock();

    return double(end - start) / CLOCKS_PER_SEC;
}

double CompareVandL::timeSortL() {
    clock_t start = clock();
    li.sort();
    clock_t end = clock();

    return double(end - start) / CLOCKS_PER_SEC;
}

double CompareVandL::timeVL() {
    copy(vi0.begin(), vi0.end(), li.begin());
    clock_t start = clock();
    copy(li.begin(), li.end(), vi.begin());
    sort(vi.begin(), vi.end());
    copy(vi.begin(), vi.end(), li.begin());
    clock_t end = clock();

    return double(end - start) / CLOCKS_PER_SEC;
}


```

10.vector存储shared_ptr智能指针、对指针指向的内容进行排序

（1）非智能指针虽然vector也可以存，但是vector只会管理指针变量的内存，不会管理指针指向的内存，这就意味着必须手动为指针指向的空间进行分配和回收；

使用智能指针的话就无需对指针指向的空间进行回收，当智能指针过期时就会自动释放指向的内存。（类的优势：有开始有终止）。

（2）关于sort排序，没有比较函数符时，需要自己定义比较函数符，比如这里比较两个指针指向的内容。

（3）注意STL算法的函数符有参数要求，而类的成员函数会默认多一个参数：this。

（4）逐渐使用类的概念：一个问题解决方案的就是一个类的实例

main.cpp

```
#include "books.h"

int main(void) {
    BooksSort b;
    b.input();
    b.show();
    
    return 0;
}
```

books.h

```
#ifndef BOOKS_H_
#define BOOKS_H_
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <algorithm>

using std::vector;
using std::string;
using std::shared_ptr;
using std::for_each;
using std::sort;



class BooksSort {
private:
    enum SortType {TITLE, RATING, PRICE};
    struct Review {
        string title;
        int rating;
        double price;
    };
    vector<shared_ptr<Review>> books;
    vector<shared_ptr<Review>> books_copy;
protected:
    void menu() const;
    bool input_review(shared_ptr<Review> &review_ptr);
    bool sort_by(SortType type);
    static bool format_data(shared_ptr<Review> review_ptr);
    // compare two reviews by SortType, for example: title, rating, price...
    static bool cmp_shared_ptr_title(shared_ptr<Review> &a, shared_ptr<Review> &b);
    static bool cmp_shared_ptr_rating(shared_ptr<Review> &a, shared_ptr<Review> &b);
    static bool cmp_shared_ptr_price(shared_ptr<Review> &a, shared_ptr<Review> &b);
public:
    // no explicit constructor and destructor
    bool input();   // input books
    bool show();

};


#endif
```

books.cpp

```
#include "books.h"

void BooksSort::menu() const {
    using std::cout;
    cout << "Please choose sort by which order: \n";
    cout << "a)orginal\t\t\tb)title\n";
    cout << "c)rating ascending\t\td)rating decending\n";
    cout << "e)price ascending\t\tf)price decending\n";
    cout << "q)quit\n";
}

bool BooksSort::input_review(shared_ptr<Review> &review_ptr) {
    using std::cout;
    using std::cin;
    using std::getline;

    review_ptr = shared_ptr<Review>(new Review);

    cout << "Please input title(quit to quit): \n";
    getline(cin, review_ptr->title);
    if (review_ptr->title == "quit") return false;

    cout << "Please input book rating: ";
    cin >> review_ptr->rating;
    // get rid of the rest of input line
    while (cin.get() != '\n') continue;

    cout << "Please input book price: ";
    cin >> review_ptr->price;
    while (cin.get() != '\n') continue;

    return true;
}

bool BooksSort::format_data(shared_ptr<Review> review_ptr) {
    using std::cout;
    cout << review_ptr->rating << "\t\t"
         << review_ptr->price << "\t\t"
         << review_ptr->title << '\n';
    return true;
}

bool BooksSort::cmp_shared_ptr_title(shared_ptr<Review> &a, shared_ptr<Review> &b) {
    return a->title < b->title;
}

bool BooksSort::cmp_shared_ptr_rating(shared_ptr<Review> &a, shared_ptr<Review> &b) {
    return a->rating < b->rating;
}

bool BooksSort::cmp_shared_ptr_price(shared_ptr<Review> &a, shared_ptr<Review> &b) {
    return a->price < b->price;
}

bool BooksSort::sort_by(SortType type) {
    books_copy = books;
    if (type == TITLE) {
        sort(books_copy.begin(), books_copy.end(), cmp_shared_ptr_title);
    } else if (type == RATING) {
        sort(books_copy.begin(), books_copy.end(), cmp_shared_ptr_rating);
    } else {
        sort(books_copy.begin(), books_copy.end(), cmp_shared_ptr_price);
    }
    
    return true;
}

bool BooksSort::input() {
    using std::cout;

    shared_ptr<Review> review_ptr;
    while (input_review(review_ptr)) {
        books.push_back(review_ptr);
    }
    cout << "Thanks for input! You have input " << books.size() << " books.\n";
    return true;
}

bool BooksSort::show() {
    using std::cout;
    using std::cin;
    menu();
    char choice;
    cin.get(choice);
    while (cin.get() != '\n') continue;

    while (choice != 'q' && choice != 'Q') {

        while (choice == '\n') {
            menu();
            cin.get(choice);
        }

        switch (choice) {
        case 'A':
        case 'a':
            cout << "------Original order-----\n";
            cout << "rating\t\tprice\t\ttitle\n";
            for_each(books.begin(), books.end(), format_data);
            // format_data(*(books.begin()));
            break;
        case 'B':
        case 'b':
            cout << "------Order by title------\n";
            sort_by(TITLE);
            for_each(books_copy.begin(), books_copy.end(), format_data);
            break;
        case 'C':
        case 'c':
            cout << "------Order by rating(ascending)------\n";
            sort_by(RATING);
            for_each(books_copy.begin(), books_copy.end(), format_data);
            break;
        case 'D':
        case 'd':
            cout << "------Order by rating(decending)------\n";
            sort_by(RATING);
            for_each(books_copy.rbegin(), books_copy.rend(), format_data);
            break;
        case 'E':
        case 'e':
            cout << "------Order by price(ascending)------\n";
            sort_by(PRICE);
            for_each(books_copy.begin(), books_copy.end(), format_data);
            break;
        case 'F':
        case 'f':
            cout << "------Order by price(decending)------\n";
            sort_by(PRICE);
            for_each(books_copy.rbegin(), books_copy.rend(), format_data);
            break;
        default:
            cout << "Invalid choice!\n";
            break;
        } // end switch

        menu();
        cin.get(choice);
        while (cin.get() != '\n') continue;
    } // end while
    
    cout << "Done!\n";
    return true;
}

```



# 第十七章

总代码行数:680行

1.熟悉peek、get、putback函数

main.cpp

```
#include <iostream>


int main(void) {
    using std::cout;
    using std::cin;
    
    char ch;
    int count = 0;
    while (cin.peek() != '$') {
        cin.get(ch);
        count++;
    }
    cout << "一共输入了" << count << "个字符\n";


    return 0;
}
```

main.cpp

```
#include <iostream>


int main(void) {
    using std::cout;
    using std::cin;
    
    char ch;
    int count = 0;
    while (cin.get(ch) && ch != '$') {
        count++;
    }
    
    cout << "一共输入了" << count << "个字符\n";


    return 0;
}
```

2.重定向输出到文件

windows下： 1>test.txt 其中1代表标准输出流，2代表标准错误流，具体还需再看。

main.cpp

```
#include <iostream>


int main(void) {
    using std::cout;
    using std::cin;
    
    char ch;
    while (cin.get(ch))
        cout << ch;
    
    // if (cin.eof()) cout << "eof\n";

    return 0;
}
```

main.exe 1>test.txt

3.使用命令行把一个文件的内容复制到另一个文件中，主要是命令行参数的传递，即:

code.cpp

```
#include <iostream>
#include <fstream>


int main(int argc, char **argv) {
    using std::cout;
    using std::ofstream;
    using std::ifstream;

    if (argc == 1) {
        cout << "There is no argv!";
    } else {
        ifstream fin(argv[1]);  // open input file
        ofstream fout(argv[2]); // open output file

        if (!fin.is_open() && !fout.is_open()) {
            cout << "Error: Could not open file!";
        };

        char ch;
        while (fin.get(ch)) {
            fout << ch;
        }

        fin.close();
        fout.close();
    }


    return 0;
}
```

```
code.exe test.txt test2.txt
```

4.合并两个文件、文件尾

main.cpp

```
#include <iostream>
#include "copy2.h"

int main() {
    Copy2 c("test2.txt", "test1.txt");
    c.Merge("outfile.txt");

    return 0;
}
```

copy2.h

```
#ifndef COPY_H_
#define COPY_H_
#include <string>
#include <fstream>

class Copy2 {
private:
    std::string file1;
    std::string file2;
public:
    Copy2(const std::string &f1, const std::string &f2) : file1(f1), file2(f2) {}

    bool Merge(const std::string &outfile);

};

bool Copy2::Merge(const std::string &outfile) {
    using std::ofstream;
    using std::ifstream;

    ifstream fin1(file1);
    ifstream fin2(file2);
    ofstream fout(outfile);

    std::string line1;
    std::string line2;

    getline(fin1, line1);
    getline(fin2, line2);
    while (fin1 && fin2) {
        fout << line1 << ' ' << line2;

        // if there is another line
        if (getline(fin1, line1) && getline(fin2, line2))
            fout << '\n';
    }

    // if fin1 is not done
    if (fin1) {
        fout << '\n' << line1;
    }

    // if fin2 is not done
    if (fin2) {
        getline(fin2, line2);
        fout << '\n' << line2;
    }

    fin1.close();
    fin2.close();
    fout.close();
    return true;
}


#endif
```

5.写入和读取二进制文件

main.cpp

```
#include "fri.h"

int main() {
    FRI f;
    f.r();

    return 0;
}

```

fri.h

```
#include "fri.h"

int main() {
    FRI f;
    f.r();

    return 0;
}

```

fir.cpp

```
#include "fri.h"

FRI::FRI() {
    using std::cout;
    using std::cin;
    using std::ofstream;
    using std::string;
    using std::ios_base;

    string temp;
    char delim[] = "\n";

    ofstream fout1("mat.dat", ios_base::out | ios_base::binary);
    for (int i = 0; i < 5; i++) {
        cout << "请输入Mat的第" << i + 1 << "个朋友的姓名：";
        getline(cin, temp);
        
        // write to file
        fout1.write(temp.c_str(), temp.length());
        fout1.write(delim, 1);
    }
    fout1.close();

    ofstream fout2("pat.dat", ios_base::out | ios_base::binary);
    for (int i = 0; i < 3; i++) {
        cout << "请输入Pat的第" << i + 1 << "个朋友的姓名：";
        getline(cin, temp);
        
        // write to file

        fout2.write(temp.c_str(), temp.length());
        fout2.write(delim, 1);
    }
    fout2.close();
    cout << "write done!\n";
}

bool FRI::r() {
    using std::string;
    using std::vector;
    using std::ifstream;
    using std::ios_base;
    using std::sort;
    using std::unique;
    using std::cout;

    
    
    char *ch = new char;
    // read first file
    ifstream fin1("mat.dat", ios_base::in | ios_base::binary);

    while (!fin1.eof()) {
        string temp;
        while (fin1.read(ch, 1) && *ch != '\n') {
            temp += *ch;
        }
        // one line for one name
        if (temp.size() > 0) {
            temp += '\0';
            all.push_back(temp);
        }
    }
    fin1.close();

    // read second file
    ifstream fin2("pat.dat", ios_base::in | ios_base::binary);

    while (!fin2.eof()) {
        string temp;
        while (fin2.read(ch, 1) && *ch != '\n') {
            temp += *ch;
        }
        // one line for one name
        if (temp.size() > 0) {
            temp += '\0';
            all.push_back(temp);
        }
;
    }
    fin2.close();
    delete ch;

    // clear same elements
    sort(all.begin(), all.end());
    auto last = unique(all.begin(), all.end());
    all.erase(last, all.end());
    for (auto x : all) cout << x << ' ';
    return true;
}
```

6.多重继承下的对象写入文件，以固定格式读取对象，为什么不能直接用write写成二进制文件：

main.cpp

```
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <typeinfo>
#include "work.h"

void discard_rest_of_line(void) noexcept;
int main(void) {
    using std::cout;
    using std::cin;
    using std::ofstream;
    using std::ifstream;
    using std::exit;
    using std::ios_base;

    // show initial contents
    ifstream fin0;
    fin0.open("test.txt");
    if (fin0.is_open()) {
        cout << "-----原始数据内容为：-----\n";
        int flag;
        fin0 >> flag;
        Worker *p;
        while (!fin0.eof()) {
            switch (flag) {
            case 0:
                break;
            case 1:
                p = new Waiter;
                break;
            case 2:
                p = new Singer;
                break;
            case 3:
                p = new SingingWaiter;
                break;
            default:
                cout << "ERROR: Unknown flag!\n";
                exit(EXIT_FAILURE);
            }
            if (flag == 0) {
                break;
            }

            p->Set(fin0);
            cout << *p;

            fin0 >> flag;
        }

        delete p;
        fin0.close();
    }

    // input new contents
    char choice;
    Worker *temp = nullptr;

    cout << "-----请选择是否添加新内容，添加(y)还是退出(n)：-----";
    while (cin.get(choice) && choice != '\n' && choice != 'n') {
        discard_rest_of_line();

        temp = nullptr;
        // choice type and create instance
        char cc;
        cout << "请选择(a)Waiter;(b)Singer;(c)SingingerWaiter: ";
        cin >> cc;
        discard_rest_of_line();

        switch (cc) {
        case 'a':
            temp = new Waiter;
            break;
        case 'b':
            temp = new Singer;
            break;
        case 'c':
            temp = new SingingWaiter;
            break;
        default:
            cout << "输入不合法！\n";
            break;
        }
        if (!temp) break; // no instance

        temp->Set();

        cout << "您输入的是：\n";
        cout << *temp;

        // append to file
        ofstream fout("test.txt", ios_base::out | ios_base::app);
        // RTTI
        if (typeid(*temp) == typeid(Waiter)) {
            fout << 1;
        } else if (typeid(*temp) == typeid(Singer)) {
            fout << 2;
        } else if (typeid(*temp) == typeid(SingingWaiter)) {
            fout << 3;
        }
        fout << *temp;
        fout.close();

        delete temp;
        cout << "请选择继续(y)还是退出(n)：";
    }
    cout << "Done!\n";

    return 0;
}

void discard_rest_of_line(void) noexcept {
    while (std::cin.get() != '\n') continue;
}

```

work.h

```
#ifndef WORKER_H_
#define WORKER_H_
#include <iostream>
#include <string>
#include <cstring>
using std::string;
using std::strlen;

// base class
class Worker {
private:
    string name;
    int id;
protected:
    virtual void Get();
    virtual void Get(std::istream &is);
    void Data(std::ostream &os) const;
public:
    Worker(string n = "None", int i = 0) : name(n), id(i) {}
    virtual ~Worker() = 0;

    virtual bool Set() = 0;
    virtual bool Set(std::istream &is) = 0;
    virtual void Show(std::ostream &os) const;
    friend std::ostream & operator<<(std::ostream &os, const Worker &w);
};

// derived class1
class Waiter : virtual public Worker {
private:
    int salary;
protected:
    virtual void Get();
    virtual void Get(std::istream &is);
    void Data(std::ostream &os) const;
public:
    Waiter(string n = "None", int i = 0, int s = 0)
        : Worker(n, i), salary(s) {};
    virtual ~Waiter();

    virtual bool Set();
    virtual bool Set(std::istream &is);
    virtual void Show(std::ostream &os) const;
    friend std::ostream & operator<<(std::ostream &os, const Waiter &w);

};

// derived class2
class Singer : virtual public Worker {
private:
    int voice;
protected:
    virtual void Get();
    virtual void Get(std::istream &is);
    void Data(std::ostream &os) const;
public:
    Singer(string n = "None", int i = 0, int v = 0) : Worker(n, i), voice(v) {}
    virtual ~Singer();

    virtual bool Set();
    virtual bool Set(std::istream &is);
    virtual void Show(std::ostream &os) const;
    friend std::ostream & operator<<(std::ostream &os, const Singer &s);
};

// derived derived class
class SingingWaiter : public Waiter, public Singer {
protected:
    void Get();
    void Get(std::istream &is);
    void Data(std::ostream &os) const;
public:
    SingingWaiter(string n = "None", int i = 0, int s = 0, int v = 0)
        : Worker(n, i), Waiter(n, i, s), Singer(n, i, v) {}
    ~SingingWaiter();

    bool Set();
    bool Set(std::istream &is);
    virtual void Show(std::ostream &os) const;
    friend std::ostream & operator<<(std::ostream &os, const SingingWaiter &s);
};


#endif
```

work.cpp

```
#include "work.h"

// base class
void Worker::Get() {
    using std::cout;
    using std::cin;
    getline(cin, name);
    cout << "请输入Worker的ID：";
    cin >> id;
    while (cin.get() != '\n') continue;
}

void Worker::Get(std::istream &is) {
    is.ignore(strlen("Worker的名字：")) >> name;
    is.ignore(strlen("\n"));
    is.ignore(strlen("Worker的ID：")) >> id;
}

void Worker::Data(std::ostream &os) const {
    os << "Worker的名字：" << name << '\n'
       << "Worker的ID：" << id << '\n';
}

void Worker::Show(std::ostream &os) const {
    Data(os);
}

Worker::~Worker() {}

bool Worker::Set() {
    using std::cout;
    cout << "请输入Worker的名字：";
    Get();

    return true;
}

bool Worker::Set(std::istream &is) {
    Get(is);
    return true;
}

std::ostream & operator<<(std::ostream &os, const Worker &w) {
    w.Show(os);
    return os;
}

// derived class1
void Waiter::Get() {
    using std::cout;
    using std::cin;

    cout << "请输入Waiter的薪水：";
    cin >> salary;
    while (cin.get() != '\n') continue;
}

void Waiter::Get(std::istream &is) {
    is.ignore(strlen("\n"));
    is.ignore(strlen("Waiter的薪水是：")) >> salary;
}

void Waiter::Data(std::ostream &os) const {
    os << "Waiter的薪水是：" << salary << '\n';
}

void Waiter::Show(std::ostream &os) const {
    Worker::Data(os);
    Data(os);
}

Waiter::~Waiter() {};

bool Waiter::Set() {
    using std::cout;

    cout << "请输入Waiter的名字：";
    Worker::Get();
    Get();

    return true;
}

bool Waiter::Set(std::istream &is) {
    Worker::Get(is);
    Get(is);
    return true;
}

std::ostream & operator<<(std::ostream &os, const Waiter &w) {
    w.Show(os);
    return os;
}

// derived class2
void Singer::Get() {
    using std::cout;
    using std::cin;

    cout << "请输入Singer的音量：";
    cin >> voice;
    while (cin.get() != '\n') continue;
}

void Singer::Get(std::istream &is) {
    is.ignore(strlen("\n"));
    is.ignore(strlen("Singer的音量为：")) >> voice;
}

void Singer::Data(std::ostream &os) const {
    os << "Singer的音量为：" << voice << '\n';
}

void Singer::Show(std::ostream &os) const {
    Worker::Data(os);
    Data(os);
}

Singer::~Singer() { }

bool Singer::Set() {
    using std::cout;

    cout << "请输入Singer的名字：";
    Worker::Get();
    Get();

    return true;
}

bool Singer::Set(std::istream &is) {
    Worker::Get(is);
    Get(is);
    return true;
}

std::ostream & operator<<(std::ostream &os, const Singer &s) {
    s.Show(os);
    return os;
}

// derived derived class
void SingingWaiter::Get() {

}

void SingingWaiter::Get(std::istream &is) {

}

void SingingWaiter::Data(std::ostream &os) const {

}

void SingingWaiter::Show(std::ostream &os) const {
    Worker::Data(os);
    Waiter::Data(os);
    Singer::Data(os);
    Data(os);
}

SingingWaiter::~SingingWaiter() {}

bool SingingWaiter::Set() {
    using std::cout;

    cout << "请输入SingingWaiter的名字：";
    Worker::Get();
    Waiter::Get();
    Singer::Get();
    Get();
    
    return true;
}

bool SingingWaiter::Set(std::istream &is) {
    Worker::Get(is);
    Waiter::Get(is);
    Singer::Get(is);
    Get(is);
    
    return true;
}

std::ostream & operator<<(std::ostream &os, const SingingWaiter &s) {
    s.Show(os);
    
    return os;
}
```

7.把字符串写入二进制文件、字符串string的成员函数data返回一个指向字符数组（注意不是字符串的概念）的指针、

main.cpp

```
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include <cstdlib>
#include "store.h"


void showstr(const std::string &str);
void Getstrs(std::ifstream &fin, std::vector<std::string> &vs);
int main(void) {
    using std::cout;
    using std::cin;
    using std::ofstream;
    using std::ifstream;
    using std::ios_base;
    using std::string;
    using std::vector;
    using std::for_each;
    using std::exit;

    vector<string> vostr;
    string temp;

    // get input
    cout << "输入字符串：（空行停止输出）\n";
    while (getline(cin, temp) && temp.size() > 0) {
        vostr.push_back(temp);
    }
    cout << "您的输入是：\n";
    for_each(vostr.begin(), vostr.end(), showstr);

    // store in file
    ofstream fout("string.dat", ios_base::out | ios_base::binary);
    for_each(vostr.begin(), vostr.end(), Store(fout));
    fout.close();

    // recover from file
    ifstream fin("string.dat", ios_base::in | ios_base::binary);
    if (!fin.is_open()) {
        cout << "Can't open string.dat!\n";
        exit(EXIT_FAILURE);
    }
    vector<string> vistr;
    Getstrs(fin, vistr);
    cout << "从文件中恢复出的字符串为：\n";
    for_each(vistr.begin(), vistr.end(), showstr);



    return 0;
}

void showstr(const std::string &str) {
    std::cout << str << '\n';
}

void Getstrs(std::ifstream &fin, std::vector<std::string> &vs) {
    std::string temp;
    std::size_t len;

    while (fin.read((char *)&len, sizeof(std::size_t)) && len > 0) {
        char ch;
        temp = "";
        for (int i = 0; i < len; i++) {
            if (fin.read(&ch, 1)) {
                temp += ch;
            } else break;

        } // end for
        if (fin) vs.push_back(temp);
    }
}
```

strore.h

```
#ifndef STORE_H_
#define STORE_H_
#include <string>
#include <fstream>


class Store {
private:
    std::ostream &os;
public:
    Store(std::ostream &o) : os(o) {}

    void operator()(const std::string &str);
};

void Store::operator()(const std::string &str) {
    std::size_t len = str.length();
    os.write((char*)&len, sizeof(std::size_t));
    os.write(str.data(), len);
}

#endif
```



# 第十八章

总代码行数：90行

1.初始化列表模板

```
#include <iostream>
#include <initializer_list>

template <typename T>
T average_list(std::initializer_list<T> i);

int main(void) {
    using namespace std;

    auto q = average_list({15.4, 10.7, 9.0});
    cout << q << endl;

    cout << average_list({20, 30, 19, 15, 45, 38}) << endl;

    auto ad = average_list<double>({'A', 70, 65.33});
    cout << ad << endl;

    return 0;
}

template <typename T>
T average_list(std::initializer_list<T> i) {
    // decltype(*i.begin()) s = 0;
    auto s = *i.begin();
    for (auto x : i) s += x;
    s -= *i.begin();

    return s / i.size();
}
```

2.移动构造函数和移动赋值运算符

```
#include <iostream>
#include <utility>
#include "cpmv.h"
using namespace std;

int main(void) {
    {
    cout << "----测试默认构造函数----\n";
    Cpmv c1;
    c1.Display();

    cout << "----测试常规构造函数----\n";
    Cpmv c2("demo2", "zzzzdemo2");
    c2.Display();

    cout << "----测试复制构造函数----\n";
    Cpmv c3 = c2;
    c3.Display();

    cout << "----测试加法和移动构造函数----\n";
    // Cpmv c4 = move(c2 + c3);
    Cpmv c4 = c2 + c3;
    c4.Display();

    cout << "----测试赋值运算符---\n";
    c3 = c4;
    c3.Display();

    cout << "----测试移动赋值运算符----\n";
    c3 = c2 + c4;
    c3.Display();
    }

    return 0;
}

```

3.可变参数模板函数：

```
#include <iostream>
using namespace std;

long double sum_value() { return 0.0; }

template <typename T, typename... Args>
long double sum_value(const T &value, const Args&... args) {
    return value + sum_value(args...);
}


int main(void) {
    cout << sum_value(19.0, 22, 'A') << endl;

    cout << sum_value('!', 22.4, 'A') << endl;

    return 0;
}

```

4.lambda函数：

```
#include <iostream>
#include <list>
#include <algorithm>
using namespace std;

int main(void) {
    list<int> l{1,2,3,4,5,6,7,8,9};
    for_each(l.begin(), l.end(), [](int i){std::cout << i << ' ';});

    return 0;
}

```



# 总结

总代码行数：1600行

这几章的内容分别是：

友元类、友元成员函数、异常、RTTI、类型转换运算符

STL标准库：迭代器、容器、函数对象、适配器、算法、智能指针

标准输入输出、文件输入输出

C++11新内容：移动语义、lambda函数、适配器、可变参数模板函数









