# 第一章 让自己习惯C++

## 条款1：C++是一个语言联邦

C++可以看作是由四个次语言组成的集合体：

- C：基本的C语言，区块、语句、预处理、内置数据类型、数组、指针等。
- Object-Oriented C++：C with Classes诉求的，即封装、继承、多态、动态绑定等等。
- Template C++：泛型编程部分，即编程不受限于某种具体类型。
- STL：标准库，包含容器、迭代器、算法、函数对象等等。

当从某一个次语言切换到另一个时，会导致高效编程的规则发生变化。例如对于内置类型而言按值传递要比引用传递高效，但是对于用户自定义类型（class）而言由于构造函数和析构函数的存在，const-引用传递更好。 对于泛型编程中的模板尤为如此。

## 条款2：尽量以const、enum、inline替换#define

### 对于单纯的常量，最好以const或者enum替换#define

**#define MAX 100**

即C语言中常用于定义常量的形式。这种形式缺点：

- **编译器无法检查是否错误。**#define与预处理命令，是由预处理器来完成的，不是由编译器完成的。具体的工作就是在编译之前把文件中所有的MAX替换成100，因此MAX从未进入编译器的记号表。因此如果出问题的话编译器报错找不到是MAX的错误，最多找到是100的错误；

- **影响目标代码大小。**如果文件中有很多处MAX，那么就会用很多100代替MAX，即出现很多份100使得目标代码变大。

  #### 改进方式：使用const变量

  ```c++
  const int Max = 100；
  ```

  这样不仅使得Max变量进入编译器检查范围，并且只会有一份变量副本。

  **注意事项：**

  1.常量指针：由于常量定义一般放在头文件中以便被不同的源码使用，因此有必要把常量指针声明为const，不仅不允许通过指针修改变量，也不允许修改指针指向：

  ```c++
  const char * const p = "sss" ;
  ```

  2.class专属常量：可以将常量的作用域限制在类内，这样常量就必须是class的成员，并且为了使得只存在一个副本而不是所有类对象都有一个常量副本，声明为static成员：

  ```c++
  class C {
      static const int Max = 100；
  };
  ```

  注意这是一个in-class声明式。只允许对于类内static整数常量进行。

  （==声明式和定义式==：C++需要对任何使用的东西提供定义式，**定义式使得编译器为此对象分配内存**。**声明式告诉编译器类型和名称**。但是对于class专属常量并且为整数类型（int、char、bool），只要不取地址，就可以声明使用它们而无需定义。==声明式也可以初始化==，把声明、定义、初始化概念分开。

  注意有可能编译器不支持in-class声明式，即声明中初始化。这样就需要进行定义式：

  ```c++
  const int Class：：MAx = 1.35； // 位于实现文件内
  ```

  而声明式随类定义位于h文件内。）

  （注意这里是static成员，与==静态存储持续性的概念有区别==，作为静态变量是会被自动进行零初始化，即所有位都被设置为0）。

  #### class专属常量的另一种形式：enum

  可以使用如下形式代替class专属常量：

  ```c++
  class C {
  	enum {Max = 100};
  	int arr[MAx];
  }
  ```

  因为枚举类型的数值可以当作int类型使用。

  枚举类型行为类似于#define，不允许取其地址，而const变量允许取地址，所以当不允许取地址时可用enum。

### 对于形似函数的宏最好用inline函数代替#define

```c++
#define MAX(a, b) f((a) > (b) ? (a) : (b));  // 以最大值调用函数f

int a = 5, b = 0;
MAX(++a, b); // 等价于((++a) > (b)) ? (++a) : (b); a累加两次
MAX(++a, b+10);	// a累加1次
```

这导致a的递增次数与它和谁相比有关，不合理。

不如改成模板内联函数：

```c++
template <typename T>
inline void Max(const T &a, const T&b) {
	f(a > b ? a : b);	// 以较大值调用函数f
}
```

## 条款3：尽可能使用const

### const作用

const语义上来说是定义了一种约束，即不允许修改。可以将const用于任何租作用域内的对象、函数参数、函数返回类型、成员函数等。

编译器会帮助检查尝试修改的做法。

需要注意的是，* 之前表示修饰的是对象本身， * 之后修饰的是指针指向的位置。

const在类型前还是在类型后作用都一样，比如：

```c++
const int a = 10；
int const a = 10；
```

### const修饰函数返回值类型与参数类型

1.修饰返回值类型即不允许将对于函数返回值进行修改，尤其是返回一个用户自定义类型的对象时；

2.修饰函数参数与修饰正常对象没什么不同。（需要注意的是，对于参数是const的引用形式，如果把一个右值（即不能取地址的值）传递给它，编译器会尝试把这个右值转换为一个匿名变量，然后引用这个匿名变量）

### const修饰成员函数

1.使得接口（函数方法）比较清晰，即声明了为const的方法表示不会对成员进行修改；

2.使得能够操作const对象。例如一个对象声明为const类型，那么就无法调用其一般接口，因为一般接口（函数方法）可能会尝试修改成员数据。这样即使一个普通接口没有修改成员无法调用。为了调用这些不修改成员的方法，就需要将这些方法声明为const。

（==什么时候会用到const对象呢？==通常不会显式声明或定义一个const对象，一般是在函数参数中将对象设置为const类型的饮用，以防止修改对象成员。）

#### 两个函数只是常量性不同也是可以被重载的

比如重载自定义数组的[]运算符，对于const对象应该使得返回值类型为const T&或者const T，运算符方法应该为const；对于非const对象应该使得运算符返回值类型为T&，运算符方法不应为const。

即对于const对象和非const对象调用同一个方法（但是方法的常量性不同）会由两个不同的版本。

#### 编译器强制实施二进制位常量性，但是编程应该按照概念常量性

以类对象为例子：

二进制位常量性指的是不允许改变类对象中成员的任何一位，编译器也是这么执行的。（修改成员数据都是通过this指针，通过对把this指针声明为const，导致无法通过this指针改变成员数据）。

概念（逻辑）常量性指的是虽然不能修改类成员，但是const成员函数可以修改它所处理的对象。这种情况只有在客户端侦测不出来时才可以。

（==客户端侦测不出来的const发生变化的情况：==比如类成员中有一个指针，虽然不允许修改常量对象的指针变量，但是指针指向的位置却不受const的约束，因此客户端侦测不出来）

这种情况下可以使用mutable关键字，把某些成员声明为mutable，这样可以修改这些对象。比如string类对象有一个指针指向字符数组，即使把string对象声明为const也不影响修改字符数组，那么string类中的成员length应该声明为mutable，这样当字符数组改变时可以修改length这个成员。

### non-const成员函数调用const成员函数

这样做的目的是当const成员函数和non-const成员函数有着等价的实现时，减少重复代码，比如数组中的[]运算符。

可以使用非const成员函数调用const成员函数，因为非const成员函数本来就可以修改或者不修改成员，因此调用const成员函数是合理的；

但是反过来就不合理，因为const成员不能修改成员，因此不能调用非const成员函数。

**非const成员函数调用const成员函数形式：**

```c++
char& operator[](int index) {
	return const_cast<char&>(static_cast<const ClassType&>(*this)[index]);
}
```

注意，这里存在两个转换

1.static_cast\<ClassType&>(*this)：安全转换，把非const对象转换为const对象，因为只有const对象才会使用const版本；

2.const_cast\<char&>把const版本的运算符[]函数的返回值类型从const char&转换为char&类型。

## 条款4：确定对象使用前已经被初始化

### 内置类型

使用前一定要先初始化。其中使用cin读取也叫做初始化。（注意初始化并不是在声明中才叫初始化）

### 用户自定义类型

对于内置类型以外的任何类型，初始化的工作由构造函数完成。

- **尽量使用初始化列表而不是在构造函数内部进行赋值**：C++规定在进入构造函数函数体之前成员变量已经创建，可以认为**初始化**（这个初始化的意思不是获得值，而是获得内存空间）在函数体之前完成（对于内置类型的成员不能保证一定在函数体之前获得初值）。因此应该使用初始化列表初始化成员，这样就避免了：先创建对象，再给对象进行赋值的时间消耗。==值得注意的是：==直接调用copy构造函数的效率比先调用default构造函数再调用copy assignment运算符的效率高！==对于内置类型：==其初始化和赋值的成本一样，但是为了一致性，使用初始化列表最好。==对于const成员和引用类型的成员：==只能在初始化列表中进行初始化！==成员初始化顺序：==与类中的声明顺序相同，所以初始化列表尽量按照成员声明顺序，防止后者对于前者有依赖。==多个构造函数有重复的成员初始化部分：==可以将那些“初始化和赋值效率相同”的成员（其实就是内置类型）统一用一个私有方法实现，这样就可以使用构造函数取调用这些内置变量的初始化操作。

- **不同编译单元中non-local static对象的初始化顺序**：==static 对象：==指的是存储持续性为static的对象，即其声明周期从程序运行开始，直到程序结束。==non-local static对象：==指的是存储持续性为static，但是非局部（即不在函数内）的对象。==编译单元：==指的是产出单一文件目标的源码，一般就是一个.cpp文件加上它包含的几个头文件。**C++对于定义域不同编译单元的non-local static对象的初始化次序无明确定义。**因为基本上也不可能进行顺序定义，例如多个编译单元的non-loacl static对象是由“模板隐式具体化“产生的，即不运行到类模板具体化的地方是不会产生这个类对象的。==解决方法是：==将每个non-local static对象移动到自己的专属函数内，这个对象在函数内声明为static（仍能保证存储持续性），定义并初始化这个对象，然后使得函数返回一个指向该对象的引用。**原理在于：**C++保证函数内的local static对象会在”函数被调用期间“、”首次遇到该对象定义式“时被初始化。所以可以用函数调用（返回一个指向local static对象的引用）替换访问一个non-local static对象。==解决方法在多线程下存在的缺陷：==因为这些函数内含static对象，所以使得它们在多线程中具有不确定性。（有可能一个函数在一个线程而另一个函数在另一个线程）会导致一件事等待另一件事，所以尽量在单线程启动阶段完成调用所有的返回局部静态变量引用的函数以解决初始化在多线程中进行竞速的关系。

  
  
  
  
  

# 第二章 构造、析构、复制运算符

本章主要是学习class中的构造、析构、赋值运算符。

## 条款5：C++编译器为类生成的函数

- default 构造函数：主要调用基类的构造函数和非静态成员的构造函数。
- 析构函数：默认为非virtual，调用基类和非静态成员的析构函数。
- copy 构造函数：将源对象的每一个成员拷贝到新对象中。
- copy assignment 运算符：基本表现与copy构造函数一致。
- move 构造函数：C++11
- move copy assignme 运算符：C++11

编译器生成的**copy assignment运算符不适用**的情况：

- 成员中存在引用类型：由于引用类型不允许更改赋值，所以编译器不允许进行赋值；
- 成员中存在const：同样不允许更改赋值；
- 如果基类的copy assignment 运算符被设声明为private，派生类无法生成默认的赋值运算符，因为派生类对象会尝试调用基类的copy assignment运算符。

## 条款6：如果不想使用编译器自动生成的函数，应该明确拒绝

1.**将相应的函数声明为private并且不予实现**：如果非成员函数或者非友元函数想要使用就会编译报错；如果成员函数或者友元函数想要使用就会链接出错，因为函数定义并不存在；

2.**声明一个基类，基类中把相应的函数定义为private，然后让实际类继承这个基类**：这样当实际类的成员函数或者友元函数尝试使用时就会报编译错误而不是链接错误。==值得注意的是：==这个做法很微妙，比如有可能导致多重继承等，又比如不一定非要public继承，也不一定需要把析构函数声明为virtual等。

**C++11可以在相应的函数参数列表后面加上=delete 表示删除禁用相应函数。**

## 条款7：为多态基类声明virtual析构函数

**1.对于polymorphic（多态性质的）的base class：**应该把析构函数声明为virtual。如果class有任何的虚函数，则就应该有一个虚析构函数。（因为存在虚函数就意味着这个这个类需要作为多态的基类。

**2.如果类的设计目的不是作为base class使用或者不是为了多态性：**不该声明虚析构函数。

（==值得一提的是：==如果声明一个虚基类（即存在纯虚函数的类），但是又没有合适的成员函数可以被声明为纯虚函数，则可以把析构函数声明为纯虚函数，即前面加上virtual，后面加上=0。同时注意必须为纯虚析构函数提供定义。）

## 条款8：析构函数不要吐出异常

- **为什么C++不鼓励析构函数抛出异常？**一个简单的例子：假设在一个区块中一个容器装有n个类对象，当离开这个块是时，需要对对象进行析构操作，如果第一个析构失败并抛出异常，还是需要对第二个对象执行析构操作，但是如果第二个也异常，就会导致C++处理两个异常，这种行为是不明确的。
- **析构函数不吐出异常：**1.出现异常就调用abort()函数终止程序；2.析构函数内catch这个异常，可以选择记录在日志中，但是不要向析构函数外传播。
- **在class中提供一个普通的函数（非析构函数）对于某个操作的异常作出反应，让用户决定是否调用：**通常是某个操作的异常会改变状态成员，当状态成员改变之后可以调用普通函数进行处理这个异常。

## 条款9：不要在构造函数和析构函数中调用virtual函数

- **不仅不要在构造和析构函数中调用virtual函数，而且构造函数和析构函数中如果存在一般函数调用，也要保证调用链中不存在virtual函数：**虚函数存在的逻辑意义是不同继承层次的对象会采用不同的行为。这就导致了问题：**派生类构造函数在调用基类构造函数会使用基类的虚函数**。（两种理解方式：1.基类构造函数执行派生类成员并未创建，如果此时虚函数的行为下降到派生类层次，即调用派生类成员，那么逻辑上是错误的；2.执行基类构造函数期间，对象的类型是基类而不是派生类，这意味着不仅虚函数会被编译器解析至基类，运行期类型信息（Runtime Type Identification）比如dynamic_cast和typeid也会把对象视作基类类型。）析构函数同理。

- **一种解决方案是：**派生类构造函数将所需要的信息通过基类构造函数调用的参数传递给基类构造函数。这里一般用派生类的静态成员函数的返回值，这样能够保证传递的已经初始化。因为最开始的问题也是由于派生类为初始化的成员导致的。

## 条款10：赋值运算符operator=返回类型是一个(*this)的引用

其实为了连续赋值的话需要返回值类型是一个左值实参，所以返回值是对象或者对象的引用都可以。但是在效率的角度，返回引用更好。

其他赋值相关的运算也遵守。

## 条款11：在operator中处理自我赋值

- **采用“证同测试”解决自我复制安全性**：就首先判断传入的参数是否为this指向的对象，如果是则直接返回。但是要注意，增加判断分支也会影响程序效率，所以需要判断是否会常有这种自身复制的情况出现，值不值得增加分支。

- **一种解决异常安全性和自我复制安全性的方法：**（影响异常安全性指的是this对象的指针可能会指向一个已经被删除的空间（比如自我赋值时删除这个指针））1.首先记住this对象的指针指向的位置；2.为指针申请新的空间并将rhs对象的内容赋值进去；3.释放原先的指针指向；4.保留这个新的指针。这种方法不是最高效的，但是一定可行。
- **（条款29）手工排列语句：**1.定义一个交换*this和rhs数据的函数；2.在operator=函数保留一份rhs数据的副本；3.在operator=函数内调用交换函数把rhs副本与\*this内容互换。==另一个变种：==当按值传递实参时，由于按值传递会自动产生一个副本，所以可以省去创建副本的操作。

ps：确定任何函数如果操作一个以上的对象，而多个对象有可能是同一个对象时，其行为仍然正确。

## 条款12：复制对象时不要忘记每一个成分

**1.要保证复制每一个成员；2.要保证复制所有的base class成分**

copy构造函数和copy assignment运算符不能相互调用，但是为了减少重复代码，可以定义一个private的复制函数，让这两个函数去调用它。

# 第三章 资源管理

资源需要的时候要向系统申请，当用完之后一定要还给系统。

最常用的资源就是动态内存，如果用完不归还给就会导致内存泄露。其他资源还有文件描述器、互斥锁、数据库连接、网络sockets等。

本章主要是建议使用对象管理资源的做法，后续对于如何管理内存做一些补充。

## 条款13：以对象管理资源

- **获得资源后立即放入对象内：**当申请一块动态内存之后，往往要记得释放内存。但是，有些情况（1.执行到释放资源语句之前return；2.continue或者goto提前退出；3.发生异常抛出异常）会导致无法执行到释放资源的语句，这就导致内存资源没有归还给系统。因此需要把资源放到对象中，因为对象一旦离开生命周期，就会被销毁，其资源也就释放。（RAII）

  资源获取即初始化：20230412：意思就是资源获得之后要进行初始化，初始化指的是一个对象创建时赋予一个值，因此意思就是资源获取之后就放到一个对象中。

- **管理对象运用析构函数确保资源被释放：**不管控制流如何离开区块，只要对象被销毁，其析构函数自动执行，资源也就被释放了。当然过程有可能发生异常，这就是前面所提到的“析构函数如何处理异常”的话题了。

### 智能指针auto_ptr

auto_ptr会在它自动销毁时释放其指向的资源。所以不要让两个指针同时指向同一对象，否则会释放一个资源两次，这种行为是未定义的。

**特性：若被copy构造函数或者copy assignment运算符复制，它们就会编程nullptr，而复制所得的指针具有所有权。**

因此其缺点就是不能同时指向同一个对象，但是对于STL容器来说，需要进行复制操作。

### 智能指针shared_ptr

引用计数型智能指针（Reference-Counting Smart Pointer），即会追踪一共有多少指针指向资源，并在无指针指向时释放资源。

RCSP的行为类似于垃圾回收，但是它无法打破环状引用，比如两个指针互相指向。

**需要注意的是：以上两种指针在其析构函数中调用的时delete而不是delete[],**因此不能指向类似于数字类型的连续空间。

## 条款14：在资源管理类中注意copy行为

当一个RAII对象被复制时，应该采用哪种策略：

- **禁止复制：**如果复制并不合理，可以拒绝复制，即在资源管理类中显式拒绝copying操作；
- **引用计数法：**即采用类似shared_ptr智能指针的方法，记录一共有多少个指针指向资源，当指针数为0时释放资源。==如果指针数为0时不想释放资源==，shared_ptr提供了删除器（deleter），即一个函数对象，当引用次数为零时被调用。例如解除互斥锁而不是删除它。
- **复制底部资源：（深复制）**就是说复制资源管理对象的时候把其资源也复制一份。
- **转移底部地缘所有权：**即像auto_ptr指针那样把资源所有权从被复制物转移到复制物，被复制的指针指向空。

## 条款15：在资源管理类中提供对于资源的访问功能

虽然使用资源管理类去管理资源的方式降低了资源未被归还的可能，但是在使用时往往是需要使用资源的，比如申请了一块char类型的内存，在使用时是希望使用char类型而不是使用资源管理对象，因此资源管理类需要对外提供直接访问资源的方式。

- **显式转换：提供一个接口（成员函数）**，比如get()方法，返回值是资源。
- **隐式转换：定义隐式转换函数，将资源管理类的类型转换成资源的类型。**比如auto_ptr和shared_ptr都提供了隐式转换为所指向资源类型指针的隐式转换函数，可以直接隐式转换为底部资源的指针类型，并且重载了指针取值操作符->和*。

需要注意的是：隐式转换可能会导致某些问题，可能被误用。

另外其实RAII对象不算是严格意义上的封装，设计它仅仅是为了管理资源，因此向外提供了访问底部资源的接口和转换。

## 条款16：成对使用new和delete时要采取相同的形式

当使用new时：1.内存被分配出来（通过名为operator new的函数，条款49和51）；2.针对此内存有一个或者更多构造函数被调用（内置类型也看作具有构造函数）。

当使用delete时：1.针对此内存有一个或更多析构函数被调用；2.内存释放（通过名为operator delete的函数，条款51）。

具体有多少个构造函数和析构函数被调用，需要关注内存中究竟有多少个对象：

- 单一内存布局：即使用new Type申请出来的空间，可以看作 [object]，只有一块内存；
- 对象数组布局：即使用new Type []申请出来的空间，需要包含这块内存的数组大小的记录 \[n][object 1]...[object n]。

虽然对于对象数组的布局并非一定是上面描述，但是可以看到两种形式的内存布局实现应该是不一样的，因此需要使用不同的delete形式：

- 针对单一内存布局：即new，需要使用delete；
- 针对对象数组布局：即new type []，需要使用delete [] type;

## 条款17：以独立语句将newed对象放入智能指针内

非独立语句形式：

```c++
int other(); // 一个其他函数的声明
void processedFunc(shared_ptr<Type> pt, int); // 参数为一个智能指针和一个int类型
...
processedFunc(new Type, other()); // !!!有可能会引发内存泄漏
```

为什么有可能引发内存泄露呢？主要原因是**对于一个语句中多项操作C++未定义顺序：**

1.调用other函数；2.new Type；3.调用shared_ptr\<Type>的构造函数。

在一条语句中这3个操作的顺序是未被定义的，可以确定的是2一定在3之前，因为2的返回值作为3的参数。

如果操作顺序为：2.new Type --> 1.调用other函数 --> 3.调用shared_ptr\<Type>的构造函数，那么假设调用other函数时发生异常，那么new出来的内存就没有存储到智能指针中，也就无法实现资源管理，从而导致内存泄露。

因此，为了保证将new出来的资源一定能存储到资源管理类中，应该把操作放到一条语句中：

```c++
shared_ptr<Type> pt(new Type);
processedFunc(pt, other());
```

对于不同语句的操作，C++是不允许调整顺序的。

# 第四章 设计与声明

软件设计就是希望软件做出期望的步骤和做法，通常从一般性的构想开始，逐渐实现细节，以允许特殊接口的开发。

这些接口最终实现为C++的声明。

本章主要是对良好的接口设计与声明进行规范。

## 条款18：让接口容易被正确使用，不易被误用

- **促进正确使用：**尽量保持用户自定义类型与内置类型的一致性（比如在设计operator=运算符时要返回对象的引用而不是对象，因为像内置类型int是不允许a * b = c的，如果返回值是一个对象，那么久允许上述赋值），以及尽量与内置类型的行为兼容（即内置类型有哪些操作，尽量让自定义类型也有）。
- **阻止误用：**包括设置新类型（**构建符合要求的参数类型**，让用户难以传入错误类型，比如**自定义类型**）、限制类型上的操作（比如operator=运算符返回值是引用等）、束缚对象值（使用const等）、消除用户的资源管理责任（不让用户进行资源释放操作等）。

PS：本节重点介绍了shared_ptr指针，包括将资源放进指针内，定义完成删除器之后再交给用户使用指针管理的资源。

**shared_ptr一个优秀的性质是：会为对象自动使用专属的删除器。**这样就消除了cross-DLL problem，指的是对象在一个动态链接库（DLL）中被new创建，却在另一个DLL内被delete销毁。之所以shared_ptr没有这个问题，是因为它的删除器是来自对象诞生所在的那个DLL的delete。

总之，shared_ptr指针大且慢，换来的是减低客户错误。（条款55）



## 条款19：设计class如同设计内置类型

如何设计高效的class呢？

- **class的对象应该如何被创建和销毁？**这会影响到构造函数、析构函数以及内存分配和释放函数（operator new、operator new []、operator delete、operator delete []）。
- **对象的初始化和赋值有什么差别？**这意味着copy 构造函数和copy assignment运算符有什么不同。
- **对象如果被按值传递，意味着什么？**这会决定copy 构造函数的设计与实现。
- **对象的合法值？**对于class的成员变量什么是合法范围，这会影响构造函数、赋值运算符的实现，需要对错误进行检查。
- **是否继承或者被继承？**如果继承了某个类，就会收到那个类的约束，比如virtual函数等；如果准备被继承，需要考虑析构函数是否为virtual等问题。
- **class需要什么样的类型转换？**如果需要其它类型转换为该类型，则需要考虑单实参构造函数（non-explicit-one-argument）以及是否为explicit等；如果需要将类转换为其他类型，则需要考虑设计类型转换运算符以及是否为explicit等。
- **什么样的操作符和函数对于class是合理的？**影响设计成员函数、运算符（成员还是友元）。
- **什么样的函数应该禁止？**可以使用private或者delete实现。
- **谁需要class的成员？**帮助决定成员为public或者private，以及友元函数友元类等。
- **什么是class的“未声明接口”？**
- **class的泛化能力？**是否需要设计为模板类。
- **是否真的需要一个class？**

## 条款20：尽量以pass-by-reference-to-const替换pass-by-value

- **对于用户自定义类型：**尽量使用按引用传递，为防止函数内部修改加上const。原因：1.比较高效。如果按值传递对象，那么至少调用一次copy 构造函数和析构函数，如果该对象成员中还存在其它类对象，那么就会调用更多copy 构造函数和析构函数。（reference往往以指针实现，因此按引用传递通常意味着传递的是指针）；2.能够避免切割问题，比如在一个继承体系中如果函数参数声明的是基类按值传递，如果传递一个派生类对象，那么派生类对象独有的部分就被切割，只有基类部分被传递。
- **对于内置类型和STL的迭代器和函数对象：**按值传递往往比较妥当。

## 条款21：必须返回对象时，别妄想返回引用

1.不要返回指针或者引用指向一个local stack对象（自动变量）；

2.不要返回指针或引用指向一个heap-allocated对象（动态内存）；（因为极有可能会忘记释放内存）

3.不要返回指针或引用指向一个local static对象（无链接性的静态变量）而有可能同时需要多个这样的对象时。（单线程合理返回指向一个local static对象的方式是在一个函数内初始化之后返回，并且只有一个引用指向这个对象）

## 条款22：将成员变量声明为private

好处：

- **保持一致性：**将所有成员设置为private之后，用户使用类时对所有的调用只能是方法，而不需要考虑哪个是成员（不需要圆括号），哪个是方法（需要圆括号）。
- **精确控制成员的访问权限：**1.不可访问：不提供get函数和set函数；2.只读访问：提供get函数；3.只写访问：提供set函数；4.读写访问：提供get和set函数。
- **封装：**封装性与当前内容改变时可能造成的代码破化量成反比，也就是说，如果一个成员是public的，外部可以随便使用，那么当这个成员被删除时，几乎所有直接使用这个成员的代码都被破坏。
- **为“可能的实现”提供弹性：**可以选择是否实现成员变量被读或者被写时通知其他对象、验证class的约束条件等。

protected成员并不比public成员更具封装性，因为protected成员更改时破坏的是派生类，public破坏的是自身类。

## 条款23：宁以non-member、non-friend函数替换member函数

- **封装性：**封装性越高，越少人去看到它，也就具有越大的弹性去改变它，因为改变仅仅直接影响看到它的人或事物。因此，越多东西被封装，我们改变这些东西的能力也就越大，即封装使得改变事物只影响有限客户。member函数向外提供接口，因此是降低了封装性，而non-member non-friend函数对内部并没有访问权限，因此加强了封装性。

- **使用non-member non-friend函数不意味着这个函数不能是另一个类的成员函数：**比如可以将这个函数定义为工具类的成员函数。
- **技能扩充性（C++组织标准库的形式）：**比如一个完整的类定义中可能有多种功能，但是当只需要其中的一部分时，可以声明一个命名空间，在命名空间中添加non-member non-friend函数使用类的其中一部分功能，比如C++标准库并不是在一个标准头文件（比如\<C++StandardLibrary>）中包含了std命名空间中的每一样东西，而是数十个文件比如<iostreeam\>、<vector\>等分别声明std的某部分功能。当需要哪一部分机能时就与哪个文件建立编译关系。这种性质也是一个类成员函数无法提供的。

## 条款24：如果所有函数参数都需要类型转换，请为此采用non-member函数

如果需要为某个函数的所有参数（包含this指针所指向的参数）进行类型转换，那么这个函数必须是个non-member函数。

例如为一个类定义了同类加法，如果同时定义了单参数构造函数（即允许其他类型向该类进行类型转换），那么 obj + int能够完成，但是int + obj却是错误的，这是因为int类型无法与obj进行运算。

因此这个同类加法不应该是成员函数。

**需要注意的是：成员函数的对立面是非成员函数，并不是friend函数。**也就是说，如果一个函数不是成员函数，不一定要定义为友元函数。

## 条款25：尝试写出一个不抛出异常的swap函数

- **当标准库中的std::swap函数对于自定义的class或class template提供可接受的效率（类中需要提供copying操作）：**直接使用这个版本就行。
- **如果std::swap默认版本效率不足（即class或者class template运用了pimpl（pointer to implementation，以指针指向一个对象，内含真正数据）的手法）：**尝试这么做：

1.提供一个public swap成员函数，让它高效地置换两个对象值，注意这个函数不要抛出异常；

2.在class或者class template所在命名空间（std命名空间不允许添加定义，重载也是）提供一个non-member swap函数或者**部分具体化的swap函数**，让它调用成员swap函数；

3.如果class不是class template，那么可以在std命名空间中**具体化swap函数**，让它调用成员swap函数。

3存在的意义是：即使2已经定定义了合适的swap函数，但是有可能会被std::swap的形式误用，所以多具体化定义了一个std::swap版本。

同上面原因，实际调用swap函数时，应该使用using std::swap声明使得标准的swap可见，这样函数查找时会首先查找当前命名空间定义的swap，即2定义的版本；如果没有，就使用std中具体化版本的swap，就是3；如果还没有，最后才会调用一般默认版本。

关于为什么成员版本的swap不要抛出异常（详见条款29）。

==值得注意的是：==**模板函数是不允许部分具体化的！**模板类允许部分具体化。所以不能够对于swap默认版本进行部分具体化（使用另一个模板作为模板函数的参数类型也是一种部分具体化）：

```c++
template <typename T>	// 原始版本
void swap(T& a, T& b) {
	T temp(a);
	a = b;
	b = temp;
}

class Widget {
private:
    ptr;
public:
    void swap(Widget& b);
};

template <>	// 具体化版本1，错误
void swap<Widget>(Widget& a, Widget& b) {
    swap(a.ptr, b.ptr);	// 无法访问私有成员
}

template <>	// 具体化版本2，正确
void swap<Widget>(Widget& a, Widget& b) {
    a.swap(b);	// 使用类内定义的方法
}

// 假如有个模板类
template <typename T>
class Widget {
private:
    ptr;
public:
    void swap(Widget& b);
    
};

template <typename T>	// 部分具体化模板函数，不合法！
void swap<Widget<T>>(Widget<T>& a, Widget<T>& b) {
    a.swap(b);	// 使用类内定义的方法
}

template <typename T>	// 尝试重载std::swap函数，不是部分具体化，不合法！因为std不允许增加内容
void swap(Widget<T>& a, Widget<T>& b) {
    a.swap(b);	// 使用类内定义的方法
}
```

因此只能在自己的命名空间中为class template类模板添加一个部分具体化的swap函数。

总结就是：**为class声明一个非默认的swap函数**，可以选择具体化std::swap函数，也可以在自己的命名空间中定义一个swap，后者请款下为了以防有人使用std::swap的方式调用，所以也在std中具体化一个swap。

**为class template声明一个非默认的swap函数**，只能在自己命名空间中定义一个swap函数。因为std不允许重载以及模板函数不允许部分具体化。

# 第五章 实现

## 条款26：尽量延迟变量定义式的出现时间

尽量延后变量的定义，直到使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够赋给它初始实参为止。

如果是在循环中，考虑：1.赋值成本与”构造+析构“成本；2.程序可阅读性和效率性哪个更重要。

## 条款27：尽量少做转型动作

- **尽量以新转型形式代替旧转型形式：**旧转型形式T(x)或(T)x，尽量只在将其它类型转换成类时使用；新转型形式：1.const_cast：通常用来将对象的常量性解除，也是唯一具有此能力的转型操作符；2.dynamic_cast：执行”安全向下转型“，用来决定某对象是否归属于继承体系中的某个类型。唯一旧式语法无法执行的动作，唯一可能耗费重大运行成本的转型动作；3.reinterpret_cast：意图实现底层转型。4.static_cast：强制进行隐式转换。比如把non-const转换成const、把派生类转换为基类等。但是不能完成const_cast的功能。
- **一旦打算转型，就要考虑转带来的危险和资源消耗：**例如，将一个派生类的对象的地址取出赋给一个基类指针，那么这个两个地址值或许并不相同（即单一对象可能拥有两个以上的地址，包括指向基类对象的指针和指向派生类的指针，这随具体实现不同而不同，**对象的布局设计随编译器不同而不同**）；再例如在基类的虚函数中将this指针转换成派生类调用派生类的同名虚函数，**由于类型转换会生成一个临时副本**，所以并不会调用该对象的基类的虚方法，而是调用一个临时对象的基类虚方法。如果想调用基类的虚方法的话，应该使用基类域解析运算符。
- **dynamic_cast的成本相当高：**许多dynamic_cast的实现版本执行速度非常慢（比如进行class名称匹配确定是哪一个类）。避免使用dynamic_cast的方法：1.使用特定类型的容器装对应类型的指针，不再统一使用基类指针指向派生类对象；2.通过base class的virtual函数接口处理所有可能的派生类想做的事情。最后应该避免使用dynamic_cast判断是继承体系里哪一个类，这样一旦改变继承体系，就会使得代码段出现错误。
- **如果转型是必要的，那么可以将转型动作隐藏于某个函数背后，让用户调用这个接口函数。**

## 条款28：避免返回handles指向对象内部成分

handles包括：引用、指针、迭代器

- **改善封装性：**1.成员变量的封装性最多只等于“返回其reference”的函数的访问级别。这意味着如果这个函数是public，那么成员变量的访问级别也是public。2.如果一个const函数返回的是非const引用，那么这个对象的成员有可能被改变。
- **降低虚吊（悬挂）handles的可能性：**即因为返回的是成员的handles，而这个**handles的存储持续性要比对象本身的存储持续性长**，因此会产生悬挂的handles。

PS：不是说绝对不能返回handles，比如operator[]运算符就允许访问string的某个字符，这是设计string的目的，但是这样的情况不是常态。

## 条款29：为异常安全努力是是值得的

异常安全函数（代码）就是指即使发生异常也不会引起资源泄露或者允许数据结构发生破坏。防止引起资源泄露通常可以“**使用对象管理资源**”实现。

异常安全函数分为三种类型：

- **基本型：**如果异常被抛出，程序内的所有事物仍然保持在有效状态下。但是不确定有效状态是指变化前还是变化后的状态。
- **强烈型：**如果异常被抛出，程序状态不不改变，即保持未调用函数的状态。常用的策略是**copy and swap**，即为打算修改的对象（原件）作出一个副本，然后在副本上做一切修改，如果修改动作完成且没有抛出异常，再将副本与原对象在一个不抛出异常的操作中互换（swap）。PS：这里副本的实现通常是把原对象的所有数据复制进另一个对象，然后使用一个指针指向副本，即pimpl。
- **不抛出异常型：**不抛出异常，总是能够完成自己的任务。但是实际上如果出现异常会调用“意想不到的函数”，可以通过set_unexpected()设置发生异常时调用的函数。

PS：函数的异常安全性最多等于它内部调用的函数的异常安全性，例如一个强烈安全的函数如果调用了一个不安全的函数，那么这个函数也不具有强烈安全性。

另外，强烈安全由于其要求对资源进行复制，因此考虑到效率问题，可能只能完成基本安全性。

## 条款30：透彻了解inline

inline函数：对于使用函数的地方使用函数本体代替。

1.如果多次使用inline函数，可能会使得目标码变大，从而导致程序体积过大，进而导致额外的换页行为，降低指令高速缓存的命中率。而如果inline函数比较小，并且调用次数少，那么会比“函数调用”的目标码更小。

2.inline只是对于编译器的申请，不是强制命令。inline可以隐喻提出，比如在类定义中定义成员函数。也可以显式声明。

3.inline通常位于头文件内，是因为在编译过程中编译器必须知道inline是什么样子，如果在其它文件中，需要在链接期间确定。同理适用于template。

4.一个表面上看似inline的函数是否真的为inline，取决于编译器的实现。比如太复杂的函数或者virtual函数，编译器拒绝使其成为inline。另外比如派生类中的空默认构造函数，虽然确实可以成为inline，但是如果类中有很多类对象，需要调用其构造函数，而如果构造过程出现异常，需要销毁基类对象和成员对象，这些代码都由编译器生成，一般放在派生类构造函数中，因此这些函数也无法成为inline。再比如取出一个函数的指针操作，那么这个函数一定会有本体存在，不然无法取地址。

5.inline函数意味着难以升级，如果改变inline函数，就必须重新编译文件；调试inline函数也是很困难。

## 条款31：文件间的编译依存关系降到最低

为什么class的定义式中需要声明所有的实现条目，比如包含的其它类的类型？最重要的原因是编译器需要在看到类型时知道为其分配多少内存。

构想：相依于声明式，不要相依于定义式。

- **handles class：**采用pimpl原则，即将原类分成两个类，其中一个类作为handles，另一个类作为implement类，前者的成员只包含一个指向implement类的指针，后者则包含真正的成员。两个类的所有接口声明都相同，因此需要为handles前置声明所有需要的类型。这样的设计原则就会使得类的接口与真正的实现分开。**基本原则：尽量让头文件自我满足，如果做不到，就让它与其他文件的声明式相依。**1.如果使用对象引用或者指针就可以完成任务，就不要使用对象。因为仅靠一个类型声明式就可以完成指针或者引用的定义，但是如果想要定义某个对象，就必须有它的类型定义。2.尽量以class声明式替换class定义式。当声明某个函数（并非调用和定义）时，仅需类的声明式即可，不需要定义式。3.为声明式和定义式提供不同的头文件。这样用户只需要#include一个声明式文件。C++标准库也是这么做的，比如声明式文件为“xxxfwd.h”，定义式则可以分布在不同的文件内“xxx.h”等。**如何使用handles类：**将所有的函数都转交给implement类完成，
- **interface class：**即使得上面所说的handles类称为一个抽象基类，这个类的唯一目的是描述它的派生类（上面所说的implement类）的所有接口。通常没有成员变量、没有构造函数，只有一个virtual析构函数和一些纯虚函数。==如何利用这个抽象基类创建一个所需要的派生类对象：==提供一个特殊函数，即静态成员函数，这个静态成员函数创建一个派生类对象（调用派生类的构造函数）并返回一个智能指针。==PS：==这体现了实现接口类的其中一种方法，即从接口类继承接口规格，时候实现出所有函数。另一种方法涉及到多重继承（条款40）。

以上两种方式也是需要付出额外代价的。

- 对于handles class：成员函数必须承担一次额外函数调用的成本；增加一个指针内存消耗；由于指针的存在，必须承担动态分配的额外开销以及可能的异常。
- 对于interface class：每个函数都是虚函数，因此有额外函数调用开销；每一个vptr都会增加内存。

PS：头文件应该仅仅涉及声明式。包括template。（意思是应该把template的定义放在另一个头文件中？）

# 第六章 继承与面向对象设计

## 条款32：public继承

public继承意味着“is-a”关系，即适用于基类的行为也一定适用于派生类，因为每一个派生类对象都是一个基类对象。

但是，这会与真实世界相悖，比如正方形是一种矩形，但是施加于矩阵的动作比如只改变长度不改变宽度却不适用于矩形，因为正方形的长宽一起变化。

再比如鸟会飞，企鹅是一种鸟，但是企鹅类不会飞，不应该有fly函数。这里其实是语言的不严谨导致的，即鸟会飞指的是大部分鸟会飞。

## 条款33：避免遮掩继承而来的名称

名称遮掩不会在意类型，比如在全局名称空间和函数局部空间内如果分别由double类型和int类型的同名变量，那么函数内部的变量名会遮掩函数外的全局变量，**无关类型。**

同样的，如果派生类中有与基类中**同名**的函数或者变量（**无关函数特征标和类型**），那么就会遮掩基类的函数或者变量，就如同派生类命名空间嵌套在基类中一样。

在public继承中，不应该出现遮掩，因为遮掩本身就表示派生类不能完成基类的行为，这违反了is-a关系，解决方案是在派生类中使用using声明基类的函数。

如果是private继承，可以使用一个转交函数，即调用基类的同名方法。

## 条款34：区分接口继承和实现继承

接口继承和实现继承不同，在public继承下，派生类总是继承基类的接口。

- **pure virtual 函数：只继承接口。**声明一个纯虚函数的目的目的是只让派生类继承接口，派生类需要根据自己的需求进行具体的实现。（C++中也可以为纯虚函数定义，但是调用方式必须指出类作用域。）
- **impure virtual 函数：继承接口和一份缺省实现。**如果派生类自己不想写一个函数，那么就会使用缺省的实现。默认的请款是基类的接口和实现是同一个函数。改变这种方式使得派生类必须了解基类的缺省行为才能使用它：1.在基类中将接口和缺省实现分开，接口使用纯虚函数实现，缺省实现使用protected方法实现，然后在派生类对于纯虚函数的实现中调用基类的protected实现；2.在基类中使用纯虚函数，并为纯虚函数提供一份定义，然后在派生类中调用基类的纯虚函数的实现。
- **non-virtual 函数：继承接口和一份强制实现。**这意味着派生类必须拥有一份基类的方法实现，代表了不变性凌驾于特异性。

注意：

- 不要把所有的方法都声明为non-virtual 函数，除非这个类永远不用作基类。
- 不要把所有的方法都声明为virtual 函数，除非派生类真的需要重新定义行为。

## 条款35：考虑virtual函数之外的其他选择

virtual函数目的：派生类与基类的同名方法有不同的行为，即在运行期间选择调用的函数。

- **由non-virtual interface 手法实现Template Method模式：**将原virtual函数设计为public的non-virtual函数，然后把真正的行为实现在一个private的virtual函数中，这样派生类会继承non-virtual函数，并在该函数内部调用private 的virtual函数，或者也可以重写这个私有方法。这个public的non-virtual称为virtual函数的外附器（wrapper），包装起来之后就可以在进行virtual时做一些其它动作。
- **借由Function Pointers实现Strategy模式：**类构造函数接受一个函数指针，并通过指针调用该函数。1.同一个类可以根据传入的函数指针（相当于函数）不同而有不同的函数；2.类的成员函数指针可以在运行期间发生变化。缺点：由于这个函数指针不是成员函数或者友元函数，因此不能使用类的私有成员信息。（使用函数指针在运行时指向不同的函数来实现虚函数）

- **借由function 完成Strategy模式：**对于特征标（返回类型和参数类型）相同的函数指针、函数对象等，可以用一个function对象实例化，然后调用这个function就相当于调用这些函数指针、函数对象。使用这个function的方式与使用函数指针、函数对象相同，都是名称(参数)。（使用函数对象在运行期间有不同的实例化来完成虚函数）
- **传统的Strategy模式：**将一个继承体系的virtual函数替换为另一个继承体系的virtual函数。（在前者继承体系里面有一个成员是指向后者继承体系对象的指针，通过这个指针来调用后者体系中的虚函数）

## 条款36：绝不重新定义继承而来的non-virtual函数

non-virtual函数是静态绑定的，即在编译时就已经确定了（根据声明的对象、引用或者指针类型确定应该使用的函数或者说是方法）；而virtual函数是动态绑定的，即在运行期间根据this对象的vptr表确定应该调用的函数。

理论上解释：

- public继承是一种is-a关系，这意味着适用于基类的每一件事都应该适用于派生类，因此两个方法不一样是不合理的。
- 派生类一定会继承基类的non-virtual方法接口和实现。

所以如果派生类真的需要一个和基类同名但是实现不同的函数，那就应该声明为virtual。

## 条款37：不要重定义继承而来的默认参数

默认参数值是静态绑定的（因为实现在运行期间确定virtual函数的默认参数的机制更为复杂），而virtual函数是动态绑定的。

因此当当对于派生类对象调用virtual函数时使用的默认参数是基类中声明的默认参数。

如果真的想要重新定义默认参数，可以采用条款virtua函数之外的实现方法，比如non-virtual函数加上private的virtual函数实现，在基类的non-virtual函数中指定默认参数类型。**即可以覆写的只能是virtual函数。**

## 条款38：通过复合塑模出has-a关系和“根据某物实现出”

复合（composition）是类型之间的一种关系，可以表示has-a关系和“根据某类型实现出”的关系。

- has-a关系：某些类型是另一种类型的组成部分，比如Person类具有string类作为名字等；
- is-implemented-in-terms-of关系：一种类是根据另一种类实现出来的类型。比如set容器可以借助list容器实现，但是不应该是继承list，因为继承表示所有适用于list的操作也适用于set，比如重复元素就不合适set，因此set应该是根据list实现出来的类型。

## 条款39：明智而审慎地使用private继承

- **private继承意味着“根据某物实现出”的关系：**通常使用复合而不使用继承。只有在派生类需要访问基类的protected成员和需要重新定义继承而来的virtual函数时才会使用private。（这种方式也可以使用在一个类中定义它所需要的那个类的派生类来完成，即复合+public继承）
- **private继承可以造成empty base最优化：**当一个类是空时，即没有成员数据时，它的大小一般被设置为1（不同的编译器可能为了对齐位而设置int大小）。也就当被用作另一个类的成员时，空类会占用内存；但是用作继承的基类时，空类不占用内存。

## 条款40：明智而审慎地使用多重继承

一、多重继承意味着在一个继承体系中某个派生类与某个基类之间有两个以上的相通路线。

C++并没有限制是否应该只有一份这样的基类副本，但是可以使用虚基类的方式使得派生类只有一个基类副本，就是在该基类的直接派生类使用virtual继承。

二、virtual继承需要付出空间和时间代价。

并且派生类的初始化需要直接调用虚基类的构造函数。

1.非必要不适用虚基类；2.如果需要使用虚基类，那么尽量不要在虚基类中声明变量，以减少初始化的麻烦。

三、当涉及到“public继承某个接口类（抽象基类，带有纯虚函数的类）”和“private继承某个协助实现的类”时，需要多重继承这两个类。

# 第七章 模板与泛型编程

## 条款41：了解隐式接口和编译期多态

class和template都支持接口和多态：

- **显式接口和运行期多态：**==显式接口==指的是当使用一个对象时，这个对象可以调用所有所属类型的接口（类中定义的public方法），可以直接找到源代码。显式接口通常由函数的声明确定，即返回值类型、函数名称、参数类型、常量性。==运行期多态==指的是当一个类中有virtual函数，对象在调用这些函数时会在运行期间确定调用哪个函数。
- **隐式接口和编译期多态：**在函数模板中，对于类型为T的对象来说，需要根据施加于对象的操作来猜测T类型具有哪些接口（详见下面的例子）。一个T类型的对象调用任何函数都用可能造成template实例化，这些实例化发生在编译期，编译器根据类型生成函数供调用。运行期多态和编译期多态就像“哪一个重载函数被调用”（发生在编译期）和“哪一个virtual函数应该被绑定”（发生在运行期）的关系。

```c++
// 隐式接口不依赖于函数声明
template <typename T>
void doSomething(T& w) {
	if (w.size() > 10 && w != someNastyWidget)
	...
}
```

看似w属于的T类型应该提供一个size函数且size函数返回值为int类型（10的类型）、支持operator!=运算符并比两个类型。

但是实际上并不一定。比如w.size()确实需要一个成员函数size，但是这个可以通过继承获得；且返回值不一定非得是int，只要是能够和10进行比较的类型对象都可以，或者返回值类型可以隐式转换为一个能够和10进行比较的类型也行。

类型T也不一定非要支持operator!=运算符，只要T能够转换为运算符需要的类型Y也行。

总结：隐式接口基于有效表达式，编译期多态基于模板实例化和函数重载解析。

## 条款42：typename双重含义

- **在template中声明参数类型时**，前缀关键字class与typename完全相同，但是还是推荐使用typename，因为typename能够表示类型并非是一个class。
- **表示嵌套从属类型名称时前面需要加上typename**，不是不能在基类列表中（即定义一个派生类时冒号:后面的基类列表）和成员初始化列表中以typename作为基类的修饰符。==嵌套从属类型名称：==从属名称指的是在一个模板中，依赖于template模板参数T的名称；嵌套从属名称指的是从属名称在class类内呈现嵌套状；嵌套从属类型名称指的是涉及到类型。说白了就是对于“T::类型”编译器不知道是T类中的成员还是T类中的类型，因此需要typename告诉编译器这是一个类型。

## 条款43：处理模板化基类中的名称

在模板化基类的派生类中，不能直接使用模板基类的成员函数，因为编译器假设模板基类有可能被具体化（特例化），具体化的基类可能与基类的行为不完全一致。

也就是C++编译器在派生类定义时不去观察模板基类的定义，从而导致找不到模板基类的成员函数。

有三种方式阻止C++不去检查模板基类的定义（意思就是让C++编译器去看模板基类到底有没有成员函数定义，当然如果没有肯定会报错）

- 1.在派生类调用基类方法时使用this指针；
- 2.在派生类中使用using声明式，即告诉编译器去基类中查找；
- 3.在派生类中使用“基类::函数”的方式调用基类方法，但是这种行为相当于关闭了virtual函数行为。

## 条款44：与参数无关的代码抽离template

template会由编译器生成具体的代码，即根据参数类型产生多个class和多个函数。

膨胀：指的是二进制代码中含有重复的代码、数据。

- 为了避免由于非类型参数造成代码膨胀，需要将template代码与非类型模板参数分离：以函数参数传递非类型参数或者以class成员变量替换template参数。
- 对于因模板类型参数造成的代码膨胀，比如如果int和long具有相同的底层大小，那么vector\<int>和vector\<long>的代码是重复的。做法是让让完全相同的二进制表述的类型共享实现码。比如指针类型都是一样大小的，不管是int*还是char\*，所以如果一个成员函数操作某个强型指针（具有类型的指针），应该令它们调用另一个操作无类型指针(void\*)的函数。

注意：抽离非类型参数需要考虑实际效率：

1.未抽离非类型参数的模板会根据类型参数的不同而生成不同的二进制代码，这些代码由于将非类型参数作为编译期常量，因此有可能被生成指令中，这也算一种优化；

抽离非类型参数的模板会缩小二进制代码的大小，因此工作集（代码运行时的页数）会小一些，这样会使得高速缓冲区中的指令比较集中，因此程序执行更快速。

2.在更改了非类型参数之后，需要考虑使用非类型参数的部分与模板之间的关系。比如如果抽离类模板中的非类型参数，需要在派生模板类中调用基类模板（非类型参数也在基类模板中声明），那么就要考虑两个类之间如何共享数据，以及由于共享数据带来的内存消耗。

## 条款45：成员函数模板接受所有兼容类型

（同一个模板实例化的两个函数或者类之间没有什么关系，比如根据一个继承体系中的基类和派生类实例化的模板之间没有继承关系，因此也就无法执行派生类向基类隐式转换的功能）

在类class之间（没有继承关系的两个类）进行类型转换时，即将其他类转换为该类，是通过接受一个参数的构造函数进行的（可以隐式也可以explicit显式）。但是如果想要一个类A接受另一个类B转换，就必须声明一个参数类型为类B的构造函数。如果又有一个类C，那么就需要更改类。

因此有了成员函数模板：即使用构造函数模板来为不同的其它类提供转换为类A的方法。

==需要注意的是：==由于存在不能进行类型转换的类，因此需要对成员函数模板支持的类型转换进行筛选，筛选的方式就是通过在类型转换函数（包括构造函数、copy构造函数、copy assignment运算符）中调用内置类型初始化或者赋值（因为类class就是由内置类型组成的），如果不允许转换就无法通过编译。

==另外：==成员模板函数如果用于泛化copy构造和泛化assignment操作，那么仍需要提供正常的copy构造函数和copy assignment运算符。

## 条款46：需要类型转换时请为模板定义非成员函数

用处：

考虑需要在一个模板类中执行该类与其它类型的运算（即其它类型需要向模板类进行类型转换）

```c++
template <typename T>
class Rational {
	...
};

template <typename T>
const Rational<T> operator*(const Rational<t> &lhs, const Rational<T> &rhs) {
	...
}

// 假如发生了如下调用
Rational<int> a;
int b;
Rational c = a + b; // 编译失败
```

原因分析：编译器对于表达式“a + b"需要调用函数模板（function template），**调用函数模板需要对参数类型进行推导（推导出参数类型才能生成函数定义）：**根据a确定参数类型T为int，但是对于int类型b来说，不是一个Rational\<T>类，因此无法推断出T的类型。==注意：==template参数推导过程不会涉及隐式类型转换！这样的转换在普通函数调用中确实存在，但是在调用函数前，必须先知道函数的存在。而为了生成这样的函数，函数模板必须推导出参数类型才能做到。

解决方案：将这个函数声明为类模板的友元。因为类模板并不依赖于函数推导（因为实例化一个类对象时，必须为其显式传递参数T，比如上面代码中显式声明参数类型T为int），所以编译器能够在为类模板实例化时得到T。

```c++
template <typename T>
class Rational {
	...
	friend const Rational<T> operator*(const Rational<t> &lhs, const Rational<T> &rhs); // 声明为类模板的友元
};

template <typename T>
const Rational<T> operator*(const Rational<t> &lhs, const Rational<T> &rhs) {
	...
}

// 发生如下调用
Rational<int> a;
int b;
Rational c = a + b; // 编译成功，链接失败

```

如果非成员函数operator*被声明为类模板的友元，当a被实例化时，类模板生成Ration\<int>的定义，同时friend函数也被声明出来，因而存在了一个被声明的函数，对于这个函数编译器会使用隐式类型转换，把int类型的b转换为Ration\<int>对象。

PS：在一个类模板内，template名称（类名）可以用来表示”template及其参数“的简略表达方式，即Rational等价于Rational\<T>

但是为什么不能链接？因为这个友元只是有了一个声明，并没有被定义出来。没有定义式，自然无法链接。==解决方案：==直接把定义式写在类模板定义里：

```c++
template <typename T>
class Rational {
	...
	// 定义为类模板的友元
	friend const Rational<T> operator*(const Rational<t> &lhs, const Rational<T> &rhs) {
		...
	}
};

Rational<int> a;
int b;
Rational c = a + b; // 编译成功，链接成功
```

更进一步，由于定义在类中的函数会被inline，这里的operator*函数比较简单inline问题不大，但是如果有一个非常复杂的函数，再inline就不合理。因此往往需要这个inline函数调用一个辅助函数。（当然一个模板函数调用的函数一般也是模板函数比较方便，如果是特定参数类型的函数，就需要声明很多比较麻烦）

## 条款47：使用traits class表现类型信息

（主要是使用traits class表现一个类在编译期的类型信息，RTTI技术用于表示运行时类型信息）

**想要表现一个类的类型信息，为什么不能在类中嵌套信息用于向外表示类型信息呢？**

因为traits这项技术不仅要求对于用户自定义类型可用，对于内置类型如指针等也要适用，而指针等内置类型是没办法嵌套信息表示类型信息的。

**如何设计并实现一个traits class：**

- 确认若干希望将来能够获取的类型信息，比如对于迭代器来说，希望获取其分类（category）；
- 为该信息选择一个名称（例如iterator_category）；
- 提供一个template和一组特化版本，内含希望的类型信息。

（下面以迭代器为例子，说明如何在编译期间获取迭代器的类型。

C++ STL中的迭代器一共有5种基础类型，分别是输入、输出、正向、双向、随机存取迭代器，其实现为：

```c++
// tag struct
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : forward_iterator_tag {};
struct random_access_iterator_tag : bidirectional_iterator_tag {};
```

)

希望实现一个加法操作advance，对于不同的迭代器能够进行不同的操作，比如对于随机存取迭代器执行+=操作，对于其它迭代器++n次

```c++
template <typename IterT, typename DistT>
void advance(IterT &iter, DistT d) {
	if (iter is a random access iterator ) iter += d;
	else {
		if (d >= 0) {
			while (d--) iter++;
		} else {
			while (d++) iter--;
		}
	}
}

// 1.在每一个用户自定义的类型种嵌套定义一个迭代器类型信息
template <...>
class dequeue {
public:
    // 嵌套迭代器类型信息
    class iterator {
    public:
        typedef random_access_iterator_tag iterator_category;
        ...
    }
};

// 2.提供一个template
template <typename IterT>
struct iterator_traits {
    typedef typenname IterT::iterator_category iterator_category;
    ...
};

// 3.提供一个具体化版本用于指针
template <typename IterT>
struct iterator_traits<IterT *> {
    typedef random_access_iterator_tag iterator_category;
    ...
};

// 4.劳工函数模板-针对随机存取迭代器
template <typename IterT, typename DistT>
void doAdvance(IterT &iter, DistT d, std::random_access_iterator_tag) { // 注意这里的第三个参数，如果有多种参数类型，C++函数解析会根据参数类型选择函数
    iter += d;
}

// 5.工头函数模板-调用劳工函数
template <typename IterT, typename DistT>
void advance(IterT &iter, DistT d) {
    doAdvance(iter, d, typename std::iterator_traits<IterT>::iterator_category()); // 注意这里第三个参数是一个对象，它具有适当的迭代器分类
}
```

**使用traits class类：**

- 建立一组重载函数（身份像劳工）或者函数模板，彼此之间的差异只在于各自的traits参数；
- 建立一个控制函数（身份像工头）或者函数模板，调用上述的劳工函数并传递traits_class所包含的类型信息。

## 条款48：认识template元编程

Template metaprograming（TMP， 模板元编程）是编写template-based C++程序并执行与编译期的过程。以C++写成、执行于C++编译器内的程序，一旦TMP程序执行，也就是从template具现出来若干C++源码，便会一如既往的编译。

作用1：让某些事情变得容易，有些事没有它是困难甚至不可能的

作用2：将一些工作从运行期转移到编译期。这导致的结果一是让某些运行期才能发现的问题在编译期就能发现，二是可能会在一下方面高效：较小的可执行文件、较短的运行期、较少的内存需要。但是编译时间会变长。

不使用TMP编程产生的错误例子：

以上条款47为例子，假如使用traits class时不采用函数重载的方法，而是使用typeid的运行期类型识别（RTTI）方法：

```c++
template <typename IterT, typename DistT>
void advance(IterT &iter, DistT d) {
	if (typeid(typename std::iterator_traits<IterT>::iterator_category) == 
		typeid(std::random_access_iterator_tag)) {
		iter += d;	
	else {
		if (d >= 0) {
			while (d--) iter++;
		} else {
			while (d++) iter--;
		}
	}
}
// 声明一个双向迭代器而非随机存取迭代器
std::list<int>::iterator iter;
// 调用会报错
advance(iter, 10);
```

**为什么编译会出错？**

首先编译器会根据参数类型生成相应的函数代码，在生成“iter += d”的代码时，由于iter的类型是双向迭代器而非随机存取迭代器，所以这行代码是错误的；

虽然在运行期间通过typeid可以知道这行代码是永远不会执行的，但是在编译器会为“永远不会执行的代码”也生成目标码，所以这行代码无法通过编译。

因此在上一个条款中使用的逻辑是：if...else逻辑（即判断是哪个类型在使用哪个操作）被template和它的具体化版本体现出来（函数重载解析判断参数类型选择函数也就是操作）。

注意，TMP元编程被证明是“图灵完全机”，这意味着它可以计算任何事物，声明变量、执行循环、编写以及调用函数。

**下面以TMP通过递归模板具现化实现循环：(以及如何在TMP中创建和使用变量）**

计算阶乘：

```c++
// 类模板
template <usigned n>
struct Factorial {
	enum { value = n * Factorial<n-1>::value };
};

// 类模板特化（具体化）
template <>
struct Factorial<0> {
	enum { value = 1 };
}；
```

TMP能够做到的目标：

1.确保度量单位正确。确保度量单位的正确组合是根关键的，比如允许把“距离”类型的变量与一个“时间”类型的变量的商赋给一个“速度”类型的变量，再比如不允许把一个质量类型的变量赋给一个速度类型的变量。使用TMP可以确保在编译期中程序中所有的度量单位组合正确；

2.优化矩阵运算。比如实现了一个矩阵运算，那么Matrix res = a * b * c *d这个表达式会生成4个临时矩阵变量，如果使用高级的TMP技术，有可能消除临时对象；

3.用来生成基于政策选择组合的客户定制代码，即用户可以选择以什么样的设计模式（设计模式如strategy、observer等可以有很多种方式实现，把这些实现作为选项提供给用户，用户选择组合选项实现行为）组合实现行为。

# 第八章 定制new和delete

## 条款49：了解new_handler的行为

当时operator new申请分配内存失败时，会首先调用一个错误处理函数（new handler），如果这个函数不存在，就会抛出异常。

如果用户想要指定这个new handler函数，可以使用set_new_handler函数指定：

```c++
#include <new>
namespace std {
	typedef void (*new_handler)();
	new_handler set_new_handler(new_handler p) throw();
};
```

在std命名空间中，new_handler类型其实是一个函数指针；set_new_handler函数接受一个处理函数指针，返回的函数指针是之前的处理函数。

（当op new申请内存失败时，会不断调用new_handler函数，直到找到足够内存。条款51）

**一个设计良好的new_handler函数应该做的事：**

- 让更多内存被使用：以便让new的下一次分配内存成功，一个策略是程序一开始就分配一大块内存，当首次分配失败时，将这块内存归还。
- 设置另一个new_handler函数：如果当前的new_handler函数无法做到申请更多内存，可以设置新的new_handler函数，即调用set_new_handler函数修改处理函数替换自己。还可以修改自己的行为，以便下次被调用的时候做一些不同的事。
- 卸载new_handler函数：即设置处理函数为空指针，这样下一次分配失败时就会直接抛出异常。
- 抛出bad_alloc异常：这样的异常不会被new捕捉，而是传播到内存申请的地方。
- 不返回：直接调用abort或者exit函数终止程序。

**对于不同的class分配失败时采用不同的处理方式：**

C++不支持每个class专属的new_handler函数，但是可以通过以下方式实现这种行为：

1. 每一个class类定义一个set_new_handler函数：用于指定想要调用的handler处理函数；
2. 每一个class类定义一个operator new函数：在分配过程中以class专属的handler函数代替全局的handler函数。

```c++
class Widget {
private:
	static std::new_handler current_handler;
public:
	static std::new_handler set_new_handler(std::new_handler p) noexcept;
	static void * operator new(std::size_t size);
};

// 需要在class实现文件初始化指向new_handler函数的指针
std::new_handler Widget::current_handler = nullptr;

// set_new_handler函数需要做的工作是保存获得的指针p，并将之前的指针作为参数返回
std::new_handler Widget::set_new_handler(std::new_handler p) noexcept {
    std::new_handler old_handler = current_handler;
    current_handler = p;
    return old_handler;
}
```

==注意:==这里只是把某个new_handler函数与class绑定，但是如果想要在内存分配不足时调用这个new_handler函数需要使用std的set_new_handler函数安装这个处理函数才行。

class的operator new函数应该做的事情：

- 调用std::set_new_handler函数，将class专属的new_handler函数传递给它，以完成安装动作。
- 调用std的全局global operator new函数，执行内存分配。==这里需要注意的是：==当内存申请失败时，如果最终抛出异常，那么class的operator new必须保证全局的new_handler函数恢复为原来的默认处理方式。
- 如果std的全局global operator new函数分配内存成功，class的operator new函数返回一个指向内存的指针，但是同时，class的析构函数也需要管理global new_handler函数，也就是需要卸载当前的new_handle函数，将class进行operator new之前的handler恢复。

由于上述原因，需要创建一个资源管理类。这个类保存过去的new_handler，并且当这个对象过期时（其实就是在进入class 的 operator new函数时，创建这个对象保存过去的handler，当new函数结束时，就可以重新安装它了，也就是class专属的new_handler已经没用了）重新安装它保存的new_handler

```c++
class NewHandlerHolder {
private:	
	std::new_handler handler;
public:
	explicit NewHandlerHolder(std::new_handler nh) : handler(nh) {}
	~NewHandlerHolder() { std::set_new_handler(handler); } // 重新安装new_handler
    
    // 禁止copying
    NewHandlerHolder(const NewHandlerHolder &other) = delete;
    NewHandlerHolder & operator=(const NewHandlerHolder &other) = delete;
};
```

有了资源管理类，就可以定义class的operator new函数：

```c++
void * Widget::operator new (std::size_t size) {
	// h对象保留过去的handler，当该类的new动作完成之后，即可恢复原来的handler
	NewHandlerHolder h(std::set_new_handler(current_handler)); 
	return ::operator new(size);
}
```

**复用上述方案：**

即把这个资源管理类当作一个基类，这样所有派生类都可以继承它的特性——独特的new错误处理方式。

同时为了使得每个派生类能够获得实体互异的基类成员数据复件，需要把这个类改成模板。（其实就是不同的派生类有不同的基类，这样就会保存不同的静态成员变量current_handler）

```c++
class NewHandlerHolder;
template <typename T>
class NewHandlerSupport {
private:
	static std::new_handler current_handler;
public:
	static std::new_handler set_new_handler(std::new_handler p) noexcept;
	static void * operator new(std::size_t size);
};

// 需要在class实现文件初始化指向new_handler函数的指针
std::new_handler Widget::current_handler = nullptr;

// set_new_handler函数需要做的工作是保存获得的指针p，并将之前的指针作为参数返回
template <typeanme T>
std::new_handler NewHandlerSupport<T>::set_new_handler(std::new_handler p) noexcept {
    std::new_handler old_handler = current_handler;
    current_handler = p;
    return old_handler;
}

template <typename T>
void * NewHandlerSupport<T>::operator new (std::size_t size) {
	// h对象保留过去的handler，当该类的new动作完成之后，即可恢复原来的handler
	NewHandlerHolder h(std::set_new_handler(current_handler)); 
	return ::operator new(size);
}

// 资源管理类
class NewHandlerHolder {
private:	
	std::new_handler handler;
public:
	explicit NewHandlerHolder(std::new_handler nh) : handler(nh) {}
	~NewHandlerHolder() { std::set_new_handler(handler); } // 重新安装new_handler
    
    // 禁止copying
    NewHandlerHolder(const NewHandlerHolder &other) = delete;
    NewHandlerHolder & operator=(const NewHandlerHolder &other) = delete;
};

// 使用方式
class Widget : public NewHandlerSupport {
    ...
    // 和之前一样，不必再定义new和set_handler_new函数
}
```

**目前的new：**

之前的new如果申请失败返回空指针，目前的C++如果申请失败会抛出异常。

取消抛出异常：C++11支持采用nothrow的方式阻止抛出异常并返回空指针：

```c++
Widget *p = new (std::nothrow) Widget;
```

上面的表达式做两件事：1.nothrow版本的new被调用，如果分配失败返回空指针；2.如果分配成功调用Widget类的构造函数，而因为这个构造函数可以做任何事情，比如申请一块空间。

**因此虽然new (std::nothrow)不抛出异常，但是上述表达式可能会。综上没有使用它的必要。**

## 条款50：了解new和delete的合理替换时机

有时可能默认的new和delete不能满足要求，因此需要自定义new和delete，理由有如下这些：

- **检测运用上的错误：**比如将”new所得的内存delete失败“、”在new得到的内存上多次使用delete“等等，可以在自定义的new和delete上做一些额外操作检测错误。
- **收集使用上的数据：**比如分配区块的大小分布如何、倾向于先入先出还是后进先出来分配和归还、最大动态分配量是多少。
- **为了增加分配和归还的速度：**由于默认的new和delete往往是泛用的，需要考虑的事情比较多，所以并不针对某一特定类型具有优秀性能，因此为了提高某种类型的分配和规划的速度，可以采用定制化new和delete，但是要首先确认程序的效率瓶颈是默认的new和delete带来的。
- **为了降低默认内存管理器带来的空间额外开销：**泛用型分配器往往不仅比定制型慢，而且还会占用更多内存，因为常常在每一个分配区块上使用更多额外开销。
- **为了弥补默认分配器中的非最佳齐位：**齐位（alignment）是许多计算机体系结构要求特定的类型必须放在特定的内存地址上，比如要求指针的地址必须是4的倍数或者double的地址必须是8的倍数，如果没有齐位，有可能会导致硬件异常或者运行效率不高。因此为了效率更高，需要自行进行齐位操作。
- **为了将相关对象成簇集中：**如果某些对象往往一起使用，并且希望在处理这些对象的时候”内存页错误“的频率最低（尽量将它们放在一起会降低页错误率，操作系统内存管理页结构），那么可以定制化这种行为。
- **为了获得非传统行为：**希望做一些默认版本分配器没有做的行为，比如归还的时候希望把所有的内存都覆盖为0。

ps：并不一定需要自己定制化new和delete，原因1.某些编译器已经在它们的内存管理函数中切换为调式和志记状态，可以查看相关文档从而不必自己编写；2.有很多商业产品可以替代编译期自带的内存管理器；3.开放源码中也会有内存管理器，比如Boost库中的Pool（条款55）就是一款内存管理器。

## 条款51：编写new和delete时需要遵守一些规则

- 自定义的new函数应该：1.返回正确的值；2.申请失败时调用new_handler函数；3.应对0内存需求；4.注意派生类会继承基类的new

```c++
void * operator new(std::size_t size) {
	using namespace std;
	if (size == 0) size = 1;
	
	while (true) {
		尝试分配size bytes;
		if (分配成功) return 指针；
		
		// 分配失败，找出目前的new_handler函数
		new_handler global_handler = set_new_handler(0);
		set_new_handler(global_handler);
		
		if (global_handler) global_handler();
		else throw std::bad_alloc();
	}
}
```

==需要注意的是：==上述的new函数在一个循环中，如果申请失败不断调用new_handler函数，退出循环的唯一办法是内存被分配成功或者new_handler函数做出如下行为（条款49）：让更多内存可用、安装另一个new_handler函数、卸载当前new_handler函数、抛出异常、承认失败直接return。

派生类会继承基类的new运算符，所以当使用new申请一个派生类对象时，调用的是基类的new。如果基类的new并非想处理派生类的内存申请，可以先判断是否申请的是基类的空间，如果不是则转交给std的new函数进行处理：

```c++
void * Base::operator new(std::size_t size) {
	if (size != sizeof(Base)) return ::operator new(size);
	
	// 剩余部分在这里处理
}
```

如果需要实现operator new []，唯一需要做的事情就是分配一块内存，无法计算array中包含多少个对象，因为首先对象大小不确定（因为基类的operator new[]有可能被继承调用，将内存分配给派生类对象使用）

- 自定义的delete函数应该：1.保证删除null指针是合法的；2.如果成员delete内存大小有误，交给std的delete函数处理

```c++
void Base::operator delete(void *rawMemory, std::size_t size) {
	if (rawMemory == 0) return;
	if (size != sizeof(Base)) {
		::operator delete(rawMemory);
		return;
	}
	
	// 归还内存
	return;
}
```

## 条款52：写了placement new也要写palcement delete

**正常new和delete如何处理内存泄漏:**

```c++
Widget *p = new Widget;
```

上述语句先调用new分配内存，再调用Widget的构造函数，如果在调用构造函数时出现异常，需要释放new的内存，由于用户并未获得内存指针，所以无法操作这块内存，C++会自动调用与之匹配的delete函数

```c++
void * operator new(std::size_t); // 正常的new

void operator delete(void *rawMemory); // 正常的new对应的delete
void operator delete(void *rawMemory, std::size_t); // class中典型的delete
```

**placement new和delete的含义：**

即带有正常形式参数之外的参数的new和delete，比如处理size之外还接受一个指针指向被构造之处：

```c++
void *operator new(std::size_t, void *pMemory);
```

（这个new的用途之一就是在vector未使用的空间上创建对象）

**因此为了防止内存泄漏，就需要有一个placement delete与placement new参数个数个类型完全一致，再加上一个自定义的delete，一共需要一个new和两个delete**

**另外，为了防止类中的new和delete掩盖正常的new和delete，可以采用的方案是建立一个base class，把所有的正常形式的new和delete包含，然后让class继承这个base class：**

```c++
// 默认的new
void * operator new(std::size_t);
void * operator new(std::size_t, void *);
void * operator new(std::size_t, const std::nothrow_t &);

class StandardNewDeleteForm {
public:
	// 正常形式new和delete
	static void * operator new(std::size_t size) { return ::perator new(size); }
	static void * operator delete(void *pMemory) { return ::delete(pMemory); }
	// placement new和delete
	static void * operator new(std::size_t size, void *ptr) { return ::new(size, ptr); }
	static void * operator delete(void *pMemory, void *ptr) { return ::delete(pMemory, ptr); }
	// nothrow的new和delete
	static void * operator new(std::size_t size, const std::nothrow_t &nh) { return ::new(size, nh); }
	static void * operator delete(void *ptr, const std::nothrow_t &nh) { return ::delete(ptr, nh); }
};

// 正常类继承并声明其中的new和delete函数
class Widget : public StandardNewDeleteForm {
public:
    using StandardNewDeleteForm::new;
    using StandardNewDeleteForm::delete;
    声明class自己的new和delete
    ...
}
```

# 杂项

## 条款53：不要轻视编译器的警告

1.不要请示编译器的警告，尝试在最高警告级别下达到“无警告”；

2.不要过度依赖于编译器的警告，不同的编译器对待事情的方式并不相同，因此当程序移植之后，可能原警告会消失。

## 条款54：熟悉TR1在内的标准程序库



## 条款55：熟悉Boost























