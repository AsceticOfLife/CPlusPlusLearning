# 规划

书本一共14章，一周两章，预计两个月左右看完。今天是5.5，也就是7.5左右看完，同时有思考、笔记、代码。

每一章大概40页左右，那么一周两章就是读80页，一章花费两天看完，一天就是20页；一周中抽出4天看两章。

# 第一章 

BDF 正确答案：ABCD

要实现部分子类所需要功能，我的想法就是创造一个新类，在这个类中提供方法，谁有这个能力就继承这个新类。

不好的地方：如果每个鸭子的fly有细微差别，那么新类是没有办法复用的，即使是接口也需要不同的实现。

其实上述思路是可以的，即将**需要变化的部分分离出来。**（即鸭子的基本属性是不变的，飞行方式是变化的）

将变化的行为设计成一个接口，也就是抽象类，使用多态的方式实现不同的行为特征。

**接着针对接口（抽象类）进行编程，而不是针对实现编程。**

什么是针对实现：1.继承而来的方法；2.或者继承某个接口**自行实现**。

针对接口编程就是直接使用接口而不考虑其实现。

这样就可以让不变化的部分与变化的部分组合，**并且变化的部分不会影响到不变化的部分。**

这里还有一个缺点就是：即使使用引用或者指针指向接口，需要new一个具体的接口的行为。

总结：

###### 原则1：将需要变化的部分分离出来；

###### 原则2：针对接口编程而不是针对实现编程

-------------

提问：如何设计一个行为可以在运行时改变的鸭子？

目前是使用一个引用或者指针指向动态的行为类，所以可以设计这样一个函数：申请一个新的行为对象，删除旧的行为对象；让这个行为引用或者指针指向新的行为对象。

作者的思路和我一样，只不过作者把一个行为类对象作为参数传入，直接让函数设置这个新的行为对象。

------

将一组行为描述为一族算法，表示鸭子类能够做的事情。

一组算法与鸭子之间是has-a关系（使用composition方式）、鸭子与各种鸭子是is-a关系（public继承方式）、抽象基类与派生类是implement关系（使用public继承方式）

###### 设计原则3：多用组合实现复用，少用继承

###### 第一个设计模式：策略模式

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\1.png" alt="image-20230506172243134" style="zoom: 80%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\1-2.png" alt="image-20230506172954113" style="zoom:67%;" />

-----

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\1-1.png" alt="image-20230506172929811" style="zoom:80%;" />

----------

设计模型可以充当行话，使得讨论和思考层面不深入到数据或者操作，而是保留在设计层次。

设计模式指的是如何组织类和对象以解决某种问题。

知道了封装、抽象、继承、多态并不会让你马上变成优秀的面向对象设计者，**构造面向对象系统的经验**被收集和整理成为设计模式。

设计是一门艺术，要考虑**弹性的设计**、**可以维护**、可以应付变化。

- 抽象：把关注的特点提取出来

- 封装：将特点包装在一个类中
- 多态：不同的对象的行为不同，不同的函数的行为不同
- 继承：继承原有属性，进行扩展。

# 第二章

ABCDE 正确答案：ABCE

以报纸（主题）和订阅报纸的人（观察者）说明观察者模式。

###### 观察者模式

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\2-1.png" alt="image-20230508114437383" style="zoom: 80%;" />

###### 设计原则3：为了交互对象之间的松耦合而努力。

------

如何世界天气数据和展示板之间的关系：

注意这里不仅有观察者模式，关注展示板接口的实现还采用了之前的策略模式。

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\2-2.png" alt="image-20230508145537535" style="zoom:67%;" />

 <img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\2-3.png" alt="image-20230508145629945" style="zoom:67%;" />

-------

这里需要思考的问题是，是否直接将天气的三个数据传递给展示板观察者呢？明显通过调用观察者的update，将三个数据作为参数传递是有问题的，因为如果以后增加了数据，需要重新编写所有的update函数。

-----------

目前实现的观察者模式，总是主题将数据push给观察者，有些时候有些数据观察者并不需要。能否让观察者主动去get想要的数据呢？

----------

观察者模式与设计原则：

1.关于变化的部分与不变的部分分离：一个具体的主题看作是不变的，变化的是谁来订阅这个主题

2.关于针对接口编程而非实现：在主题中，使用的是观察者的接口；在具体的观察者中，使用的是主题的接口。

3.关于多用组合，少用继承：在主题接口中，观察者作为成员数据的一部分；在具体的观察者中，主题作为成员的一部分。

# 第三章

以饮品和调料为例，我觉得应该设计一个调料的接口，组合进入饮品。

组合的动态扩展。

###### 设计原则4：类应该对扩展开放，对修改关闭

即使用组合的话，由于是通过指针或者引用动态确定，方便了扩展；

并且对于组合类的修改，不会影响现有的类。

总体来说就是在不修改现有代码的情况下**搭配**新的行为。

对于要进行扩展的部分要小心地选择，并不是所有的部分都要扩展。

**装饰者与被装饰对象：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\3-1.png" alt="image-20230511110348122" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\3-2.png" alt="image-20230511110428168" style="zoom:80%;" />

与我的构思不同的是，将调味作为一个包含了饮品的类，这样就不会改变音频的代码。

###### 装饰者模式

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\3-3.png" alt="image-20230511110644767" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\3-4.png" alt="image-20230511110852093" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\3-5.png" alt="image-20230511111100016" style="zoom:80%;" />

-----

如何实现饮品和调料的cost：对于饮品来说，就是返回饮品的价格；对于调料来说，首先通过访问自己引用的饮品的cost得到饮品的价格，再加上饮料的价格。

如何实现调料的getDescription：需要通过饮品得到饮品的描述，再加上调料的描述。

-----

这里的继承只是为了使得饮品和调料“同类型”；行为是来自装饰者和基础组件。

新的装饰者可以增加新的行为，不用修改组件。

# 第四章

-----

如何把实例化具体类的代码从应用中隔离？
使用一个函数完成这个实例化操作，返回对象的指针。

作者的思路：讲创建对象的工作交给工厂对象完成。

利用静态方法创建对象的工厂与上面的对象有什么区别：不需要使用创建对象的方式实例化对象。

###### 简单工厂

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\4-1.png" alt="image-20230512112117560" style="zoom:67%;" />

如果有多个不同的工厂需求，那就创建三个工厂类。

如果希望各自工厂做稍微的改变，即需要各自工厂（即子类）自己定义creat对象函数，那么可以采用抽象基类的方法。

即工厂现在是一个函数方法而不是之前的类。

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\4-2.png" alt="image-20230512113033446" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\4-3.png" alt="image-20230512113108610" style="zoom: 67%;" />

**解耦的实现：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\4-4.png" alt="image-20230512113339229" style="zoom:67%;" />

上面的过程实际上把一个创建对象的工作从交给一个对象转移到交给一个方法（子类中的方法）来实现。

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\4-5.png" alt="image-20230512113823969" style="zoom:80%;" />

**工厂模式方法（抽象方法实现）：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\4-6.png" alt="image-20230512114510094" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\4-7.png" alt="image-20230512114532355" style="zoom:67%;" />

**工厂模式方法（对象实现）：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\4-8.png" alt="image-20230512114739343" style="zoom:80%;" />

###### 工厂方法模式

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\4-9.png" alt="image-20230512114910915" style="zoom:80%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\4-10.png" alt="image-20230512115035099" style="zoom:67%;" />

分析依赖性：

直接实例化一个对象时，就是在依赖它的具体类：

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\4-12.png" alt="image-20230512115704946" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\4-11.png" alt="image-20230512115640861" style="zoom:67%;" />

###### 设计原则5：依赖抽象而不是依赖具体类

依赖倒置原则

不仅不能让高层组件依赖底层组件的具体类，而是依赖抽象，并且无论高层还是底层组件都应该依赖抽象。

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\4-13.png" alt="image-20230512120135449" style="zoom:67%;" />

倒置思考方式：假如以思考pizza店要生产披萨，从上到下的设计方式是：披萨店要生产哪些pizza，这种思考方式就会使得商店依赖于多种披萨类；

从下向上思考：为所有的披萨类设计一个抽象的pizza接口，即所有的披萨都依赖于这个pizza接口；那么商店只需要使用这个接口，依赖于这个接口。靠一个工厂生产出pizza给商店。

###### **指导方针**

**违反时要有充足的理由**

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\4-14.png" alt="image-20230512144306245" style="zoom:80%;" />



###### 抽象工厂模式

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\4-15.png" alt="image-20230513154652514" style="zoom:80%;" />

抽象工厂的每个方法实际上都是工厂方法。

工厂方法使用的是继承，需要扩展一个类，并覆盖它的工厂方法。

抽象工厂使用的是组合，当需要一个抽象工厂时，需要是实例化一个工厂，并把它传递给客户，让客户的成员中存在这个工厂，使用这个工厂创建产品家族。

抽象工厂方便将产品家族和相关产品集合在一起，工厂方法便于将客户代码与创建对象解耦，使用方式很简单，将其设置为一个抽象方法，必须子类实现它。

# 第五章

单件实例类：

1.构造函数是私有的；2.使用一个静态方法创建一个对象；3.使用一个静态成员变量保存实例化对象。

###### 单件模式

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\5-1.png" alt="image-20230515111246339" style="zoom: 80%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\5-2.png" alt="image-20230515111531479" style="zoom: 80%;" />

**单间模式存在的问题是：**

在多线程中或许由于同步问题而创建出多个实例对象。

因此要解决同步问题。

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\5-3.png" alt="image-20230515112354072" style="zoom:80%;" />

书中给了针对java语法关键字解决方案，以及一种牺牲延迟实例化，直接在最开始就借助静态变量实例化这个对象：

<img src="D:\RegularFile\C++\learning\2.C++进阶\Head First 设计模式\image\5-4.png" alt="image-20230515112515137" style="zoom:80%;" />















