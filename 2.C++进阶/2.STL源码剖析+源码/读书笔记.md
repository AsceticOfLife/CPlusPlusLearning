开始于2023.10.7

主要是相对STL库进行系统学习。

# STL概论与版本简介

## STL概论

STL低层次来说是一个组件库，方便使用；高层次来说是一个抽象概念库，定义了一些概念应该具有的标准。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-1-1.png" alt="image-20231007085138361" style="zoom:67%;" />

## STL六大组件 功能和运用

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-2-1.png" alt="image-20231007085543857" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-2-2.png" alt="image-20231007085616544" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-2-3.png" alt="image-20231007090023570" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-2-4.png" alt="image-20231007090139020" style="zoom:67%;" />



STL源码就在C++的头文件中，一般存在两个版本，具有扩展名（为了向下兼容）和不具有扩展名（C++建议的命名方式）。GNU C++的SGI版本不但有一线的<vector.h>和<vector\>，还有二线的<stl_vector.h>

## GNU源码开放精神

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-3-1.png" alt="image-20231007090636314" style="zoom:67%;" />

实际上是一种代码前的声明，即允许使用，但是条件是加上这个声明。

由于出现了很多不同的开放源码分支，为了整合各方，后面又出现了open source名字，只要符合9条定义就是open source软件。

GCC全称是GNU Compiler Collection，是由GNU开发的编程语言编译器。

## HP实现版本

STL最早的版本是HP实现版本，需要遵守的是在所有文文件加上HP的版本声明，这种授权不属于GNU GPL，属于open source。

## P.J.Plauger实现版本

PJ版本继承HP版本，但是还加上了自己的声明，因此既不属于open source，也不属于GNU GPL。

被Visual C++采用。由于Visual C++对于C++的语言特性支持并不理想，所以PJ版本变现受到影响。

## Rouge Wave实现版本

由Rouge Wave公司开发，继承HP版本，加上自己的版权声明。因此既不属于open source，也不属于GNU GPL。

由C++ Bulider采用。

## STLport实现版本

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-7-1.png" alt="image-20231007093229552" style="zoom:67%;" />

## SGI STL实现版本

SGI版本由Silicon Graphics Computer System，Inc.公司发展，继承HP版本，属于open source的一员，但是不属于GNU GPL。

SGI版本被GCC采用，可以在GCC的include字幕下找到所有的STL文件。

### GNU C++头文件分布

众多头文件大致可以分为：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-8-1.png" alt="image-20231007093907304" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-8-2.png" alt="image-20231007093927544" style="zoom:67%;" />

### SGI STL文件分布与简介

1.STL标准头文件（无扩展名）：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-8-3.png" alt="image-20231007094131488" style="zoom:67%;" />

2.C++ Standard定案前，HP规范的STL头文件（扩展名.h）：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-8-4.png" alt="image-20231007094300435" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-8-5.png" alt="image-20231007094325649" style="zoom:67%;" />

3.SGI STL内部私用文件（SGI STL真正实现于此）：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-8-6.png" alt="image-20231007094425418" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-8-7.png" alt="image-20231007094448737" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-8-8.png" alt="image-20231007094518419" style="zoom:67%;" />

### SGI STL的编译器组态设置

（“组态(Configure)”的含义是“配置”、“设定”、“设置”等意思，是指用户通过类似“搭积木”的简单方式来完成自己所需要的软件功能，而不需要编写计算机程序，也就是所谓的“组态”。）

SGI STL准备了一个环境组态文件<stl_config.h>定义了许多常量，标志着某些组态成立与否。所有STL文件都会直接或者间接包含这个文件，以条件式写法，让预处理器根据常量取舍一段程序代码。

通过这些组态能够判断对于C++特性的支持情况。

## 可能会令你困惑的语法

指的是一些C++中的语法层次的特性。

### stl.config中出现的组态

#### 1.**模板类**中的**静态数据成员**初始化

常量__STL_STATIC_TEMPLATE_MEMBER_BUG

（1）首先搞清楚隐式实例化、显式实例化、显式具体化的意思，这里以函数模板来说明含义：
隐式实例化：根据传递的参数类型由编译器根据模板定义生成函数定义；
显式实例化：主动声明对哪种参数类型生成函数定义，使用的是通用模板定义；
显式具体化：对于特定的类型生成与通用模板不同的函数定义。

```c++
#include <iostream>

// 通用模板
template <typename T>
void swap(T &a, T &b);

// 显式实例化
// 不用提供定义，使用通用模板的定义
template void swap<int>(int &a, int &b);

// 显式具体化
// 需要提供定义，使用不同于通用模板的定义
template <> void swap<double>(double &a, double &b);

int main(void) {
    char a = 'a', b = 'b';
    swap(a, b); // 隐式实例化

    int a1 = 1, b1 = 2;
    swap(a1, b1); // 显式实例化

    double a2 = 12.8, b2 = 13.1;
    swap(a2, b2); // 显式具体化

    return 0;
}

// 通用模板定义
template <typename T>
void swap(T &a, T &b) {
    using std::cout;

    T temp = a;
    a = b;
    b = temp;

    cout << "a = " << a << " b = " << b << '\n';
}

// 显式具体化模板定义
template <> void swap<double>(double &a, double &b) {
    using std::cout;

    double temp = a;
    a = b;
    b = temp;

    cout << "b = " << b << " a = " << a << '\n';
}

```

（2）其次搞清楚类模板的具体化：

```c++
// 1.隐式实例化：根据需要声明对象时传递类型参数来实例化一个类模板

// 2.显式实例化：未进行声明对象时传递类型参数来实例化一个类模板
template class ClassType<AnyType>;

// 3.显式具体化：对于特定类型参数，类的定义需要不同时，需要定义一个不同的类模板
template <> class ClassType<Antype> {
    ...
};

// 4.部分具体化：如果一个类模板有多个类型参数，可以使得某些类型具体化
// 通用模板
template <typename T1, typename T2>
class Pair {...};
// 对于typename T2进行具体化
// 注意具体化是需要提供定义的
// 关键字template后面的<>声明的是没有被具体化的类型参数
// 如果所有类型都被指定，那么<>里面是空的，就成了显式具体化
template <Typename T1>
class Pair<T1, int> {...};
```

（3）普通类的中的静态成员初始化：在类中声明，在类外初始化。一般初始化放在方法文件中，因为头文件可能被包含很多次，导致多个初始化语句副本。

```c++
class StringBad {
public:
    static int nums;
};

// 静态成员初始化
// 不需要关键字
int StringBad::nums = 0; 
```

（4）模板类中的静态成员数据初始化：

```c++
// 两种数据成员
// 第一种不依赖于模板的类型参数
// 第二种依赖于模板的类型参数

template <typename T> 
class TestTemStatic
{
    public:
    static int knownTypeVar;
    static T unKnownTypeVar;
};

// 第一种类型的初始化方式
// 1.范化定义,定义num时不需要知道T的类型
template <typename T> int TestTemStatic<T>::knownTypeVar=50;
// 2.具化定义，给出T类型,同时定义num，T可以是其他任意特定类型。
template <> int TestTemStatic<int/* any other type */>::knownTypeVar=2;

// 第二种类型的初始化方式
// 具化定义
template <> float TestTemStatic<float>::unKnownTypeVar=4.0f;
```

MinGW支持这个特性。

#### 2.模板类的部分具体化

常量：__STL_CLASS_PARITIAL_SPECIALIZATION

```c++
#include <iostream>
using namespace std;

// 一般化模板
template <typename I, typename O>
struct Test {
    Test() {
        cout << "I, 0" << endl;
    }
};

// 部分特殊化设计
// 这里的部分具体化需要这样理解：
// 关键字template后面的<>里面是没有被具体化的类型
// 后面的<>里面中第二个类型参数使用的是第一个没有被具体化的类型
//（按照过去的认知具体化应该是某些已知类型，比如int、char等，但是实际上是可以使用未被具体化的类型的）
template <typename T>
struct Test<T*, T*> {
    Test() {
        cout << "T*, T*" << endl;
    }
};

// 部分特殊化设计
// 这里的部分具体化理解与上面一个例子类似
// 注意const与否也表示一种重载
template <typename T>
struct Test<const T*, T*> {
    Test() {
        cout << "const T*, T*" << endl;
    }
};

int main(void) {
    // 初始化三种模板并且调用默认构造函数
    Test<int, char> obj1;
    Test<int *, int *>obj2;
    Test<const int *, int *>obj3;

    return 0;
}
```

MinGW支持这个特性。

#### 函数模板的重载

常量：__STL_FUNCTION_TMPL_PARTIAL_ORDER

虽然未文件中声明这个常量的意义与partial specialization of function templates相同，但是实际上并不相同。前者的意义如下表示，后者参考C++语法书籍。

```c++
// 节选自stl_vector.h内容
class alloc {};

template <class T, class Alloc = alloc>
class vector {
public:
    void swap(vector<T, Alloc> &) {
        cout << "swap()" << endl;
    }
};

#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
template <class T, class Alloc>
inline void swap(vector<T, Alloc> &x, vector<T, Alloc> &y) {
    x.swap(y);
}
#endif
// 上面这一段是节选自stl_vecor.h，表示根据常量进行条件编译
// 如果定义了这个常量，说明支持这个语法
// 所以会调用这个模板函数，模板函数就会调用类方法。从而打印出swap
// 但是如果没有定义这个常量，就不会生成这个模板

int main(void) {
    vector<int> x, y;
    swap(x, y); // 没有输出，说明调用的不是重载的模板函数

    return 0;
}

```

（我使用的是MinGW8.1.0的64位编译器，这里没有定义这个常量。因此实际上调用的是另一个模板函数。）

#### 显式函数模板参数

常量：__STL_EXPLICIT_FUNCTION_TMPL_ARGS

整个SGI STL没有用到这一个定义

#### 模板成员

常量：__STLMEMBER_TEMPLATES

```c++
#include <iostream>
using namespace std;

// 声明一个空类
class alloc {};

// 声明一个模板类
template <typename T, typename Alloc = alloc>
class vector {
public:
    typedef T value_type;
    typedef value_type* iterator;

    // 类模板中的模板成员函数
    template <typename I>
    void insert(iterator position, I first, I last) {
        cout << "insert()" << endl;
    }
};

int main(void) {
    int ia[5] = {1, 2, 3, 4, 5};

    vector<int> x;
    vector<int>::iterator it;
    x.insert(it, ia, ia + 5); // insert()

    return 0;
}
```

MinGW支持这个特性。

#### 模板参数可否根据前一个模板参数设定默认值

常量：__STL_LIMITED_DEFAULT_TEMPLATES

```c++
#include <iostream>
using namespace std;

// 声明一个空类
class alloc {};

// 声明一个模板类
template <typename T, typename Alloc = alloc, size_t BufSiz = 0>
class deque {
public:
    deque() {
        cout << "deque" << endl;
    }
};

// 根据前一个参数值T，设定下一个参数的默认值
template <typename T, typename Sequence = deque<T>>
class stack {
public:
    stack() {
        cout << "stack" << endl;
    }
private:
    Sequence c;
};


int main(void) {
    stack<int> x; // 输出 deque 和 stack

    return 0;
}
```

MinGW支持这个特性

#### 类模板是否可以拥有non-type参数

常量：__STL_NON_TYPE_TMPL_PARAM_BUG

MinGW支持类模板的非类型参数。





后面还介绍了一些常量，均表示是否支持的一些C++语法功能，但是我采用的版本并不存在这些常量（应该大部分都支持），所以暂时先不看了。

### 临时对象的产生与运用

临时对象又称为匿名对象（比如按照传递时就会产生一个临时对象）。

刻意创造一个临时对象的方法是：在类型后加一对小括号，可以指定初始值。例如 Shape(3, 5)。相当于调用类型的构造函数到那时不指定名称。

STL将这个技巧应用于仿函数和算法的搭配上。

```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

// 定义一个仿函数
template <typename T>
class Print {
public:
    // 重载()运算符
    void operator()(const T &elem) {
        cout << elem << ' ';
    }
};


int main(void) {
    using std::for_each; // 算法
    using std::vector;
    int arr[5] = {1, 2, 3, 4, 5};
    vector<int> iv(arr, arr + 5);

    // print<int>()是一个临时对象
    // 调用重载运算符()的方法
    for_each(iv.begin(), iv.end(), Print<int>());

    return 0;
}
```

### 静态常量整数成员在类内直接初始化

如果类中包含const static integtal 的成员数据，那么可以直接给与初始值。注意这里必须是const；以及integral指的是所有的整数类别，包括int、short、char等。

### 自增、自减、解引用操作符

```c++

class Test {
public:
    // 前置自增或者自减的重载方式
    Test& operator++() {
        ++(this->i_);
        return *this;
    }
    
    // 后置自增或者自减的重载方式
    Test operator++(int) {
        Test temp = *this;
        ++(*this); // 调用前者自增运算符
        return temp;
    }
    
    // 解引用运算符
    int& operator*() const {
        return (int&)i_; // 上述转换操作明确告诉编译器需要将const int转为non-const lvalue
    }
private:
    int i_;
};
```

### 前闭后开区间表示法

任何STL算法都需要获得一对迭代器所标示的区间，用以表示操作范围。这区间是前闭后开的，即后面的迭代器指向的是最后一个元素的下一个位置。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-9-1.png" alt="image-20231008090304336" style="zoom:67%;" />

### 函数调用操作符operator()

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-9-2.png" alt="image-20231008090510347" style="zoom:67%;" />

这一整组操作可以是以函数的形式实现，通过**函数指针**将函数作为参数传递。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-9-3.png" alt="image-20231008090707579" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\1-9-4.png" alt="image-20231008090733191" style="zoom:67%;" />

# 空间配置器allocator

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-1-1.png" alt="image-20231008091511056" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-1-2.png" alt="image-20231008091534119" style="zoom:67%;" />

## 空间配置器的标准接口

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-1-3.png" alt="image-20231008105406145" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-1-4.png" alt="image-20231008105431614" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-1-5.png" alt="image-20231008105452081" style="zoom:67%;" />

### 设计一个简单的空间配置器：JJ::allocator

知识点1：ptrdiff_t是表示指针之间的差距的数据类型，可以是负数；size_t是表示数组长度的类型，必须是正数。

知识点2：**set_new_handler()**函数定义在头文件new中，当operator new函数申请分配内存失败时，会尝试调用错误处理函数，这个函数如果不存在就会抛出异常。使用set_new_handler函数可以指定这个handler函数。

知识点3：placement new指的是在用户指定的内存位置上申请空间。语法格式为：

```c++
// address：placement new所指定的内存地址
// ClassConstruct：对象的构造函数
Object * p = new (address) ClassConstruct(...);
```

知识点4：作用域解析运算符::(1)作用1是表示指定类中的成员或者命名空间中的成员，比如使用A::member表示类A中的成员；(2)作用2是当前面没有类或者命名空间时，表示全局作用域符号，可以用于区分同名的全局和局部变量。

```c++
int jmz = 2; //全局变量
int main() {
    int jmz = 3; //局部变量
    jmz = jmz* jmz;//局部=局部*局部
    ::jmz = ::jmz* jmz;//全局=全局*局部
    cout << jmz << endl;
    cout << ::jmz << endl;
}
```

自定义一个allocator类：

```c++
#ifndef _JJALLOC_
#define _JJALLOC_

#include <new> // for placement new
#include <cstddef> // for ptrdiff_t, size_t
#include <cstdlib> // for exit()
#include <climits> // for UINT_MAX
#include <iostream> // for cerr

namespace JJ {

// allocate的实际实现，申请size个T类型的空间
template <typename T>
inline T* _allocate(ptrdiff_t size, T*) {
    set_new_handler(0); // 设置当new失败时的处理函数为空，所以会直接退出
    T* tmp = (T*)(::operator new((size_t)(size * sizeof(T)))); // 申请size个T类型的空间
    // 如果得到空指针
    if (tmp == 0) {
        cerr << "out of memory" << endl;
        exit(1); // 退出
    }

    return tmp;
}

// deallocate的实际实现，释放指定位置内存
template <typename T>
inline void _deallocate(T *buffer) {
    ::operator delete(buffer); // 调用global operator delete
}

// construct的实际实现，在指定位置创建一个对象
template <typename T1, typename T2>
inline void _construct(T1 *p, const T2 &value) {
    new(p) T1(value);
}

// destory的实际实现，调用指定对象的析构函数
template <typename T>
inline void _destory(T *ptr) {
    ptr->~T();
}

// 自定义的空间配置器类
template <typename T>
class allocator {
public:
    // 定义类型
    typedef T           value_type;
    typedef T*          pointer;
    typedef const T*    const_pointer;
    typedef T&          reference;
    typedef const T&    const_reference;
    typedef size_t      size_type;
    typedef ptrdiff_t   difference_type;

    // 一个嵌套的类模板
    // rebind allacator of type U
    template <typename U>
    struct rebind {
        typedef allocator<U> other;
    }

    // 配置空间，用于存储n个T对象
    // hint used for locality
    pointer allocate(size_type n, const void *hint = 0) {
        return _allocate((difference_type)n, (pointer)0);
    }

    // 归还配置的空间
    void deallocate(pointer p, size_type n) {
        _deallocate(p);
    }

    // 使用T对象value在指定位置p创建一个新对象T
    void construct(pointer p, const T &value) {
        _construct(p, value);
    }

    // 析构指定位置p的对象T
    void destory(pointer p) {
        _destory(p);
    }

    // 返回某个对象的地址
    pointer address(reference x) {
        return (pointer)&x;
    }

    // 返回某个const对象的const地址
    const_pointer const_address(const_reference x) {
        return (const_pointer)&x;
    }

    // 返回可成功配置的最大值
    size_type max_size() const {
        return size_type(UINT_MAX/sizeof(T));
    }

};


} // end of namespace JJ

#endif
```

使用MinGW无法通过编译，**因为SGI STL的allocator并不完全符合STL规范，我们编写的符合规范的自然不能搭配使用。**

## 具备层次配置能力的SGI空间配置器

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-1.png" alt="image-20231009093741874" style="zoom: 67%;" />

### SGI标准的空间配置器std::allocator

这个allocator部分符合STL标准，它在文件 defalloc.h 中实现。但是SGI STL的容器并不使用它，也不建议我们使用，它存在的意义仅在于为用户提供一个兼容老代码的折衷方法，其实现仅仅是对new和delete的简单包装因此效率不高。

### SGI特殊的空间配置器std::alloc

C++内存配置操作和释放操作：

```c++
class Foo {...};
Foo *pf = new Foo; // 配置内存，然后构造对象
delete pf;	// 析构对象，然后释放内存
```

new运算符包括两给阶段的操作：（1）调用::operatro new配置内存；（2）调用Foo::Foo()构造对象内容；

delete运算符号包括两阶段的操作：（1）调用Foo::~Foo()将对象析构；（2）调用::operator delete释放内存。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-2.png" alt="image-20231009193732479" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-3.png" alt="image-20231009194118094" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-4.png" alt="image-20231009194159187" style="zoom:67%;" />

### 构造和析构的基本工具：construct()和destory()

construct()和destory()示意图：
<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-5.png" alt="image-20231009200509941" style="zoom:67%;" />

下面是作者注释的<stl_construct.h>的部分内容，主要是为了说明construct和destroy的功能。（不同版本的SGI STL代码可能不同，但是设计思路是一致的。）

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-6.png" alt="image-20231009201210619" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-7.png" alt="image-20231009201251845" style="zoom:67%;" />

这两个构造和析构的函数被设计为全局函数，STL规定配置器应该具有construct和destroy两个成员函数，但是实际上SGI STL中的std::alloc配置器并没有遵守这一规则。

关于上面的construct函数：接收一个指针p和一个初始值value，改函数的作用就是将初始值value设置到指针所指的空间上。（使用C++ placement new完成）

关于上面的destroy函数：第一个版本接受一个指针，将指针所指的对象析构。第二个版本接收first和last两个迭代器，准备将[first, last)内的对象析构。考虑到这个范围可能很大，并且如果每个对象的析构函数都是trivial destructor(即系统默认的析构函数)，那么会降低效率。因此这里的方法是先利用**vaule_type()**获得迭代器所指对象的类型，再利用**__type_traits<T\>**判断这种类型的析构函数是否无关痛痒。如果是(\_\_true_type)，那么什么都不做；如果否(\__false_type)，以循环方式遍历每一个对象，并对于每一个对象调用第一个版本的destroy()。

### 空间配置和释放，std::alloc

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-8.png" alt="image-20231010114141367" style="zoom:67%;" />

为了解决小型区块可能造成的内存破碎的问题，SGI设计采用了双层配置器，第一级配置器直接使用malloc和free，第二级配置器当配置区块超过128bytes时，认为内存够大调用第一级配置器，否则认为过小，采用内存池（memory pool）的方式。第一级和第二级配置器的关系：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-9.png" alt="image-20231010114558211" style="zoom:67%;" />

无论alloc被定为第一级还是第二级配置器，SGI都为其增加一层包装为simple_alloc。第一级配置器和第二级配置器的包装以及使用方式：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-10.png" alt="image-20231010114745673" style="zoom: 80%;" />

### 第一级配置器解析malloc_alloc_template

第一级配置器以malloc()、free()、realloc()等C函数实现实际的内存配置、释放、重配置操作。

```c++
void * malloc(size_t size); // 申请大小为size个字节的内存，如果分配成功返回一个void *指针，否则返回空指针
void * realloc(void *ptr, size_t size); // 更改已经分配的内存空间的大小，返回新的空间地址
void * calloc(size_t num, size_t size); // 申请num个大小为size个字节的内存空间
void  free(void *ptr); // 释放指针指向内存
```

（第一级配置器定义为template <int inst\> class __malloc_alloc_template，在使用时会指定inst为0，

```c++
typedef __malloc_alloc_template<0> malloc_alloc; // 之后就可以将malloc_alloc作为第一级配置器的名称
```

这样用户在不知道这个类是什么模板的情况下无法生成其它模板。下面均是类中的成员定义）

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-11.png" alt="image-20231010161734519" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-12.png" alt="image-20231010161806524" style="zoom:67%;" />

由于作者采用的版本仍然使用malloc等C函数，所以并没有用到C++中的new-handler机制（即当new申请空间失败时，在抛出std::bad_alloc异常之前，可以选择调用一个指定的处理函数，参考《Effective C++》第三版条款49）。所以这个版本的SGI第一级配置器实现了一个类似的set_malloc_handler：

（下面仍然是第一级配置器类内的成员函数）

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-13.png" alt="image-20231010162652236" style="zoom:67%;" />

（下面是在类外进行malloc-handler函数的初始化）

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-14.png" alt="image-20231010162717093" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-15.png" alt="image-20231010162823575" style="zoom:67%;" />

如果第一级配置器的allocate和realloca在调用malloc和realloc失败之后，改为调用oom_malloc和oom_realloc，后二者都有内循环，不断调用”内存不足处理例程“（即new-handler），希望能够处理好内存分配工作。但是如果未设置new-handler（即为空指针时）则直接抛出异常。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-16.png" alt="image-20231010163535768" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-17.png" alt="image-20231010163624088" style="zoom:80%;" />

### 第二级配置器解析default_alloc_template

为什么需要第二级配置器？避免太多小额区块造成内存碎片，以及配置时的额外负担（overhead）。如果区块越小，那么额外负担所占比例就越大。
<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-18.png" alt="image-20231010184810091" style="zoom: 67%;" />

第二级配置器的做法是：如果申请区块超过128byte，交给第一级配置器处理；否则以内存池管理，此方法又称为次层配置。

所谓内存池，就是先配置一大块内存，使用自由链表（free-list）管理，当有需要相同大小的内存需求时，从自由链表中取出一块内存使用；如果归还空间，就添加到链表上。

为了方便管理，第二级配置器会把任何区块需求量上调至8字节的倍数，一共维护16个free-list，大小分别为8，16，...，128。free-list的结点结构为：

```c++
union obj {
	union obj *free_list_link;
    char client_data[1];
};
```

使用union节省空间的巧妙之处：当没有作为用户使用的空间时，在链表上使用第一个字段指向下一个obj；当作为用户使用的空间时，使用第二个字段指向实际区块。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-19.png" alt="image-20231010185528301" style="zoom:67%;" />

下面是第二级配置器的实现内容：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-20.png" alt="image-20231010185623532" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-21.png" alt="image-20231011153809092" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-22.png" alt="image-20231010185751889" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-23.png" alt="image-20231010185811896" style="zoom:67%;" />

### 空间配置函数allocate

接口函数**allocate()**的主要流程是：先判断区块大小，如果超过128byte，就交给第一级配置器；小于128就检查对应的free list，如果链表上有可用的区块，就直接取第一块来用，如果没有，就将区块大小上调至8的倍数，然后调用**refill()**函数为这一个free list填充空间。

```c++
static void * allocate(size_t n) {
    obj * volatile * my_free_list;
    obj *result;
    // 大于128就调用第一级配置器
    if (n > (size_t)__MAX_BYTES) {
        return malloc_alloc::allocate(n);
    }
    
    // 循环16个free list中适当的一个
    my_free_list = free_list + FREELIST_INDEX(n);
    result = *my_free_list;
    if (result == 0) {
        // 如果free list上没有空闲的区块就重新填充区块
        void *r = refill(ROUND_UP(n));
        return r;
    }
    
    // 取出当前free list的第一个区块
    *my_free_list =- result->free_list_link;
    return result;
}
```

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-24.png" alt="image-20231011154406479" style="zoom:67%;" />

### 空间释放函数deallocate

接口函数**deallocate()**主要流程是：如果内存块大于128byte，调用第一级配置器释放内存；否则找到区块大小对应的free list，将这个区块插在链表第一个位置。

```c++
static void deallocate(void *p, size_t n) {
    obj *q = (obj *)p;
    obj * volatile *my_free_list;
    
    // 大于128就调用第一级配置器
    if (n > (size_t)__MAX_BYTES) {
        malloc_alloc::deallocate(p, n);
        return;
    }
    
    // 找到对应大小的free list
    my_free_list = free_list + FREELIST_INDEX(n);
    // 调整free list，将区块插入为第一个
    q->free_list_link = *my_free_list;
    *my_free_list = q;
}
```

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-25.png" alt="image-20231011161922484" style="zoom:67%;" />

### 重新填充链表函数refill

当allocate发现适当位置的链表为空时，就调用**refill()**为这一个链表重新填充空间。新的空间取自内存池（由chunk_alloc完成）。默认情况下获取20个新区块，如果内存池空间不足，获取区块数会小于20.

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-26.png" alt="image-20231011163212262" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-27.png" alt="image-20231011163410061" style="zoom:67%;" />

### 内存池(memory pool)管理

**chunk_allco**函数以end_free - start_free（单位是字节数）来判断内存池中的空间。
如果空间足够满足总需求量（默认是20个需求大小区块），那么直接将空间分配；
如果空间不够总需求量，但是可以满足至少一个（含）以上需求区块大小，那么修改默认返回的区块大小（也就是将20转换为实际上能够满足的区块数量），然后将这些空间返回；
如果空间连一个需求的区块大小都不能满足，那么就需要向堆区申请内存，申请内存大小为2倍的总需求量加上一个随着分配次数越来越大的附加量。不过在正式向堆区申请内存之前，先将内存池中的零头分配给适当的free list。之后正式调用**malloc**函数向堆区申请内存。如果申请成功，那么就调用自身将需求满足；如果申请失败，那么先尝试将free list中未使用并且足够大的（也就是空间至少大于1个需求区块大小）区块拿出来，补充内存池空间，然后调用自己分配内存。如果free list后面的均为空，那么最后尝试将任务交给第一级配置器尝试进行分配。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-28.png" alt="image-20231015172629792" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-29.png" alt="image-20231015172815949" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-30.png" alt="image-20231015173027951" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-31.png" alt="image-20231015173123208" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-32.png" alt="image-20231015173205110" style="zoom:67%;" />



### 总结

无论是第一级还是第二级配置器，最终都被**simple_alloc**包装：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-33.png" alt="image-20231015173352882" style="zoom:67%;" />

使用配置器的方法：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-34.png" alt="image-20231015173532284" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-2-35.png" alt="image-20231015173546855" style="zoom:67%;" />

缺省参数alloc已经被typename为第一级配置器或者第二级配置器，SGI STL将其设置为第二级配置器。

## 内存处理基本工具

STL定义五个全局函数，用于处理未初始化空间。前两个是用于构造的**construct**和用于析构的**destroy**，另外三个是uninitialized_copy()、uninitialized_fill()、uninitialized_fill_n()，对应着高层次函数copy、fill、fill_n。如果想要使用这三个此层次函数，应该包含头文件memory，但是实际定义于stl_uninitialized。

### 概述

**uninitialized_copy：**

```c++
template <typename InputIterator, typename ForwardIterator>
ForwardIterator
uninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);
```

将内存的申请与对象的初始化行为分开，主要负责完成对象的初始化功能。

对于目的地result，调用复制构造函数，利用[first, last)的每一个迭代器指向的对象复制一个新的对象。相当于调用了construct(&*(result + (i - first)), *i)，在相应的位置产生相应的复制品。

如果需要实现一个容器，容器的全区间构造函数（range constructor）通常以两个步骤完成：
1.申请内存空间，足以包含范围内所有元素；
2.使用uninitialized_copy在内存空间上构造元素。

C++标准要求具有commit or rollback特性，也就是要么构造出所有元素，要么一个都不构造。

**uninitialized_fill：**

```c++
template <typename ForwardIterator, typename T>
void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T &x);
```

将内存的申请与对象的初始化行为分开，主要负责完成对象的初始化功能。

对于[first, last)迭代器指向的内存，均使用x进行初始化。也就是对于范围内的每个迭代器 i 指向的内存地址调用construct(&*i, x)。

同样需要具有commit or rollback特性。

**uninitialized_fill_n：**

```c++
template <typename ForwardIterator, typename Size, typename T>
ForwardIterator
uninitialized_fill_n(ForwardIterator first, Size n, const T &x);
```

将内存的申请与对象的初始化行为分开，为指定范围内的所有元素设定相同的初始值。

对于[first, first + n)范围内的每一个迭代器指向的内存调用复制构造函数，产生x的复制品。

同样需要具有commit or rollback特性。



### 源代码

**uninitialized_fill_n：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-3-1.png" alt="image-20231016091351869" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-3-2.png" alt="image-20231016091507205" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-3-3.png" alt="image-20231016091617090" style="zoom:67%;" />



**uninitialized_copy：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-3-4.png" alt="image-20231016091714181" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-3-5.png" alt="image-20231016091755619" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-3-6.png" alt="image-20231016091905466" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-3-7.png" alt="image-20231016091935680" style="zoom:67%;" />



**uninitialized_fill：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-3-8.png" alt="image-20231016092012397" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-3-9.png" alt="image-20231016092106840" style="zoom:67%;" />

### 源代码总结

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\2-3-10.png" alt="image-20231016092217446"  />



# 迭代器与tiaits技巧

设计模式中对于迭代器模式的描述：提供一种方法能够顺序访问一个聚合对象中的各个元素，而又不暴露内部表示。

## 迭代器设计思维

STL的中心思想是将算法与容器分开，使其泛型化。可以分别使用函数模板和类模板实现。

迭代器充当二者之间的胶着剂，算法通过迭代器访问容器中的所有元素，这样就不需要了解容器内部表示。

以find算法为例，如果想要操作不同的容器，比如list和queue，在不使用迭代器的情况下，必须知道如何访问list和queue的所有元素的方法，但是list和queue由于结构不同，其遍历所有元素的方法有可能不同，比如list可以采用链式存储结构实现，也可以采用顺序存储结构实现，queue同样也有自己的结构实现，那么遍历方法肯定是不相同的。于是对于两种不同的容器就存在两种find算法。

如果使用迭代器，那么迭代器向提供统一的一种遍历容器的所有元素的方法，例如将接口定义为itrator++的这种表示，虽然不同的容器迭代器的接口实现不同（比如对于链式存储结构iterator++实现为next方法，对于顺序存储结构实现为指针加法），但是对于高层的算法find来说，只要不断使用iterator++就可以实现所有元素的遍历。

## 迭代器

迭代器是一种抽象概念，可以理解为一系列标准的集合（比如说苹果是一个概念，苹果的简单劣质标准就是：红的、圆的、水果，那么主要符合这三个标准就认为是苹果）。

最重要的标准就是通过迭代器能够访问指向的元素，也就是解引用（operator*）和成员访问（operator->）。

迭代器类似于智能指针的概念。因为智能指针能够满足迭代器的标准要求。

下面以list容器为例设计一个迭代器：

首先是list和结点结构的定义：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-2-1.png" alt="image-20231016095219326" style="zoom:67%;" />

list容器的迭代器定义为：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-2-2.png" alt="image-20231016095447808" style="zoom: 80%;" />

这里使用的例子如下：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-2-3.png" alt="image-20231016095604833" style="zoom: 67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-2-4.png" alt="image-20231016095634437" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-2-5.png" alt="image-20231016095722792" style="zoom:67%;" />

上面就可以看出迭代器向上层隐藏了不同容器的实现细节，但是迭代器本身一定要非常清楚容器的实现细节，所以一般每一种STL容器都有专属的迭代器。

## 迭代器相关的类型

算法中有可能需要用到**迭代器相关的类型**（包括所指向对象的类型、所指向对象的指针和引用类型以及const形式的指针和引用类型、迭代器类型）。例如需要在算法中声明一个临时变量，这个变量的类型与迭代器指向的对象类型一致。

解决方法是利用**编译器对于模板函数的参数类型推导机制**。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-3-1.png" alt="image-20231016151209397" style="zoom:67%;" />

比如这里想要使用迭代器所指向对象的类型，但是如果直接将迭代器对象作为参数传递给算法，那么算法只能推导出迭代器的类型。

这里将接口和实现分开，在接口中，接受一个迭代器对象，编译器推导出迭代器类型；在实现中，接受一个迭代器所指向对象，根据传入的所指对象（即迭代器解引用的对象）编译器推导出迭代器所指之物的类型。

## Traits编程技巧

利用编译器推导函数模板的参数类型并非是全能的。因为本质上是**根据传入的实参**来推断形参类型，从而能够使用形参的类型。

但是如果算法的返回值需要迭代器相关的类型，那么就无法推断。

解决方法是在迭代器类中声明一个**嵌套类型声明**：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-4-1.png" alt="3-4-1" style="zoom:67%;" />

算法根据传入的迭代器类型推断出迭代器的class type，根据class中的嵌套声明就可以确定返回值类型。

但是这种方法存在限制，即要求迭代器必须是class type，但是并不是所有的迭代器都是class，比如原生指针就是一种迭代器，但是没有办法在原生指针中添加声明。

解决方法是利用类模板的偏特化——针对任何模板参数更进一步的条件限制所设计出来的一个特化版本。例如：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-4-2.png" alt="3-4-2" style="zoom:67%;" />

所以，即使原生指针没有办法声明嵌套类型，也可以通过设计特化版本的迭代器，来处理算法的模板参数（迭代器参数）为指针的情况。

结合上面两种方式，设计一个类模板专门用于萃取迭代器的特性：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-4-3.png" alt="image-20231016153210490" style="zoom:67%;" />

这个类模板接受一个迭代器类型，必须是class type，于是就可以访问迭代器类中声明的嵌套类型value_type。

如果是原生指针的化，就需要一个偏特化版本：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-4-4.png" alt="image-20231016153427788" style="zoom:67%;" />

这个特化版本接接受一个原生指针类型，并将原生指针所指类型typedef为value_type。

提供以上两个萃取类模板，于是算法就可以根据传入的迭代器对象传给这个萃取模板，萃取模板根据迭代器是class还是原生指针来选择以不同的方式返回所指对象的类型。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-4-5.png" alt="image-20231016153723392" style="zoom:67%;" />

最后需要补充的是，针对“指向常熟对象的指针”，iterator_traits<const int *>::value_type得到的类型是一个const int，但是这并不是我们所期望的，我们希望利用这种机制声明一个临时变量，这个临时变量的类型与迭代器的value_type相同。但是如果这个临时变量不可赋值，那么没有什么意义。所以**当迭代器是一个pointer-to-const类型，应该令其value_type为一个non-const类型。**这就需要另一个特化版本：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-4-6.png" alt="image-20231016154115640" style="zoom:67%;" />

### Traits技巧总结

**iterator_traits模板类作用：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-4-7.png" alt="image-20231016154251504" style="zoom:67%;" />



**与迭代器相关的类型有五种：**
如果想要自定义的容器与STL的算法兼容，那么自定义容器的迭代器一定要定义五种相应的类型。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-4-8.png" alt="image-20231016154427219" style="zoom:67%;" />

### 迭代器相关类型：value type

指的是迭代器所指对象的类型。

实现方法为：

```c++
// 1.在迭代器类中声明value_type类型
template <typename T>
class iterator {
public:
    typedef T value_type; // 声明指向的对象的类型是value_type
};

// 2.在iterator_traits 类模板中嵌套声明value_type类型
template <typename I>
struct iterator_traits {
    typedef typename I::value_type value_type;
};

// 偏特化原生指针类型
template <typename T>
struct iterator_traits<T *> {
	typedef T value_type;  
};

// 偏特化指向常熟对象的指针（pointer-to-const）
template <typename T>
struct iterator_traits<const T *> {
	typedef T value_type;  
};

// 3.使用时根据迭代器类型得到value_type
// 以count为例
// 根据传入的迭代器对象获取迭代器类型I
// 将迭代器类型I传入iterator_traits模板，得到value_type
template <typename I, typename T>
typename iterator_traits<T>::difference_type
count(I first, I last, const T &value) {
    typename iterator::traits<I>::difference__type n = 0;
    for ( ; first != last; ++first) ++n;
    
    return n;
}
```



### 迭代器相关类型：difference type

表示两个迭代器之间的距离。也可以用来表示一个容器的最大容量。

实现方法：

```c++
// 1.在迭代器class type中声明difference type
template <typename T>
class iterator_type {
public:
    typedef ptrdiff_t difference_type; // 假设迭代器的difference_type底层类型就是ptr
};

// 2.在iterator_traits类模板中声明difference_type类型
template <typename I>
struct iterator_traits {
	typedef I::difference_type difference_type;
};

// 原生指针特化版本
template <typename T>
struct iterator_traits<T *> {
	typedef ptrdiff_t difference_type;  
};

// 指向常量对象的指针特化版本
template <typename T>
struct iterator_traits<const T *> {
	typedef ptrdiff_t difference_type; 
};

// 3.使用时先对推断出迭代器类型I，再通过将I传递给iterator_traits类模板提取类型
typename iterator_traits<I>::difference_type
```

### 迭代器相关类型：reference type

迭代器可以分为两种：不允许改变所指对象内容，称为constant iterator，比如const int *pic；允许改变所指对象内容，称为mutable iterator，比如int *pi。

当对于一个mutable iterator进行解引用操作(operator*)时，获得的应该是是一个左值而不是一个右值，因为左值允许赋值操作，右值不允许赋值操作。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-4-9.png" alt="image-20231016213859704" style="zoom:67%;" />

在C++中，函数如果想要传回左值，都是以引用的方式返回类型。所以当p是一个mutable iterator时，如果其value_type是T，那么*p的类型不应该是T，应该是T &；如果p是一个constant iterator，其value_type是T，那么\*p的类型不应该是const T，应该是const T &。

*p的类型就是reference type。

### 迭代器相关类型：pointer type

reference type类型指的是传回一个左值类型，令它代表p所指之物；pointer type类型指的是传回一个左值类型，令它代表p所指之物的地址。

实现方法：

```c++
// 1.将reference type和pointer type加入迭代器中
template <typename T>
class iterator {
public:
    typedef T & reference;
    typedef T * pointer;
};

// 2.在iterator traits类模板中添加声明
template <typename I>
struct iterator_traits {
	typedef typename I::reference reference;
    typedef typename I::pointer pointer;
};

// 针对原生指针的偏特化版本
template <typename T>
struct iterator_traits<T *> {
	typedef T & reference;
    typedef T * pointer;
};

// 针对指向常量的指针的偏特化版本
template <typename T>
struct iterator_traits<const T *> {
	typedef T & reference;
    typedef T * pointer;
};

// 3.在算法中使用时根据传入的迭代器对象确定迭代器类型I
// 在将I传给iterator_traits类模板生成合适的类定义并访问其中声明的reference和pointer
template <typename I>
void func(I iterator) {
    iterator_traits<I>::pointer 
    iterator_traits<I>::reference 
}
```

### 迭代器相关类型：iterator_type

迭代器一共有五种类型：

- 输入迭代器：针对于程序来说从容器中输入，只读，只能递增，单通行（不保证第一次和第二次遍历顺序相同，递增之后不保证前一个迭代器的值还可解引用）
- 输出迭代器：针对于程序来说向容器中输出，只写，只能递增，单通行。
- 正向迭代器：可读可写，只能递增，多通行（总是按照相同的顺序遍历，并且递增之后前一个迭代器仍然可以解引用）
- 双向迭代器：可以双向移动，支持正向迭代器的所有特性。
- 随机访问迭代器：前四种只提供部分算术能力（前三种只支持operator++，第四种支持operator++和operator--），第五种支持p + n、p - n、p1 - p2，p1 < p2等。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-4-10.png" alt="image-20231017084549299" style="zoom:67%;" />

箭头表示概念与强化的关系。

为什么需要迭代器类型的概念：因为针对不同类型的迭代器，算法可能会有不同的效率。比如advance算法，接受一个迭代器参数和一个整数参数，功能是将迭代器p + n。如果是输入迭代器，只能递增n次，算法复杂度为O(n)；如果是双向迭代器，当n大于等于0时，递增n次，当n小于0时，递减n次，时间复杂度时O(n)；如果是随机访问迭代器，直接p + n，时间复杂度O(1)。
因此**算法中有时需要判断迭代器的类型**，对于不同的迭代器采取不同的处理方式。

想要使用迭代器类型，首先需要定义迭代器类型：

```c++
// 1.定义迭代器类型
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};
```

然后在迭代器类中声明迭代器类型，比如在一个迭代器中声明其类型为上述其中一种：

```c++
template <typename T>
class iteartor {
public:
    typedef input_iterator_tag iterator_category; // 这个迭代器类型就是输入迭代器
};
```

接着在萃取类iterator traits模板中根据传入的迭代器class type提取迭代器类型：

```c++
template <typename I>
struct iterator_traits {
    typedef typename I::iterator_category iterator_category;
}

// 针对原生指针偏特化的版本
template <class T>
struct iterator_traits<T *> {
    typedef random_access_iterator_tag iterator_category; // 原生指针是随机访问迭代器类型
}

// 针对指向常量的指针的特化版本
template <class T>
struct iterator_traits<const T *> {
    typedef random_access_iterator_tag iterator_category; // 原生指针是随机访问迭代器类型
}
```

最后如果需要获取迭代器类型，需要将算法的接口和实现分开，在接口中，接受迭代器对象并推断出迭代器的class type，根据这个参数实例化萃取类型模板并得到iterator_category；在实现中的参数中多接受一个迭代器类型参数，根据传入的实参推断类型：

```c++
// 算法对外接口
template <typename InputIterator, typename Distance>
inline void advance(InputIterator &i, Distance n) {
    // 第三个实参是获取迭代器内部声明的迭代器类型而创建的临时对象
    // 根据这个实参对象的类型选择调用哪个具体实现
    __advance(i, n, itrator_traits<InputIterator>::iterator_category());
}

// 算法真正实现
// 对于输入迭代器类型的实现
template <typename InputIterator, typename Distance>
inline void __advance(InputIterator &i, Distance n, input_iterator_tag) {
    // 单层递增
    while (n--) ++i;
}

// 对于正向迭代器类型的实现
template <typename InputIterator, typename Distance>
inline void __advance(InputIterator &i, Distance n, forward_iterator_tag) {
    // 单纯传递调用
    advance(i, n, input_iterator_tag());
}

// 对于双向迭代器类型的实现
template <typename InputIterator, typename Distance>
inline void __advance(InputIterator &i, Distance n, bidirectional_iterator_tag) {
    if (n >= 0) while (n--) ++i;
    else while (n++) --i;
}

// 对于随机访问迭代器类型的实现
template <typename InputIterator, typename Distance>
inline void __advance(InputIterator &i, Distance n, random_access_iterator_tag) {
    i += n;
}
```

上面的每一个__advance作为算法实际实现，其第三个参数只是为了激活编译器的函数重载机制，在算法中并不会使用，所有不需要形参名。

另外，STL标准中，**要以算法能够接受的最低阶的迭代器类型来为迭代器类型参数命名**。

为什么以在迭代器类型存在public继承：好处是可以消除传递调用版本的实现。例如上面例子中对于输入迭代器和正向迭代器的实现是相同的，那么可以只定义输入迭代器的实现，当参数为输入迭代器类型和正向迭代器类型时，会将正向迭代器类型隐式转换为其基类——输入迭代器类型。

## STL提供迭代器基类

为了符合规范，任何迭代器都应该提供五个嵌套相关类型声明，以方便traits进行萃取。

如果不想自己定义，STL定义了一个迭代器的基类iterator:

```c++
template <typename Category, typename T, typename Distance = ptrdiff_t, typename Pointer = T *, typename Reference = T &>
struct iterator {
	typedef Category	iterator_category;
    typedef T			value_type;
    typedef Distance	difference_type;
    typedef Pointer		pointer;
    typedef Reference	reference;
};
```

在这个标准基类中不存在任何成员，只是对于相关类型进行定义。后面三个类型都有默认参数，前两参数需要在定义自己的迭代器时声明，比如声明在3.2节自定义的ListIter：

```c++
template <typename Item>
stuct ListIter : public std::iterator<std::forward_iterator_tag, Item> {
    ...
};
```



**总结：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-5-1.png" alt="image-20231017092921462" style="zoom:67%;" />

## 对于源码的汇总

前面描述迭代器类型时分别描述如何实现，这里将所有类型汇总，并提供一些类型同名函数来返回类型。

详细看书。

## SGI STL的另一个技巧：__type_traits

iterator_traits主要是萃取迭代器的特性，而__type_traits主要是为了萃取类型的特性。

根据iterator_traits的特性，希望采取如下形式使用类型T的特性：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-7-1.png" alt="image-20231017101142590" style="zoom:67%;" />

希望得到的类型应该是真或者假。但是如果希望利用编译器进行参数类型的推导，那么就必须是一个对象。所以需要定义真类型和假类型：

```c++
struct __true_type {};
struct __false_type {};
```

为了定义上面五个特性，__type_traits类内必须定义一些typedef，SGI 在默认情况下定义为假类型：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-7-2.png" alt="image-20231017101517167" style="zoom:67%;" />

如果想要对于某种类型T定义某些特性为真类型，就必须提供上面模板的特化版本，比如对于内置类型chary提供特化（显式实例化）版本：

```c++
template <> struct __type_traits<char> {
	typedef __true_type		has_trivial_default_constructor;
    typedef __true_type 	has_trivial_copy_constructor;
    typedef __true_type		has_trivial_assimnment_operator;
    typedef __true_type 	has_trivial_destructor;
    typedef __true_type		is_POD_type;
};
```

类似的，如果想要针对自定义的类型，比如Test，萃取特性，需要提供一个Test特化版本的__type_traits：

```c++
template <> struct __type_traits<Test> {
    typedef __true_type		has_trivial_default_constructor;
    typedef __true_type 	has_trivial_copy_constructor;
    typedef __true_type		has_trivial_assimnment_operator;
    typedef __true_type 	has_trivial_destructor;
    typedef __true_type		is_POD_type;
}
```

使用时就可以根据类型获取特性类型，根据特性类型选择不同的处理方式。

参考2.3.2节的uninitialized_fill_n中，先使用value_type萃取出迭代器的value_type，也就是所指对象的类型；然后将value_type传递给__type_traits模板，得到实例化版本的类型声明：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-7-3.png" alt="image-20231017102941786" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-7-4.png" alt="image-20231017103049909" style="zoom:67%;" />

之后就可以根据type_traits的特性选择不同的处理方式：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\3-7-5.png" alt="image-20231017103316355" style="zoom:67%;" />

# 序列式容器

## 概述

容器就是保存数据对象的地方。

数据的特定排列方式（即数据结构）都是为了实现某种特定的算法。

常用的数据结构包括数组、链表、栈、队列、树、哈希表、集合、字典等。

STL的容器中存在衍生关系，也就是内含关系，比如stack和queue都内含一个deque。

待补充内含关系

### 序列式容器

序列式容器中的元素都可以排序，但是未必一定是有序的。

C++语言本身提供了一个序列式容器array，STL提供了vector、list、deque、stack、queue、priority-queue等，其中stack和queue是deque改头换面而成，技术上是一种配接器。



## vector

### 概述

vector的数据安排和操作方式与array非常类似，均是采用一块连续的存储空间排列数据元素。

二者的差别在于空间的灵活性：
array是静态空间，一旦申请了就不能改变。如果想要更换空间，就需要用户申请一块新的空间，然后将旧空间中的元素全部移动到新申请的空间，最后把原来的空间释放。
vector是动态空间，随着元素加入，内部机制会自行扩充空间以容纳新元素。

vector实现的关键技术就是对于空间大小的控制以及重新申请空间时的雄数据移动效率。

### vector源代码

书上列举了vector的实现源代码摘要。

### vector的迭代器

vector是一块连续线性空间，因此支持随机访问，又因为普通指针能够满足vector的迭代器要求，因此vector内部将原生指针声明为迭代器类型：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-1.png" alt="image-20231018090403169" style="zoom:67%;" />

```c++
// 定义vector的迭代器
vector<int>::iterator ivite;
vector<Shape>::iterator svite;

// 实际上ivite的类型就是 int *，svite的类型就是 Shape *
```

### vector的数据结构

vector的数据结构就是一段线性连续空间。以两个迭代器start和finish指向已经被使用的范围，以迭代器end_of_storage指向整块空间的尾端。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-2.png" alt="image-20231018090744171" style="zoom:67%;" />

这也表明vector的实际大小要比已经使用的大小要大，这是为了以后添加元素时尽量不用重新申请空间。因此实际大小称为capacity，已经使用的大小称为size。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-4.png" alt="image-20231018091657884" style="zoom:50%;" />

利用上述三个迭代器，很容易提供首尾标志、size、capacity、是否为空等接口：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-3.png" alt="image-20231018091313714" style="zoom:67%;" />

### vector的构造与内存管理

vector默认情况下以alloc作为空间配置器，基于此定义了一个data_allocator，以元素大小为申请空间单位。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-5.png" alt="image-20231018092309423" style="zoom:67%;" />

对于默认配置器alloc的allocate函数来说，是以字节为单位申请n个字节的内存；而外层的simple_alloc提供了一层包装，以元素类型为单位申请 sizeof(value_type) * n个字节的内存。

以其中一个构造函数为例：指定空间大小（以元素为单位）和初始值

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-6.png" alt="image-20231018093533086" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-7.png" alt="image-20231018093619878" style="zoom:67%;" />

经过重重传递调用，最终：1.调用分配器的allocate(n)申请n个元素空间；2.调用uninitialized_fill_n(first, n, x)函数，即使用x对象为[first, first + n)迭代器范围内的空间进行初始化。这里会根据迭代器指向的元素类型是否为POD来决定使用高阶算法fill_n还是不断为每一个位置调用construc来完成构造任务。



<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-8.png" alt="image-20231018094707759" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-9.png" alt="image-20231018094933439" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-10.png" alt="image-20231018095119458" style="zoom:67%;" />

这里需要注意的是，任何对于vector的操作，一旦引发了空间重新配置，那么指向原vector的所有迭代器均失效。（原空间已经被释放）

### vector的一些元素操作

#### pop_back

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-11.png" alt="image-20231018095716460" style="zoom:67%;" />

#### erase和clear

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-12.png" alt="image-20231018095940185" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-13.png" alt="image-20231018100216774" style="zoom:67%;" />

#### insert

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-14.png" alt="image-20231018100533612" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-15.png" alt="image-20231018104139435" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-16.png" alt="image-20231018154258933" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-17.png" alt="image-20231018154343842" style="zoom:67%;" />

插入完成之后，新的结点将位于哨兵迭代器（也就是指向position位置的迭代器）的前面。

下面对于插入操作进行演示，主要分成剩余空间足够和不够两种情况。

**1.当剩余空间足够时：**
剩余空间足够又分为两种情况，插入结点后面的元素个数（m）大于插入元素个数（n）和反之。
当m大于n时：
<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-18.png" alt="image-20231018155731188" style="zoom:67%;" />

当m小于等于n时：
<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-19.png" alt="image-20231018155807898" style="zoom:67%;" />
这样做的好处是少做了 n - m 次移动。

**2.当剩余空间不够时：**
<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-2-20.png" alt="image-20231019095723362" style="zoom:67%;" />



## list

### 概述

list与vector相比，主要区别是底层存储空间不同。vector使用连续存储结构表示线性表，list使用链式存储结构表示线性表。
使用链式存储结构的好处就是每次插入和删除一个元素，就配置或者释放一个元素空间。另外就是对于任何位置的元素插入和删除是常数时间。

### list的节点

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-1.png" alt="image-20231022092900641" style="zoom:67%;" />

### list的迭代器

因为list的存储结构并不是连续的，所以不能像vector一样使用普通指针作为迭代器完成随机存取。

list的迭代器需要具备的功能有：1.递增，指向下一个节点；2.递减，指向前一个结点；3.取值，解引用时取的是节点的数据；4.成员访问，成员访问时是节点的成员。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-2.png" alt="image-20231022093546612" style="zoom:67%;" />

由于STL中的list是双向链表。所以迭代器的类型是双向迭代器。

list迭代器与vector迭代器的不同：插入、删除和连接操作不会使原有的list迭代器失效（删除只会让被删除的迭代器失效），这是因为对于list的操作不会影响现有的空间，对于vector的任何操作有可能会导致空间重新分配。

list迭代器源代码：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-3.png" alt="image-20231022094054153" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-4.png" alt="image-20231022094217730" style="zoom:67%;" />

### list的数据结构

SGI的list是一个双向循环链表，因此只需要一个指针就可以表示整个链表。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-5.png" alt="image-20231022094420366" style="zoom:67%;" />

为了满足前闭后开区间的要求，这里需要让这个指针指向最后一个元素后面的一个空结点：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-6.png" alt="image-20231022094621428" style="zoom:67%;" />

由此便可以实现下面几个函数：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-7.png" alt="image-20231022094711960" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-8.png" alt="image-20231022094826598" style="zoom:67%;" />

### list的构造与内存管理

list默认使用alloc（默认是第二级配置器）作为空间配置器，并据此借助接口simple_alloc定义一个专属配置器list_node_allocator，方便以元素为单位申请空间。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-9.png" alt="image-20231022095322494" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-10.png" alt="image-20231022095342246" style="zoom:67%;" />

所以就可以使用list_node_allocator(n)表示申请n个节点的空间。下面四个函数用于配置、释放、构造、销毁一个节点：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-11.png" alt="image-20231022095744952" style="zoom:67%;" />



**以默认构造函数为例说明list的创建过程：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-12.png" alt="image-20231022100017648" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-13.png" alt="image-20231022100039139" style="zoom:67%;" />



当调用push_back()插入新元素时，该函数调用其中一个重载版本的insert函数：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-14.png" alt="image-20231022100216879" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-15.png" alt="image-20231022100253014" style="zoom:67%;" />

注意插入节点之后返回的是哨兵迭代器（插入点）的前方。

关于插入节点的操作顺序：

插入节点主要是对指针进行操作，这里的关键在于**修改指针之后要保证能够找到需要被操作的节点**，不要出现修改指针之后丢失节点问题。所以插入时进行每一步指针操作时都要考虑清楚这步操作完成之后能否找到需要被操作的节点。

以单链表为例，假如需要在节点P后面（单链表只有next指针所以只能在后面插入）插入一个节点S：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-21.png" alt="image-20231022155406548" style="zoom:67%;" />

这里一共有两个指针操作，即P的next指针和S的next指针。这两个操作的顺序是要有先后顺序的，一定是先让S的next指针指向P->next，然后再让P的next指针指向S。这里的原因是，我们目前可以明确知道P和S节点，获取未知节点（P->next）的唯一方法就是通过P的next指针。如果我们先修改P的next指针使其指向S，那么就丢失了获取P节点后面节点的方法。所以这里一定是先让S的next指针指向后面的节点，此时有两种方式（S->next和P->next）可以获取到后面的节点，所以接下来就可以修改其中一种方式（P->next）。

下面以双链表为例，假如需要在节点P之前插入一个新节点S：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-22.png" alt="image-20231022180633816" style="zoom:67%;" />

首先这里一共需要四个指针操作，分别是P->prev、T(P->prev)->next、S->next、S->prev。
这里需要注意的是，T是未知节点，目前只能通过P->prev来访问。所以如果想要更新这个指针，必须先增加一个指针指向T节点，也就是必须先令S->prev指向T，所以必须先更新S->prev才能更新P->prev。其它的操作顺序没有要求。
这里采用的顺序先确定从S节点出去的指针，即S->next和S->prev；再确定指向S节点的指针，即T->next和P->prev。






### list的一些元素操作

#### 插入和删除操作

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-16.png" alt="image-20231022104056753" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-17.png" alt="image-20231022104231361" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-18.png" alt="image-20231022104506672" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-19.png" alt="image-20231022104528183" style="zoom:67%;" />

#### 迁移操作

list内容提供一个迁移操作：将某段连续范围的元素迁移到某个指定位置之前。这个操作为其它复杂操作如splice、sort、merge提供了基础。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-20.png" alt="image-20231022111956967" style="zoom:67%;" />

对于迁移操作，一共需要操作6个指针。需要将范围[first, last - 1]插入到P节点之前，这是4个指针的操作；还需要将first - 1的节点与last节点相连，这是2个指针的操作。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-24.png" alt="image-20231023210851380" style="zoom: 80%;" />

这里需要明确的是，涉及的节点一共有5个，已知的是P、first、last，不能直接取得的是P - 1(P->prev)、firs - 1(first->prev)、last - 1(last->prev)，再修改这些指针之前一定要保证存在另一个指向这个节点的指针。但是这里注意，由于firs - 1(first->prev)需要指向P - 1(P->prev)，所以这里一定是需要一个临时指针取保存其中一个的。因此6次指针再加一次保存临时指针的操作，一共是7个操作。
下面对于这7次操作的顺序进行演示，这里的逻辑是：先连通一个方向（保证first-1 ->last和P-1->first->...->last - 1->P），再连通另一个方向（last->first-1和P-1->last-1 -> ...->first->P-1）。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-23.png" alt="image-20231023210828563" style="zoom:67%;" />

上面的transfer并不是对外接口，对外的接口是接合操作splice：将某连续范围的元素从一个list移动到另一个（或同一个list）的某个定点。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-25.png" alt="image-20231023211156558" style="zoom:67%;" />

为了提供各种接口的弹性，splice有许多版本：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-26.png" alt="image-20231023212140513" style="zoom:67%;" />



merge函数：将另一个链表合并到当前链表上。这里要求两个链表已经经过递增排序。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-27.png" alt="image-20231023212545025" style="zoom:67%;" />



reverse函数：将list逆向

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-3-28.png" alt="image-20231023212921145" style="zoom:67%;" />



sort函数：采用归并排序算法

<img src="D:\Blog\MyBlog\source\_posts\STL源码剖析\【STL源码剖析】系列五：序列式容器-list\4-3-29.png" alt="image-20231024093656997" style="zoom:80%;" />

## deque

### 概述

vector是单向开口的连续线性空间，deque是双向开口的连续线性空间。

即deque可以在头尾两端做插入和删除操作。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-1.png" alt="image-20231025085128304" style="zoom:67%;" />

deque与vector的差异在于：1.deque可以在常数时间内对头端进行插入和移除；2.deque没有容量的概念，它的底层存储空间是由分段的连续存储空间组合而成，也就是随时可以动态申请一段新的空间连接在头部或者尾部。

deque的迭代器也是随机存取迭代器，但是由于其分段的连续存储空间结构，它的迭代器不能是普通指针，具有复杂的处理结构。因此，尽可能使用vector而不是deque。对于deque的一些操作比如排序，为了效率更高可以将deque中的元素复制到vector中，在vector排序之后再复制回deque。

### deque的中控器

连续线性存储空间一般都不能动态增长，比如array。vector之所以可以实现动态增长，而且只能尾部增长，其实也是一种假象，实际上是：1.重新分配存储空间；2.复制原数据；3.释放原空间 三个步骤完成，只是对外隐藏细节。vector在每次动态增长空间之后都会留下一些富裕空间，否则动态增长带来的代价非常昂贵。

deque实际上是**由一段一段的定量连续空间**组成。如果需要在deque的前端或者后端增加新的空间，就需要申请一段**定量连续空间**，连接在deque的头部或者尾部。deque的关键任务就是**维护这些多段定量连续空间**，并对外**提供随机存取的接口**。

deque采用map作为中控器来维护这些多段定量连续空间。map本身是一段连续存储空间，其中每一个元素都是一个指针，指向一段连续存储空间，称为缓冲区。缓冲区默认大小为512bytes。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-2.png" alt="image-20231025090521784" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-3.png" alt="image-20231025090617283" style="zoom:67%;" />

实际上map就是一个T**，即map是一个指针，指向一块连续空间，连续空间中存放着多个指针，每一个指针指向一个缓冲区。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-4.png" alt="image-20231025090911757" style="zoom: 67%;" />

### deque的迭代器

deque的两个关键任务，一是维护多段定长连续存储空间（缓冲区），由map中控器完成；二是对外提供随机存取接口，由迭代器完成。

为了维护deque整体是一段连续空间的假象，迭代器的operator++和operator--必须对外表现出连续的假象。因此，对于一个迭代器来说，它必须知道：1.当前缓冲区（连续空间）的位置；2.处在当前缓冲区的哪个位置，方便判断是否处在边缘，如果是变换，那么operator++和operator--就必须跳跃到下一个缓冲区或上一个缓冲区；3.为了实现在缓冲区之间的跳跃，迭代器还必须借助map

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-5.png" alt="image-20231025091945232" style="zoom:67%;" />

这里的用于获取缓冲区大小的函数**buffer_size**调用的式全局函数：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-6.png" alt="image-20231025092106298" style="zoom:67%;" />

如果n不为默认值0，说明缓冲区大小由用户定义，返回n；
如果n为默认值0，说明缓冲区大小使用默认值512字节，如果元素类型大小sz小于512，则返回512/sz(即一个缓冲区中有多少个元素)，否则传回1(说明缓冲区大小装不下一个元素)。

下图式deque的中控器、缓冲区和迭代器的关系：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-7.png" alt="image-20231025092405827" style="zoom:67%;" />

下面是deque迭代器的几个关键行为。

**跳跃缓冲区：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-8.png" alt="image-20231025093744548" style="zoom:67%;" />



**重载运算符：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-9.png" alt="image-20231025093851188" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-10.png" alt="image-20231025094147462" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-11.png" alt="image-20231025094239647" style="zoom:67%;" />



**实现随机存取：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-12.png" alt="image-20231025095933261" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-13.png" alt="image-20231025100259278" style="zoom:67%;" />

如果offset是正数很好理解，如果是负数，需要理解以上红线标注的部分：

![image-20231025111548447](D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-15.png)

需要计算中间红色部分占据多少个缓冲区，其中的节点个数为 -offset - 1，减去的是offset这个位置。
接着整除buffer_size，得到中间间隔的缓冲区个数。
得到缓冲区个数取负再减去1到达offset所在的缓冲区。



**其它一些运算：**基本上只要基础上面的operator+=运算即可。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-14.png" alt="image-20231025100555023" style="zoom:67%;" />

### deque的数据结构

deque处理维护一个指向map中控器的指针外，还需要维护start、finish两个迭代器，分别指向第一个缓冲区的第一个元素和最后一个缓冲区的超尾元素。
同时还需要一个记录当前map大小的量，这样才能在map节点不够时重新配置更大的一块map。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-16.png" alt="image-20231025113254946" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-17.png" alt="image-20231025113349636" style="zoom:67%;" />



有了这几个量，下面函数便可以实现：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-18.png" alt="image-20231025114035896" style="zoom:67%;" />



### deque的构造与内存管理

deque内部定义了两个专属的空间配置器，一个用于每次配置一个元素大小的空间，一个用于每次配置一个指针大小的空间。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-19.png" alt="image-20231025114724915" style="zoom:67%;" />

以一个构造函数为例说明如何配置空间：构造函数创建n个value元素。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-20.png" alt="image-20231025114906751" style="zoom:67%;" />

内部调用**fill_initialize**来生成一个deque。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-21.png" alt="image-20231025115244348" style="zoom:67%;" />

其中**create_map_and_nodes**函数创建map以及缓冲区：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-22.png" alt="image-20231025115823337" style="zoom: 80%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-23.png" alt="image-20231025115935051" style="zoom:80%;" />

**push_back：**

在向尾端插入元素时，如果最后一个缓冲区还有备用空间，即除了一个超尾元素之外还有剩余空间，那么就直接在备用空间上构造元素：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-24.png" alt="image-20231025151540937" style="zoom:67%;" />

如果最后一个缓冲区无备用空间或者只剩一个空间，就需要调用**push_back_aux**函数：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-25.png" alt="image-20231025152217534" style="zoom:67%;" />

**push_front：**

在deque的前端插入元素，如果前端有备用空间就直接进行构造；如果前端没有备用空间就需要重新申请一块缓冲区：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-26.png" alt="image-20231025152449082" style="zoom:67%;" />

即调用**push_front_aux**函数完成重新申请缓冲区的操作：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-27.png" alt="image-20231025152612008" style="zoom:67%;" />



**map的重新整治：**

在后端插入时，如果只剩一个备用空间时就会调用push_back_aux，在重新申请一个缓冲区之前会调用**reserve_map_at_back()**调整map；

在前端插入时，如果前面没有备用空间就会调用push_front_aux，在重新申请一个缓冲区之前会调用**reserve_map_at_front()**调整map。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-28.png" alt="image-20231025153235067" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-29.png" alt="image-20231025153256329" style="zoom:67%;" />

实际上就是当map指针数组中的指针都使用完时，就必须重新申请一个更大的map指针数组。这个工作由**reallocate_map**完成：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-30.png" alt="image-20231025154123738" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-31.png" alt="image-20231025154358390" style="zoom:67%;" />

### deque的一些常见操作

#### pop_back和pop_front

**pop_back:**
当最后一个缓冲区有一个或者更多元素时（每个迭代器的cur指向的是当前缓冲区最后一个元素的后一个元素），摧毁最后一个元素即可；否则就需要先删除最后一个缓冲区，再执行销毁最后一个元素操作。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-32.png" alt="image-20231025155113511" style="zoom:67%;" />

**pop_front：**

与上面的思路类似：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-33.png" alt="image-20231025155216747" style="zoom:67%;" />

#### clear和erase

**clear：**

用于清除整个deque。deque最初状态下保留一个缓冲区，所以清除之后也要保留一个缓冲区：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-34.png" alt="image-20231025155539293" style="zoom:67%;" />



**erase：清除一个元素的版本**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-35.png" alt="image-20231025160232419" style="zoom: 67%;" />

**erase：清除[first, last)范围内的元素**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-36.png" alt="image-20231025170525563" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-37.png" alt="image-20231025170609651" style="zoom:67%;" />



#### insert

insert再deque中存在许多版本，下面主要介绍这个版本：再某个点之前插入一个元素：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-38.png" alt="image-20231025170719998" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-39.png" alt="image-20231025170738897" style="zoom:67%;" />

如果是头部和尾部就交给push_front和push_back去做，否则由**inset_aux**函数完成：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-40.png" alt="image-20231025171114665" style="zoom: 80%;" />

如果前面元素比较少，插入过程如图：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-41.png" alt="image-20231025173624704" style="zoom:80%;" />

如果后面元素比较少，插入过程如图：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-4-42.png" alt="image-20231025174730115" style="zoom:80%;" />





## stack

### stack概述

stack（栈）是一种先进后出的数据结构。栈只有一个出口，只能在这个出口进行添加元素（push）、删除元素（pop）、获取最顶端元素（top）。

除了上述三种操作之外，不允许有其它操作存取栈的其它元素，即不允许遍历行为。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-5-1.png" alt="image-20231026203258256" style="zoom:67%;" />

### stack完整实现

从上述结构图可以发现，如果**以deque作为底层数据结构**，然后限制其**只能在一个端口进行操作**，就可以轻易完成stack的实现。

因此，SGI STL以deque作为默认情况下的stack的底层结构。

（实际上，stack是在deque的基础上修改其对外接口，这种设计模式称为适配器（配接器）模式。即在内部以组合方式包含deque，但是在stack中对外提供不同的接口）

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-5-2.png" alt="image-20231026203947177" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-5-3.png" alt="image-20231026204421812" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-5-4.png" alt="image-20231026204547507" style="zoom:67%;" />

### stack不提供迭代器

stack的所有元素进出都必须符合“先进后出”，只有顶端元素可以被外接访问。所以不提供遍历功能。

### 以list作为stack的底层容器

由于list也是双向开口的数据结构。上面调用的底层容器deque的函数有empty、size、back、push_back、pop_back，这些list也都具备，所以如果以list作为底层结构一样可以形成一个stack。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-5-5.png" alt="image-20231026204933615" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-5-6.png" alt="image-20231026204954843" style="zoom:67%;" />

## queue

### queue概述

queue（队列）是一种先进先出的数据结构。

队列有两个端口，其中一个端口（尾端）只能用于新增元素（push）和查看尾端（back），另一个端口（首端）只能用于删除元素（pop）和查看首端（front）。

队列中的元素除了上面的操作之外不允许进行存取，即queue不允许遍历。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-5-7.png" alt="image-20231026205406254" style="zoom:67%;" />

### queue完整实现

同stack一样，queue也可以将deque作为底层容器，在其基础上对外限制两端操作即可实现queue。

因此SGI STL以默认情况下以deque作为queue的底层结构。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-5-8.png" alt="image-20231026205706299" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-5-9.png" alt="image-20231026205726593" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-5-10.png" alt="image-20231026205746334" style="zoom:67%;" />

### queue没有迭代器

与stack类似，queue所有元素进出都必须符合“先进先出”，所以必须限制对于内部元素的访问，因此不提供迭代器。

### 以list作为queue的底层容器

上述实现中可以看出queue需要底层容器提供的接口有empty、size、front、back、push、pop，这些list也能提供，所以可以把list作为底层容器：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-5-11.png" alt="image-20231026210020843" style="zoom:67%;" />







## heap

### heap概述

heap并不是一种STL容器，引入它的目的是为了实现priority queue（优先级队列）。

优先级队列允许用户以任何次序将元素装进容器内部，但是取出时一定是将优先级最高的元素先取出。而大顶堆恰好具有这样的性质，因此STL中实现的是大顶堆。

堆的定义是：一颗具有如下性质的完全二叉树：每个节点的值都大于或等于其左右孩子的值，称为大顶堆；每个节点的值都小于或等于其左右孩子的值，称为小顶堆。

完全二叉树具有这样的性质：假设一共有n个元素，下标从1~n，那么对于一个节点 i 来说（i 大于等于1，小于等于n / 2），其左孩子的下标为2i，右孩子的下标为2i + 1，其父节点的下标为i/2。因此可以使用vector来保存完全二叉树的n个节点。（使用vector是因为array不具有动态改变大小的功能，而一个堆增加元素时可能需要动态增长空间。）

综上，实现一个堆需要一个vector作为底层容器，以及一组heap算法来调整其中的元素顺序。



### heap算法

#### push_heap算法

当向堆中插入一个元素时，首先将这个元素插入到最后一层的从左到右的第一个空位置上，也就是底层容器vector的end()处。

插入之后，需要调整这个新元素的位置，让其满足大顶堆的定义。因此执行一个上溯的过程：将新节点与父节点比较，如果值比父节点大，就父子对换位置；这样一直上溯，直到不需要对换或者直到根节点为止。

下面是push_heap算法细节，接受两个迭代器，分别表示底层容器vector的头和尾，并且假设新元素已经在vector的尾：
<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-6-1.png" alt="image-20231106212052557" style="zoom: 67%;" />
<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-6-2.png" alt="image-20231106213221868" style="zoom:67%;" />

关于上面计算父节点序号的解释：
这里first迭代器作为序号1，0号位置为空。这里 first + holdIndex为最后一个元素的位置。
此时有：（1）(first + holdIndex)  / 2 = P;(2)(holdIndex - 1) / 2 = parent;(3)P = first + parent
因为first为1，因此可以得到（3）等式两边是相等的。

**这样做的好处是：如果使用两个迭代器来进行运算，中间会涉及到很多次迭代器加减运算；如果使用两个下标进行运算，仍然需要通过迭代器找到相应的元素；所以这里采用的是一个迭代器（first）和一个下标（holdIndex）的方式。**

#### pop_heap算法

当从堆中取出一个元素时，由于这里是大顶堆，因此一定是取关键值最大的元素，而这个元素一定在根部，也就是第一个元素。

将这个元素取出实际上是将其移动至底层容器的最后一个位置，而原来在这个位置上的元素（堆的最下一层的最右元素）需要重新找到一个合适的位置。这里执行一个下溯程序：将原本在底层容器的最后位置的元素（也就是堆的最下一层的最右元素）填充至根节点的位置，然后与两个孩子节点比较值，与较大的值对换；然后更新位置，重新比较，直到两个孩子的值均小于当前父节点。

下面是pop_heap算法细节，接受两个迭代器，分别指向底层容器vector的头和尾：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-6-3.png" alt="image-20231107090031124" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-6-4.png" alt="image-20231107090241139" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-6-5.png" alt="image-20231107090651889" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-6-6.png" alt="image-20231107092320650" style="zoom:67%;" />

注：我不同意侯捷先生的说法。这是因为在while循环结束之后的这一段代码的缘故：首先，循环结束时，first+holdIndex指向的是需要被插入的结点位置，此时只可能有两种情况：

![image-20231107093359555](D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-6-7.png)

如果是上图左边的情况，循环结束的代码什么也不做，可以直接令value插入到holdindex的位置；
如果是上图右边的情况，循环结束时的代码就会使得holdIndex移动到左孩子的位置，令左孩子为根结点的值。注意，这里len的位置最开始时就是value的位置（此时是原来根节点也就是最大值的位置），value与其左兄弟之间的大小不可知，但是循环结束的代码强制令holdIndex的位置移动到左孩子的位置，因此需要调用push_heap函数，这个函数会尝试比较value和其根节点的大小，调整其位置。

总结，当pop_heap之后，最大的元素放在了底层容器的尾端，并没有被取走。如果想要取值，可以调用vector的back函数，如果想要移除，可以调用vector的pop_back函数。

#### sort_heap算法

从上面的pop_heap算法可以知道，每次取最大的元素放在最后的位置。如果持续对于整个堆进行pop_heap操作，每次操作范围从后向前缩减一个元素，那么当结束时，就可以得到一个递增序列。（这里其实就是堆排序的思想）

下面是sort_heap的算法细节，同样是接受两个迭代器，分别表示底层容器vector的头尾：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-6-8.png" alt="image-20231107094734841" style="zoom:67%;" />

注意，sort_heap之后，此时已经不再是一个堆，而是一个递增序列。

#### make_heap算法

该算法就是将一段数据转换为一个堆。（也就是堆排序中对于待排序序列构造堆的过程）

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-6-9.png" alt="image-20231107095041635" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-6-10.png" alt="image-20231107095410296" style="zoom:67%;" />

### heap没有迭代器

heap中的所有元素都遵循特定的排列规则，所以不允许遍历，因此不提供迭代器。

### 补充：堆排序算法

堆排序算法分为两部分：首先将数据转换为堆，然后一个循环不断调整元素顺序。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-6-11.png" alt="9-6-8" style="zoom:67%;" />

注1：假设有n个节点需要构成一个堆，那么根据二叉树的第5个性质，第n个节点的父亲节点一定是n / 2向下取整，也就是所有的父亲节点数目。

注2：构建堆时，从最后一个父亲节点开始构造，也就是从下向上、从右向左的顺序。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-6-12.png" alt="image-20231106204337374" style="zoom:50%;" />

比如上面这张图，按照分别以30、90、10、50为节点进行构造堆，也就是第4、3、2、1个节点作为根节点构造堆。

**将无序序列调整为堆：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-6-13.png" alt="image-20230412211721295" style="zoom:67%;" />

**时间复杂度分析：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-6-14.png" alt="image-20230412213353648" style="zoom: 67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-6-15.png" alt="image-20230412213410970" style="zoom: 67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-6-16.png" alt="image-20230412213453004" style="zoom: 67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-6-17.png" alt="image-20230412213645682" style="zoom: 67%;" />



## prority_queue

### 概述

优先级队列带有权值概念，其中的元素不是按照推入的次序排列，而是按照元素的权值（通常权值以实值表示）排列，权值最高排在前面。

默认情况下优先级队列使用一个大顶堆完成，大顶堆的底层实现是由一个vector表现的完全二叉树。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-7-1.png" alt="image-20231107150303639" style="zoom:67%;" />

### priority_queue完整定义

优先级队列的实现由底层容器和heap算法处理完成，所以实现非常简单。默认情况下底层容器是vector。

（由于优先级队列也是在底层容器的基础上修改对外接口，因此优先级队列也是一种配接器）

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-7-2.png" alt="image-20231107151131675" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-7-3.png" alt="image-20231107151418334" style="zoom:67%;" />

### priority_queue没有迭代器

由于优先级队列中的元素按照一定的规则排列，因此不允许遍历，也就不提供迭代器。

## slist

### 概述

slist是SGI STL提供的一种单向链表（single linked list）。

slist与list的主要差别是，前者的迭代器是单向迭代器，后者的迭代器属于双向迭代器。

slist与list共同特点是，由于每个元素都被装在一个节点中，因此插入（insert）、移除（erase）、接合（splice）等操作不会使得原有的迭代器失效。

STL的习惯是插入操作将新元素插入指定位置之前，但是作为一个单向链表，slist没有方便的方法可以向前空出一个位置，因此它必须从头开始查找。所以对于slist而言，除了起点附近的区域，在其它位置采用插入或者删除操作都是不合适的。（对于list而言在任何位置插入都是可以的）基于同样的效率考虑，slist不提供push_back，只提供push_front。

### slist的节点

slist的节点与迭代器的设计比list复杂很多，使用了继承关系，所以在类型转换上有复杂的表现。下图是slist节点和迭代器的设计架构：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-8-1.png" alt="image-20231107154029724" style="zoom:67%;" />



下面是slist的节点结构：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-8-2.png" alt="image-20231107154313214" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-8-3.png" alt="image-20231107154336804" style="zoom:67%;" />

### slist的迭代器

slist的迭代器为单向迭代器，因此只能递增：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-8-4.png" alt="image-20231107154724220" style="zoom:67%;" />

**base迭代器结构：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-8-5.png" alt="image-20231107154953870" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-8-6.png" alt="image-20231107155014812" style="zoom:67%;" />



**派生的迭代器结构：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-8-7.png" alt="image-20231107155446072" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-8-8.png" alt="image-20231107155515618" style="zoom:67%;" />

判断两个slist的迭代器是否相等，最终会调用base迭代器的operator==，即最终是判断两个迭代器拥有的成员指针是否指向同一个元素。

### slist的数据结构

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-8-9.png" alt="image-20231107161940839" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-8-10.png" alt="image-20231107162154849" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-8-11.png" alt="image-20231107162338716" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-8-12.png" alt="image-20231107162528808" style="zoom:67%;" />

### slist的元素操作

实际上slist也提供了insert等操作，上面源代码介绍中并没有包含，这是因为其它操作效率比较低，不是slist常用的操作。

这里另外需要注意的是，slist的end()函数是构造了一个临时迭代器对象，这个临时迭代器对象成员指针是一个空指针，与正常的迭代器不同：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\4-8-13.png" alt="image-20231107163231968" style="zoom:67%;" />



# 关联式容器

标准的STL关联式容器可以分为set（集合）和map（映射表），以及这两大类的衍生容器multiset（多键集合）和multimap（多键映射表）。这些容器的底层机制都是以RB-tree（红黑树）完成。

另外，SGI STL还提供不在规格之内存的关联式容器：hash table（散列表），以及以散列表为底层机制实现的hash_set、hash_map、hash_multiset、hash_multimap。（对应于C++11中的无序关联式容器：unordered_set、unordered_map、unordered_multiset、unordered_multimap）。

关联式容器指的就是每个元素都有一个键（key）和一个值（value），当元素进入到关联式容器中时，根据键并依照某种规则将元素放置于适当位置。

关联式容器内部结构一般是一个平衡二叉树，这是为了获得良好的搜索效率。平衡二叉树具有多种类型，包括AVL-tree、RB-tree、AA-tree，其中STL中使用的是RB-tree。

## 树与AVL树

### 二叉搜索树

**二叉搜索树**也称为二叉排序树、二叉查找树，定义为具有以下性质的二叉树：

- 若左子树不空，那么左子树上所有节点的值均小于根节点的值；
- 若右子树不空，那么右子树上所有节点的值均大于根节点的值；
- 左右子树也均为二叉搜索树

**二叉搜索树的查找操作：**

从根节点开始逐个与目标值进行比较，如果当前根节点的值大于目标值，就递归从左子树查找；如果当前根节点的值小于目标值，就递归从右子树查找。

**二叉搜索树的插入操作：**

插入一个新元素时，从根节点开始，遇到值较大就向左子树，遇到值小就向右子树，直到尾端就是插入位置。

**二叉搜索树的删除操作：**

如果要删除一个节点A，分为两种情况：（如果A是叶子节点可以直接删除）

（1）A只有一个子节点，直接将A的子节点连接到A的父节点，然后删除A；

（2）A有两个子节点，以A的右子树的最小值取代A，也就是A的右子树的最左叶子节点。

查找速度取决于二叉排序的层数，但是二叉排序树的形状是不确定的。比如：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-1-1.png" alt="image-20230411164120634" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-1-2.png" alt="image-20230411164136146" style="zoom:50%;" />

### 平衡二叉搜索树--AVL树

**树的一些相关定义：**

树的根节点到任何节点之间有一条唯一的路径，路径所包含的边数称为路径长度。

一个节点的深度指的是根节点到该节点的路径长度。

一个节点的高度指的是该节点到其最深子节点（叶子节点）的路径长度。

由于二叉搜索树的查找效率取决于节点所在的层数，因此所有节点的深度均不会太大就会使得总体的查找效率比较低。这也就是**平衡二叉树**的思想。

**AVL-tree的平衡条件**是任何节点的左右子树的高度差最多为1。左子树深度减去右子树深度称为平衡因子，平衡树的平衡因子只有可能是1（左子树比右子树深）、0（左子树和右子树一样深）、-1（右子树比左子树深）

这里需要引入一个最小不平衡子树的概念：距离插入节点最近的，并且以平衡因子的绝对值大于1的节点为根的子树，称为最小不平衡子树。如果插入新节点导致不平衡，只需调整最小不平衡子树即可。

**AVL-tree的单旋转与双旋转**

- 当最小不平衡子树根节点的BF大于1时，右旋；
- 当最小不平衡子树根节点的BF小于-1时，左旋。

（左旋和右旋均只涉及一些指针操作，比较简单，以右旋为例：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-1-5.png" alt="image-20230411165107253" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-1-4.png" alt="image-20230411165131157" style="zoom:67%;" />

同时需要注意，当插入结点之后，最小不平衡子树根节点的BF与它的子树的BF符号相反时，需要先对**子树**进行旋转使得子树与根的BF符号相同之后，再对**根节点**进行一次**反向旋转**之后才能平衡。

注1：什么时候最小不平衡子树根节点的BF与它的子树的BF符号相反？什么时候相同？
左左（插入点位于最小不平衡子树根节点的左子节点的左子树）和右右（插入点位于最小不平衡子树根节点的右子节点的右子树）BF符号相同：以左左为例，根的BF为2，左子节点的BF为1；

左右（插入点位于最小不平衡子树根节点的左子节点的右子树）和右左（插入点位于最小不平衡子树根节点的右子节点的左子树）BF符号不同：以左右为例，根的BF为2，左子节点的BF为-1.

注2：以左右为例说明**双旋转**的过程：根据根节点的BF为2判断应该进行**右旋**，但是检查左子节点的BF为-1，所以应该先对左子节点进行左旋（因为左子节点的BF是负数），再对根节点进行**右旋**。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-1-3.png" alt="image-20231108094714363" style="zoom:67%;" />



## RB-tree（红黑树）

RB-tree的定义，不仅是一个二叉搜索树，还必须满足以下规则：

1.每个节点不是红色就是黑色；

2.根节点为黑色；

3.如果节点为红，子节点必须为黑色；

4.任一节点到NULL（树尾端）的所有路径，所包含的黑节点的数目必须相同。

默认NULL节点为黑色。

根据规则4，新增节点必须为红：如果新增一个黑色节点，那么其父节点经过这个新增节点到达NULL的黑节点数目一定大于经过其它路径到达NULL的黑节点数目。

根据规则3，新增节点的父节点一定是黑色：因为新增节点为红色，因此父节点不能为红（父子不能同时为红）

当新节点根据二叉搜索树的规则到达插入点，却不能符合上面的规则时，需要调整颜色和旋转树形。

**补充内容：**

红黑树能保证：其最长路径中节点个数不会超过最短路径节点个数的两倍。因为最短路径就是全黑，最长路径就是红黑节点交替，因为每条路径的黑色节点数目都相同，所以最长路径就刚好是最短路径的两倍。

也就是说，相比于AVL树，RB树并不严格追求绝对平衡。

### 红黑树的插入操作

红黑树是在二叉搜索的基础上进行平衡，因此红黑树的插入步骤可以分为两步：1.按照二叉搜索树的规则找到插入点；2.判断新节点插入之后是否破坏红黑树的条件。

新节点插入时默认是红色，如果其父节点是黑色，那么无需做任何调整，因为没有违反红黑树的性质；如果**父节点是红色**，就违反了性质3，需要进行调整，调整分为以下几种情况：

**父亲为祖父的左儿子：**

情况一：父亲和叔叔都是红色，此时无论X是父节点的左孩子还是右孩子，均进行以下调整：
（1）父亲和叔叔变为黑色，满足规则3：父子不能同时为红；叔叔需要变成黑色是因为需要保证叔叔和父亲的路径上黑色数目需要相同
（2）祖父变成红色，满足规则4：因为父亲和叔叔都是黑色，黑色的高度发生了变化，如果祖父还是黑色，会导致这条路径上黑色数目比原来增加；
（3）从祖父开始，继续进行调整，这是为了防止曾祖父为红色，出现祖父和曾祖父同时为红色的情况。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-1.png" alt="image-20231108153803573" style="zoom: 80%;" />

情况二：叔叔是黑色（如果叔叔不存在，即为NULL节点，也默认为黑色），自己是父亲的左孩子：
（1）父亲变成黑色，祖父变成红色。此时右子树的黑色高度减少；
（2）对祖父进行**右旋**，令父节点称为新的祖父，这样右子树的黑色高度得以恢复.

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-2.png" alt="image-20231108154129372" style="zoom:80%;" />

情况三：叔叔是黑色（如果叔叔不存在，即为NULL节点，也默认为黑色），自己是父亲的右孩子：
（1）对父亲进行左旋操作，使得父亲成为新的X，此时称为上面情况二；
（2）按照情况二进行处理。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-3.png" alt="image-20231108154555941" style="zoom:80%;" />

**父亲为祖父的右儿子：**

情况一：父亲和叔叔都是红色，此时无论X是父亲的左孩子还是右孩子，均进行以下处理：
（1）父亲和叔叔都变成黑色，保证父亲不会与孩子X同时为红色。叔叔也需要变成黑色是因为需要保证叔叔和父亲的路径上黑色数目需要相同；
（2）祖父变成红色，满足规则4：因为父亲和叔叔都是黑色，黑色的高度发生了变化，如果祖父还是黑色，会导致这条路径上黑色数目比原来增加；
（3）从祖父开始继续调整，这是为了防止曾祖父为红色，出现祖父和曾祖父同时为红色的情况。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-4.png" alt="image-20231108155505164" style="zoom:80%;" />

情况二：叔叔是黑色，自己是父亲的右孩子：
（1）父亲变成黑色，祖父变成红色，此时左子树的黑色高度降低；
（2）对祖父进行左旋操作，恢复左子树的黑色高度。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-5.png" alt="image-20231108155643934" style="zoom:80%;" />

情况三：叔叔是黑色，自己是父亲的左孩子：
（1）对父亲进行右旋操作，使得父亲成为新的X，构造上面情况二；
（2）按照情况二进行处理。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-6.png" alt="image-20231108155801673" style="zoom: 80%;" />

**总结：**

当父亲为祖父的左孩子时：父叔同色，只进行变色；父叔异色，自己是左孩子，进行R操作；父叔异色，自己是右孩子，进行LR操作；

当父亲为祖父的右孩子时：父叔同色，只进行变色；父叔异色，自己是右孩子，进行L操作；父叔异色，自己是左孩子，进行RL操作。

### 针对父叔同色的改进

当父叔同色时，对祖父和父叔进行颜色修改之后，需要继续向上对曾祖父进行同样的处理。为了避免自下而上的处理，可以进行一个自上而下的处理：假设新增节点为A，那么验证从根节点到A的路径，只要发现**某个节点X**的两个子节点都是红色，就将X改为黑色，两个子节点改为黑色。

这样处理之后，如果这个**节点X**的父节点是红色（此时叔叔不可能是红色，因为上一步中已经把叔父同时为红的情况处理掉了），就需要将X节点视作新增节点，按照情况二（1次旋转）或三（2次旋转）进行处理。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-7.png" alt="image-20231108195146250" style="zoom: 50%;" />

处理完所有X节点之后，就可以对**新增节点A**进行处理，此时要**么直接插入**（新增节点的父节点是黑色），要么插入后进行一次单旋转（新增节点的父节点是红色，叔叔一定是黑色）。
不理解为什么作者说一定是一次单旋转，上面的处理过程并不能保证父节点一定是祖父的左孩子还是右孩子，而插入位置也不能保证是父节点的左孩子还是右孩子，因此我认为有可能需要进行两次旋转。

### 红黑树的节点设计

STL红黑树的节点分为一个base类和一个派生类：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-8.png" alt="image-20231108195547831" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-9.png" alt="image-20231108195757492" style="zoom:67%;" />

红黑树的节点示意图：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-10.png" alt="image-20231108195857546" style="zoom:80%;" />

### 红黑树的迭代器

红黑树的迭代器同样采用继承的架构，分为base迭代器和派生迭代器，两层迭代器与节点之间的关系为：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-11.png" alt="image-20231108201453628" style="zoom:67%;" />

红黑树的迭代器属于双向迭代器，其解引用和成员访问操作与list相似，比较特殊的是前进和后退操作。RB-tree迭代器的operator++和operator--操作分别调用基类迭代器的increment和decrement方法。

**基类迭代器实现：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-12.png" alt="image-20231108201751919" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-13.png" alt="image-20231108201908231" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-14.png" alt="image-20231108202927600" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-15.png" alt="image-20231108203539919" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-16.png" alt="image-20231108203606839" style="zoom:67%;" />

在实现时，会在树的根节点上多增加一个header节点，这个节点作为根节点的父节点，并且header的父节点就是根节点。header节点的左孩子是二叉排序树的第一个元素，右孩子是二叉排序树的最后一个元素。同时header也作为end()，左孩子是begin()。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-19.png" alt="image-20231108210025242" style="zoom:67%;" />

increment函数中的情况4：当迭代器指向根节点时，并且根节点没有右孩子，也就是没有直接后继，此时node指向的是根节点，经过while循环处理之后node指向header，y指向根节点，因此node->right就等于y，因此node就是最终结果。

decrement中情况1：当迭代器指向end也就是heaher时，减一操作应该指向header的右孩子，也就是二叉搜索树的最后一个值。

**红黑树的迭代器：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-17.png" alt="image-20231108205828143" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-18.png" alt="image-20231108205844531" style="zoom:67%;" />

### 红黑树的数据结构

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-20.png" alt="image-20231108210901044" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-21.png" alt="image-20231108211223017" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-22.png" alt="image-20231108211342864" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-23.png" alt="image-20231108211553220" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-24.png" alt="image-20231108211801641" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-25.png" alt="image-20231108211931545" style="zoom:67%;" />

### 红黑树的构造与内存管理

通过上面的源代码可以看出，红黑树的构造分为两种，一种是以现有的红黑树赋值一个新的红黑树，另一种就是产生一棵空树。但是这个空树会存在一个header节点：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-26.png" alt="image-20231108212304824" style="zoom:67%;" />

因为增加了一个header节点，所以在进行插入新结点时，不仅需要根据红黑树的规则进行调整，还必须维护header的正确性，令其父节点是根节点，左孩子是最小节点，右孩子是最大节点。

### 红黑树的元素操作

这里主要介绍红黑树的插入和查找操作。

#### 元素的插入操作

红黑树提供两种插入操作，一种是插入节点的键值（key）必须在整棵树中独一无二，即insert_unique()，如果已经存在相同的键值，那么插入就不会进行；另一种是插入节点的键值可以在树中重复，即insert_equal()。

下面以最简单的版本（只接受一个实值value表示被插入节点）说明，虽然只制定了value，但是通过KeyOfValue仿函数可以从value中获取key。

**insert_euqal：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-27.png" alt="image-20231109082641967" style="zoom:67%;" />

**insert_unique：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-28.png" alt="image-20231109084635562" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-29.png" alt="image-20231109084701450" style="zoom:67%;" />

下面以comp标准为“小于”，说明while循环结束之后的一段代码。

当while循环结束之后，此时x指向插入节点，y指向插入节点的父节点，并且y一定是叶子节点。（这是因为二叉搜索树寻找插入点的特性）此时y与x只有两种可能，要么x是y的左孩子，要么x是y的右孩子，下面分别讨论：

1.x是y的右孩子：
此时comp一定是false，因此x大于等于y才会是右孩子。因此跳过第一段if语句；
在第二段if语句中判断 j （此时与y相同）是否小于x，若是，则经过上面的条件(1)$y \le x$；和此时的条件(2)$y \lt x$可以得到y与x不同，因此可以正常插入；若否，则说明y与x相同。

2.x是y的左孩子：
此时comp一定是true，因此需要进入第一段if语句。首先判断当前的父节点是否为最左节点begin()，如果是，那么直接插入；否则就令 j 指向 y 节点的前一个节点；
接着判断 y 节点的前一个结点与 x 之间的关系。如果 j < x，结合上一步的条件 x < y，并且 j 是 y 的直接前驱，因此 x 不会发生重复；但是如果$j \ge x$，结合之前对于插入点的搜索过程，因为插入点在 j 的后面，所以$x \ge j$，此时就可以说明 j 与 x结点键值重复。

**真正的插入程序：__insert**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-30.png" alt="image-20231109091217740" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-31.png" alt="image-20231109092128794" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-32.png" alt="image-20231109092223023" style="zoom:67%;" />

在插入操作完成之后，需要进行调整操作，也就是上面的**__rb_tree_rebalance()函数**，使得整棵树满足红黑树的性质：

需要调整的情况在红黑树的插入操作已经分析过，下面这段代码不难理解：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-33.png" alt="image-20231109093530776" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-34.png" alt="image-20231109093943193" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-35.png" alt="image-20231109094017545" style="zoom:67%;" />

注：作者在这里说明上面的程序就是“自上而下的程序”，但是我的理解中这个程序对于树的调整是从插入点开始自下而上，并没有用到前面提到的针对父叔同色的改进方法。

下面是左旋和右旋操作的函数：

**左旋：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-36.png" alt="image-20231109094514372" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-37.png" alt="image-20231109095022913" style="zoom:67%;" />

**右旋：**

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-38.png" alt="image-20231109095052266" style="zoom:67%;" />

#### 元素的查找操作

由于红黑树是一个二叉搜索树，因此对于元素的查找非常简单：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-2-39.png" alt="image-20231109095322824" style="zoom:67%;" />

## set

### set概述

set（集合）中的所有元素都会根据元素的键自动被排序，每个元素的键(key)就是实值(value)。

set中不允许存在两个元素具有相同的键值，也就是不允许存在两个相同的元素。

正是由于set中实值就是键值，因此不能通过迭代器随意更改实值。set容器中底层实现是RB-tree，也就是说所有元素都是按照一定的键值顺序排列的，如果随意更改实值，那么键值也会随之改变，破坏了二叉搜索树的结构。

由于set和list一样均使用离散式存储结构（都以结点表示元素），因此当客户端进行新增操作或者删除操作时，操作之前的迭代器不会失效。

### set源代码摘录

由于RB-tree是一种平衡二叉搜索树，其自动排序以及查找的效率很不错，因此STL set以红黑树作为底层机制。

并且set需要对外开放的接口，均可以调用红黑树的接口来实现。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-1.png" alt="image-20231109192131007" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-2.png" alt="image-20231109192634762" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-3.png" alt="image-20231109192723713" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-4.png" alt="image-20231109193224489" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-5.png" alt="image-20231109193359150" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-6.png" alt="image-20231109193753483" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-7.png" alt="image-20231109193829693" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-8.png" alt="image-20231109194003348" style="zoom:67%;" />

### set的find操作

对于关联式容器来说，应该使用其内部提供的find函数来进行查找元素，这样比使用STL算法的find更有效率。

这是因为STL的算法只是根据迭代器遍历搜寻，而关联式容器的搜寻会基于其底层实现来进行搜寻，比如set的底层实现是红黑树，那么对于n个元素的搜寻效率是O(logn)，而STL的算法采用遍历搜寻，搜寻效率是O(n)。

## map

### map概述

map（字典）中的每一个元素都是一对键值（value）和实值（value），所有元素根根据**键值**（key）自动排序。

map中不允许存在键值相同的两个元素。

map中的每一个元素是一个pair，pair的第一元素是键值（key），第二元素是实值（value），定义如下：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-9.png" alt="image-20231109195524098" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-10.png" alt="image-20231109195541100" style="zoom:67%;" />

对于map来说，如果想要通过迭代器修改键值（key），这是不被允许的，因为键值关系到所有元素的排列规则；如果想要通过迭代器改变实值（value）是可以的。

由于map和set、list一样采用离散式存储结构，所以当进行增加、删除等操作之后，原来的迭代器仍然可以正常使用。

### map源代码摘录

map同样以RB-tree作为底层实现机制，并且map需要向外提供的接口，红黑树中已经提供，所以其实现比较简单：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-11.png" alt="image-20231109200334538" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-12.png" alt="image-20231109200522220" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-13.png" alt="image-20231109200709761" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-14.png" alt="image-20231109201115338" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-15.png" alt="image-20231109201153114" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-16.png" alt="image-20231109201254950" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-17.png" alt="image-20231109201453165" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-18.png" alt="image-20231109201649418" style="zoom:67%;" />

注意，在map的实现中，只要返回值是迭代器的函数，一般都有两个版本，一个返回普通迭代器，一个返回const 迭代器。

### 针对下标访问方式的说明

map中可以使用下标加键值的方式访问元素的实值：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-19.png" alt="image-20231109202647450" style="zoom:67%;" />

上面A式的说明：

```c++
// 首先，最内层创建一个元素对象：
// 这个元素对象的实值不重要
// 键值必须是通过[]传递的即可
value_type(k, T())；
    
    
// 接着，尝试调用insert函数将该元素根据键值key插入到红黑树中
// 假设键值已经存在，那么一定会找到这样一个键值为k的结点
insert(value_type(k, T()))；

    
// 插入操作返回值一个pair，第一个元素是迭代器，第二个元素表示是否能够插入
// 如果键值存在，那么第一个元素刚好就是要找的结点
(insert(value_type(k, T()))).first
// 解引用这个迭代器可以得到元素
*((insert(value_type(k, T()))).first)
// map的每个元素都是pair，第二个是value
(*((insert(value_type(k, T()))).first)).second

// 如果键值不存在就会报错
    
```



## multiset

multiset与set特性与用法与set基本相同，唯一的区别在于multiset允许键值重复，因此它的插入操作采用的是底层红黑树的insert_equal（set采用的是insert_unique）。

下面是multiset的源代码摘要，只列出与set的不同之处：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-20.png" alt="image-20231109205555864" style="zoom:80%;" />

## multimap

multimap的特性和用法与map完全相同，唯一的区别就是multimap允许键值重复，因此插入操作采用的是底层红黑树的insert_equal。

下面是源代码摘要，只列出与map的不同之处：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-3-21.png" alt="image-20231109205751827" style="zoom: 80%;" />

## hashtable

前言：hashtable是实现set和map的另一种底层机制，准确来说，在C++11之后，是实现unordered_set、unordered_map、unordered_multiset和unordered_multimap这四种无序关联式容器的底层机制。

但是由于书中使用的C++编译器是C++11之前的版本，因此这里的介绍在C++11标准之前，下面介绍的hashtable与正式标准存在一些差别，比如hash function的差别、C++增加了重映射策略等等。

尽管如此，这里剖析的hashtable在关键设计思想上与新标准一致，比如均使用开链法（链地址法）处理冲突，即使用bucket vector和linked list实现哈希表。

### hashtable概述

hash table（哈希表）能够对于其中的元素提供常数级时间的存取和删除操作。

实现方式就是利用一个hash函数（散列函数），将元素的值value映射到一个索引范围内，比如通过取模运算将任意整数X映射到[0, TableSize - 1]，那么TableSize是哈希表的大小，索引范围就是[0, TableSize - 1]。

哈希函数的问题是：如果元素的取值空间远大于索引的取值空间，那么有可能会导致不同的元素被映射到相同的位置，也就是发生了碰撞。对于碰撞的处理有以下几种处理方式：线性探测、二次探测、开链等。

#### **线性探测：**

当通过哈希函数计算出某个元素的插入位置时，如果当前位置已经存在元素，那么就依次向后寻找（如果遇到尾部就从头开始）。

查找时如果通过哈希函数计算出的插入位置不是当前元素，也是依次向后查找，直到遇到目标元素或者空位置。

删除时只标记删除记号，实际删除操作等待表格重新整理时再进行。

这种方法的缺点是：当哈希表中负载系数增大时，插入成本会剧烈增大。（负载系数指的是哈希表中当前元素个数）也就是说，如果当前表中元素越多，那么新元素越有可能在填充过元素的地方不断向后探测，直到找到合适的位置；而这个合适的位置又会增加未来新元素的插入成本。

#### **二次探测：**

如果插入时通过哈希函数计算出来的插入位置H已经存在元素，那么向后寻找的位置依次为：$H+1^{2},H+2^2,H+3^2,...$而不再像线性探测一样为：$H+1,H+2,H+3,...$

二次探测带来的疑问：

①线性探测每次探测的都必然是一个不同的位置，二次探测能够保证如此？二次探测能否保证如果表格之中没有X，那么我们插入X一定能够成功？
②线性探测的运算过程机器简单，二次探测则显式复杂一些。这是否会在执行效率上带来太多的负面影响
③不论线性探测还是二次探测，当负载稀疏过高时，表格能够够动态成长

对于①：假设表格大小为质数，其负载系数永远在0.5以下（也就是最多只装一半元素），那么就可以确定每插入一个新元素所需要的探测次数不多于2。（注，这是书中的结论，暂时没有理解）

对于②：至于复杂度问题，一般总是这样考虑：收获的比付出的多，才值得这么做。我们增加了探测次数，所获得的利益好歹比**二次函数计算所花的时间**多。线性探测需要的是一个加法（加1），一个测试（看是否回头），以及一个可能用到的减法（用以绕转回头）。二次探测需要的则是一个加法（从i-1到i）、一个乘法（计算$i^2$），另一个加法以及一个mod运算。看起来得不偿失。然而中间却又一些技巧，可以除去耗时的乘法和除法：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-1.png" alt="image-20231110085705418" style="zoom:80%;" />

因此，如果我们能够以前一个H值来计算下一个H值，就不需要执行二次方所需要的乘法了。虽然还是一个乘法，但那是乘以2，可以位移位快速完成。置于mod运算，也可证明并非真有需要。

对于③：array的增长。如果想要扩充表格，首先必须要找出下一个新的且足够大（大约两倍）的质数，然后考虑表格重建的成本——不仅要拷贝元素，还需要考虑元素在新表格中的位置然后再插入。

二次探测的缺点是：两个元素经由哈希函数计算出来的位置若相同，则插入时所探测的位置页相同，形成了某种浪费。消除次集团的方法也有，例如复式散列等。

#### **开链法（链地址法）：**

将所有索引值相同的元素存储在一个链表中，hash表只存储这些链表的头指针。

因此如果插入时发生冲突，也只需要在链表上增加一个结点。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-2.png" alt="image-20230411203449141" style="zoom:50%;" />

搜寻时如果发生冲突，需要在链表上进行线性搜寻，但是只要链表足够短，那么速度还是非常快。

（怎么使得链表足够短？发生冲突的次数尽量少，也就是hash表尽量大）



### hashtable的桶子(buckets)与节点(nodes)

SGI STL将hash table内的每一个元素称为桶子(bucket)，这样表述意思是说：哈希表中的每个单元，有可能是一”桶“元素。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-3.png" alt="image-20231110091002641" style="zoom:67%;" />

哈希表的节点定义为：

```c++
template <class Value>
struct __hashtable_node {
    __hashtable_node *next; // 指向下一个节点的指针
    Value val; // 节点的值
};
```

需要注意的是，bucket维护的链表，并不使用STL的list，而是自行维护节点。但是哈希表，也就是bucket的聚合体，以STL的vector完成，以便有动态扩充能力。

### hashtable的迭代器

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-4.png" alt="image-20231110091641514" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-5.png" alt="image-20231110091757795" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-6.png" alt="image-20231110091846728" style="zoom:67%;" />

hashtable的迭代器处理维持当前指向的bucket的节点的关联，还需要维持与整个hash表的关联。
这样前进操作从当前节点出发，通过节点的next指针访问下一个节点；如果当前节点恰好是当前bucket的尾端，则需要利用与hash表的关联跳转到下一个bucket上。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-7.png" alt="image-20231110092535725" style="zoom:67%;" />

由于hashtable迭代器是一个正向迭代器，所以没有后退操作。

### hashtable的数据结构

下面是hashtable的定义摘要，主要可以看出以vector装载buckets。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-8.png" alt="image-20231110093058115" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-9.png" alt="image-20231110093141110" style="zoom:67%;" />

hashtable的模板参数有：

- Value：节点的实值类型
- Key：节点的键值类型
- HashFcn：hash function的函数类型
- ExtractKey：从节点取出键值的方法（函数或仿函数）
- EqualKey：判断键值相同与否的方法（函数或仿函数）
- Alloc：空间配置器。缺省使用std::alloc

hash function是计算元素所在桶子索引的函数，这项任务交给**bkt_num**函数，由它调用hash function计算一个可以执行模运算的值。

**系统预定义的hash表大小：**

虽然链地址法并不要求哈希表大小必须为质数，但SGI STL仍然以质数来设计哈希表大小，并且先将28个质数（主键呈现大约2倍的关系）计算好，以备随时使用，同时提供一个函数，用来查询在这28个质数之中，“最接某数并大于某数”的质数

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-10.png" alt="image-20231110094504033" style="zoom: 80%;" />

### hashtable的构造与内存管理

#### **hashtable的构造**

在hashtable的定义式中定义了以节点为单位申请空间的配置器：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-11.png" alt="image-20231110103855006" style="zoom:67%;" />

节点配置函数和节点释放函数为：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-12.png" alt="image-20231110104101344" style="zoom:67%;" />

hash table没有默认构造函数，构造函数如下：需要指定bucket的个数

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-13.png" alt="image-20231110104247967" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-14.png" alt="image-20231110104446736" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-15.png" alt="image-20231110104658464" style="zoom:67%;" />

#### 元素插入(insert)和表格重整(resize)

##### 键值不允许重复的插入操作

hash table以**insert_unique**函数完成插入元素操作：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-16.png" alt="image-20231110105149344" style="zoom:67%;" />

该函数首先调用**resize**函数判断是否重建表格；之后调用**insert_unique_noresize**函数完成插入操作。

**resize：**表格重建与否的标准是：加入当前元素之后的元素个数与哈希表的大小（即bucket的数量）相比，如果前者大于后者就重建表格。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-17.png" alt="image-20231110110019834" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-18.png" alt="image-20231110111431233" style="zoom:67%;" />

将其中一个旧bucket中的元素移动到新的bucket的操作图解：（下面需要将#2中的55移动到对应的新#55中）

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-19.png" alt="image-20231110112558015" style="zoom: 67%;" />

**insert_unique_noresize：**经过重建处理，下面就是在不需要重建的情况下插入新节点，注意键值是不允许重复的

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-20.png" alt="image-20231110113514465" style="zoom:67%;" />

##### 键值允许重复的插入操作

**insert_qeual**函数允许键值重复的元素插入，同样是首先调用resize尝试重建表格，但是第二步调用的不再是insert_unique_noresize，而是**insert_equal_noresize**函数。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-21.png" alt="image-20231110113818743" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-22.png" alt="image-20231110114043348" style="zoom:67%;" />

### 判断新元素属于哪一个bucket(bkt_num)

判断元素属于哪一个bucket应该是hash function的任务，SGI在处理时包装一层，将任务交给**bkt_num**完成，在由此函数调用hash function，最终获得一个可以进行模运算的值。这是因为某些元素类型无法直接用于对hash table的大小模运算。

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-23.png" alt="image-20231110114722006" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-24.png" alt="image-20231110114831476" style="zoom:67%;" />

### 复制(copy_from)和清除(clear)操作

整个hash table由vector和linked-list组合而成，因此复制和清除时需要注意内存释放问题。

清除全部元素操作：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-25.png" alt="image-20231110151158958" style="zoom:67%;" />

复制另一个hash表的操作：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-26.png" alt="image-20231110151329199" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-27.png" alt="image-20231110151735292" style="zoom:67%;" />

### hash function

hash function用于将一个元素的键值key映射到[0, N - 1]，N是hash表中的bucket个数。

SGI将这个任务交由bkt_num来完成，这是因为元素的键值类型可能是非数值，比如const char*，bkt_num调用hash function，对于不同的键值类型取得一个可以对N进行模运算的值。大部分的hash function对于char、int、long等整数类型什么都不做，只是返回原值。但是对于字符串类型，设计一个转换函数为：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-28.png" alt="image-20231110154636866" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-29.png" alt="image-20231110154656325" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-7-30.png" alt="image-20231110154715953" style="zoom:67%;" />

由此，可以得知，如果hash funciton没有办法处理的类型，就需要用户自行定义针对这些类型的hash funciton。

**笔者注：**

侯捷先生使用这版SGI标准位于C++11之前，目前（2023年）的C++标准已经对于hash table进行了修订，目前的hash table采用的策略是h2(h1(k), N)，其中k表示键值，N为hash表大小，h1是一个hash function，将映射到[0, numeric_limits<size_t>:::max()]，h2是一个range-hashing function，将h1(k)映射到[0, N)。另外还增加了重映射策略等等。

因此这里的hash function仅供参考，说明一种设计思想。

## hash_set(C++11中的unordered_set)

之前介绍的set底层实现是RB-Tree（红黑树），但是SGI提供了另一种以hashtable作为底层机制的set（C++11标准中是unordered_set）

使用set的目的是快速查找元素，这一点不管是红黑树还是哈希表都能完成。但是底层实现是红黑树的set实际上是有序的，而底层实现是哈希表的set是无序的(注意，如果插入元素小于哈希表大小，那么可能会造成有序的假象)。

hash_set所有对外接口都由hashtable提供，所以hash_set的所有行为都是调用哈希表的行为。

注意set的元素键值就是实值，hash_set与set的使用方式完全相同。

下面是hasn_set的源代码摘录：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-8-1.png" alt="image-20231111082647551" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-8-2.png" alt="image-20231111082953021" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-8-3.png" alt="image-20231111083217683" style="zoom:67%;" />

<img src="D:\Blog\MyBlog\source\_posts\STL源码剖析\【STL源码剖析】系列十二：关联式容器-hashtable\5-7-32.png" alt="image-20231111083358643" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-8-4.png" alt="image-20231111083518185" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-8-5.png" alt="image-20231111084141988" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-8-6.png" alt="image-20231111084251327" style="zoom:67%;" />

## hash_map(C++11中的unorder_map)

与set一样，map也可以使用hashtable作为底层实现机制，表示为hash_map，使用与map完全一样。

hash_map内部元素同样是无序的。

下面是源代码摘录：

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-8-7.png" alt="image-20231111085126085" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-8-8.png" alt="image-20231111085326469" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-8-9.png" alt="image-20231111085816823" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-8-10.png" alt="image-20231111091116075" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-8-11.png" alt="image-20231111091304595" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-8-12.png" alt="image-20231111091714339" style="zoom:67%;" />

<img src="D:\RegularFile\C++\learning\2.C++进阶\2.STL源码剖析+源码\image\5-8-13.png" alt="image-20231111092032739" style="zoom:67%;" />

## hash_multiset(C++11中的unordered_multiset)

hash_multiset特性与multiset完全相同，唯一的区别就是底层实现是hashtable。

hash_multiset实现上与hash_set的唯一区别就是：前者的插入操作使用底层机制hashtable的insert_equal，而后者采用insert_unique。

因此这里不再列举源代码。



## hash_multimap(C++11中的unordered_map)

hash_multimap特性与multimap完全相同，唯一的区别就是底层实现是hashtable。

hash_multimap实现上与hash_map的唯一区别就是：前者的插入操作使用底层机制hashtable的insert_equal，而后者采用insert_unique。

因此这里不再列举源代码。

# 算法



































